//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armtestbase

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AccountListResult.
func (a AccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountListResult.
func (a *AccountListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountResource.
func (a AccountResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountResource.
func (a *AccountResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &a.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourceProperties.
func (a AccountResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessLevel", a.AccessLevel)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "sku", a.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountResourceProperties.
func (a *AccountResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessLevel":
			err = unpopulate(val, "AccessLevel", &a.AccessLevel)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &a.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountSKU.
func (a AccountSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capabilities", a.Capabilities)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "resourceType", a.ResourceType)
	populate(objectMap, "tier", a.Tier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountSKU.
func (a *AccountSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilities":
			err = unpopulate(val, "Capabilities", &a.Capabilities)
			delete(rawMsg, key)
		case "locations":
			err = unpopulate(val, "Locations", &a.Locations)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &a.ResourceType)
			delete(rawMsg, key)
		case "tier":
			err = unpopulate(val, "Tier", &a.Tier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountSKUCapability.
func (a AccountSKUCapability) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountSKUCapability.
func (a *AccountSKUCapability) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountSKUListResult.
func (a AccountSKUListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountSKUListResult.
func (a *AccountSKUListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUpdateParameterProperties.
func (a AccountUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sku", a.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountUpdateParameterProperties.
func (a *AccountUpdateParameterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sku":
			err = unpopulate(val, "SKU", &a.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUpdateParameters.
func (a AccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountUpdateParameters.
func (a *AccountUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &a.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUsageData.
func (a AccountUsageData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentValue", a.CurrentValue)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "limit", a.Limit)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "unit", a.Unit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountUsageData.
func (a *AccountUsageData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentValue":
			err = unpopulate(val, "CurrentValue", &a.CurrentValue)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, "Limit", &a.Limit)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, "Unit", &a.Unit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUsageDataList.
func (a AccountUsageDataList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountUsageDataList.
func (a *AccountUsageDataList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUsageName.
func (a AccountUsageName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "localizedValue", a.LocalizedValue)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountUsageName.
func (a *AccountUsageName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "localizedValue":
			err = unpopulate(val, "LocalizedValue", &a.LocalizedValue)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActionRequest.
func (a ActionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionRequest.
func (a *ActionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActionRequestProperties.
func (a ActionRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "creationDate", a.CreationDate)
	populate(objectMap, "preReleaseAccessRequestSpec", a.PreReleaseAccessRequestSpec)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "requestType", a.RequestType)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionRequestProperties.
func (a *ActionRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationDate":
			err = unpopulateTimeRFC3339(val, "CreationDate", &a.CreationDate)
			delete(rawMsg, key)
		case "preReleaseAccessRequestSpec":
			err = unpopulate(val, "PreReleaseAccessRequestSpec", &a.PreReleaseAccessRequestSpec)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "requestType":
			err = unpopulate(val, "RequestType", &a.RequestType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActionRequests.
func (a ActionRequests) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActionRequests.
func (a *ActionRequests) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalysisResultListResult.
func (a AnalysisResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalysisResultListResult.
func (a *AnalysisResultListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalysisResultSingletonResource.
func (a AnalysisResultSingletonResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalysisResultSingletonResource.
func (a *AnalysisResultSingletonResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAnalysisResultSingletonResourcePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalysisResultSingletonResourceProperties.
func (a AnalysisResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = a.AnalysisResultType
	populate(objectMap, "grade", a.Grade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalysisResultSingletonResourceProperties.
func (a *AnalysisResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &a.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &a.Grade)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnswerCitation.
func (a AnswerCitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "chunkIndex", a.ChunkIndex)
	populate(objectMap, "title", a.Title)
	populate(objectMap, "url", a.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnswerCitation.
func (a *AnswerCitation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "chunkIndex":
			err = unpopulate(val, "ChunkIndex", &a.ChunkIndex)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &a.Title)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableInplaceUpgradeOSListResult.
func (a AvailableInplaceUpgradeOSListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableInplaceUpgradeOSListResult.
func (a *AvailableInplaceUpgradeOSListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableInplaceUpgradeOSProperties.
func (a AvailableInplaceUpgradeOSProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "sourceOsName", a.SourceOsName)
	populate(objectMap, "sourceOsReleases", a.SourceOsReleases)
	populate(objectMap, "supportedTargetOsNameList", a.SupportedTargetOsNameList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableInplaceUpgradeOSProperties.
func (a *AvailableInplaceUpgradeOSProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "sourceOsName":
			err = unpopulate(val, "SourceOsName", &a.SourceOsName)
			delete(rawMsg, key)
		case "sourceOsReleases":
			err = unpopulate(val, "SourceOsReleases", &a.SourceOsReleases)
			delete(rawMsg, key)
		case "supportedTargetOsNameList":
			err = unpopulate(val, "SupportedTargetOsNameList", &a.SupportedTargetOsNameList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableInplaceUpgradeOSResource.
func (a AvailableInplaceUpgradeOSResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableInplaceUpgradeOSResource.
func (a *AvailableInplaceUpgradeOSResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOSListResult.
func (a AvailableOSListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableOSListResult.
func (a *AvailableOSListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOSProperties.
func (a AvailableOSProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "insiderChannel", a.InsiderChannel)
	populate(objectMap, "osId", a.OSID)
	populate(objectMap, "osName", a.OSName)
	populate(objectMap, "osPlatform", a.OSPlatform)
	populate(objectMap, "osUpdateType", a.OSUpdateType)
	populate(objectMap, "osVersion", a.OSVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableOSProperties.
func (a *AvailableOSProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "insiderChannel":
			err = unpopulate(val, "InsiderChannel", &a.InsiderChannel)
			delete(rawMsg, key)
		case "osId":
			err = unpopulate(val, "OSID", &a.OSID)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &a.OSName)
			delete(rawMsg, key)
		case "osPlatform":
			err = unpopulate(val, "OSPlatform", &a.OSPlatform)
			delete(rawMsg, key)
		case "osUpdateType":
			err = unpopulate(val, "OSUpdateType", &a.OSUpdateType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &a.OSVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOSResource.
func (a AvailableOSResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableOSResource.
func (a *AvailableOSResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubExecutionUsageDetail.
func (b BillingHubExecutionUsageDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", b.ApplicationName)
	populate(objectMap, "applicationVersion", b.ApplicationVersion)
	populate(objectMap, "billedCharges", b.BilledCharges)
	populateTimeRFC3339(objectMap, "endTimeStamp", b.EndTimeStamp)
	populate(objectMap, "executionRequestId", b.ExecutionRequestID)
	populate(objectMap, "meterId", b.MeterID)
	populate(objectMap, "osBuild", b.OSBuild)
	populate(objectMap, "release", b.Release)
	populate(objectMap, "sku", b.SKU)
	populateTimeRFC3339(objectMap, "startTimeStamp", b.StartTimeStamp)
	populate(objectMap, "testType", b.TestType)
	populate(objectMap, "updateType", b.UpdateType)
	populate(objectMap, "usedBillableHours", b.UsedBillableHours)
	populate(objectMap, "usedFreeHours", b.UsedFreeHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubExecutionUsageDetail.
func (b *BillingHubExecutionUsageDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &b.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, "ApplicationVersion", &b.ApplicationVersion)
			delete(rawMsg, key)
		case "billedCharges":
			err = unpopulate(val, "BilledCharges", &b.BilledCharges)
			delete(rawMsg, key)
		case "endTimeStamp":
			err = unpopulateTimeRFC3339(val, "EndTimeStamp", &b.EndTimeStamp)
			delete(rawMsg, key)
		case "executionRequestId":
			err = unpopulate(val, "ExecutionRequestID", &b.ExecutionRequestID)
			delete(rawMsg, key)
		case "meterId":
			err = unpopulate(val, "MeterID", &b.MeterID)
			delete(rawMsg, key)
		case "osBuild":
			err = unpopulate(val, "OSBuild", &b.OSBuild)
			delete(rawMsg, key)
		case "release":
			err = unpopulate(val, "Release", &b.Release)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &b.SKU)
			delete(rawMsg, key)
		case "startTimeStamp":
			err = unpopulateTimeRFC3339(val, "StartTimeStamp", &b.StartTimeStamp)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &b.TestType)
			delete(rawMsg, key)
		case "updateType":
			err = unpopulate(val, "UpdateType", &b.UpdateType)
			delete(rawMsg, key)
		case "usedBillableHours":
			err = unpopulate(val, "UsedBillableHours", &b.UsedBillableHours)
			delete(rawMsg, key)
		case "usedFreeHours":
			err = unpopulate(val, "UsedFreeHours", &b.UsedFreeHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubFreeHourIncrementEntry.
func (b BillingHubFreeHourIncrementEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createTimeStamp", b.CreateTimeStamp)
	populateTimeRFC3339(objectMap, "expirationTimeStamp", b.ExpirationTimeStamp)
	populate(objectMap, "freeHourStatus", b.FreeHourStatus)
	populate(objectMap, "freeHourType", b.FreeHourType)
	populate(objectMap, "incrementalFreeHours", b.IncrementalFreeHours)
	populate(objectMap, "remainingFreeHours", b.RemainingFreeHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubFreeHourIncrementEntry.
func (b *BillingHubFreeHourIncrementEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTimeStamp":
			err = unpopulateTimeRFC3339(val, "CreateTimeStamp", &b.CreateTimeStamp)
			delete(rawMsg, key)
		case "expirationTimeStamp":
			err = unpopulateTimeRFC3339(val, "ExpirationTimeStamp", &b.ExpirationTimeStamp)
			delete(rawMsg, key)
		case "freeHourStatus":
			err = unpopulate(val, "FreeHourStatus", &b.FreeHourStatus)
			delete(rawMsg, key)
		case "freeHourType":
			err = unpopulate(val, "FreeHourType", &b.FreeHourType)
			delete(rawMsg, key)
		case "incrementalFreeHours":
			err = unpopulate(val, "IncrementalFreeHours", &b.IncrementalFreeHours)
			delete(rawMsg, key)
		case "remainingFreeHours":
			err = unpopulate(val, "RemainingFreeHours", &b.RemainingFreeHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubGetFreeHourBalanceResponse.
func (b BillingHubGetFreeHourBalanceResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "incrementEntries", b.IncrementEntries)
	populate(objectMap, "totalRemainingFreeHours", b.TotalRemainingFreeHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubGetFreeHourBalanceResponse.
func (b *BillingHubGetFreeHourBalanceResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "incrementEntries":
			err = unpopulate(val, "IncrementEntries", &b.IncrementEntries)
			delete(rawMsg, key)
		case "totalRemainingFreeHours":
			err = unpopulate(val, "TotalRemainingFreeHours", &b.TotalRemainingFreeHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubGetUsageRequest.
func (b BillingHubGetUsageRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "endTimeStamp", b.EndTimeStamp)
	populate(objectMap, "pageIndex", b.PageIndex)
	populate(objectMap, "pageSize", b.PageSize)
	populateTimeRFC3339(objectMap, "startTimeStamp", b.StartTimeStamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubGetUsageRequest.
func (b *BillingHubGetUsageRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTimeStamp":
			err = unpopulateTimeRFC3339(val, "EndTimeStamp", &b.EndTimeStamp)
			delete(rawMsg, key)
		case "pageIndex":
			err = unpopulate(val, "PageIndex", &b.PageIndex)
			delete(rawMsg, key)
		case "pageSize":
			err = unpopulate(val, "PageSize", &b.PageSize)
			delete(rawMsg, key)
		case "startTimeStamp":
			err = unpopulateTimeRFC3339(val, "StartTimeStamp", &b.StartTimeStamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubGetUsageResponse.
func (b BillingHubGetUsageResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextRequest", b.NextRequest)
	populate(objectMap, "packageUsageEntries", b.PackageUsageEntries)
	populate(objectMap, "totalCharges", b.TotalCharges)
	populate(objectMap, "totalUsedBillableHours", b.TotalUsedBillableHours)
	populate(objectMap, "totalUsedFreeHours", b.TotalUsedFreeHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubGetUsageResponse.
func (b *BillingHubGetUsageResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextRequest":
			err = unpopulate(val, "NextRequest", &b.NextRequest)
			delete(rawMsg, key)
		case "packageUsageEntries":
			err = unpopulate(val, "PackageUsageEntries", &b.PackageUsageEntries)
			delete(rawMsg, key)
		case "totalCharges":
			err = unpopulate(val, "TotalCharges", &b.TotalCharges)
			delete(rawMsg, key)
		case "totalUsedBillableHours":
			err = unpopulate(val, "TotalUsedBillableHours", &b.TotalUsedBillableHours)
			delete(rawMsg, key)
		case "totalUsedFreeHours":
			err = unpopulate(val, "TotalUsedFreeHours", &b.TotalUsedFreeHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubPackageUsage.
func (b BillingHubPackageUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", b.ApplicationName)
	populate(objectMap, "applicationVersion", b.ApplicationVersion)
	populate(objectMap, "azureResourceUri", b.AzureResourceURI)
	populate(objectMap, "totalCharges", b.TotalCharges)
	populate(objectMap, "totalUsedBillableHours", b.TotalUsedBillableHours)
	populate(objectMap, "totalUsedFreeHours", b.TotalUsedFreeHours)
	populate(objectMap, "usageEntriesGroupedByUpdateType", b.UsageEntriesGroupedByUpdateType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubPackageUsage.
func (b *BillingHubPackageUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &b.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, "ApplicationVersion", &b.ApplicationVersion)
			delete(rawMsg, key)
		case "azureResourceUri":
			err = unpopulate(val, "AzureResourceURI", &b.AzureResourceURI)
			delete(rawMsg, key)
		case "totalCharges":
			err = unpopulate(val, "TotalCharges", &b.TotalCharges)
			delete(rawMsg, key)
		case "totalUsedBillableHours":
			err = unpopulate(val, "TotalUsedBillableHours", &b.TotalUsedBillableHours)
			delete(rawMsg, key)
		case "totalUsedFreeHours":
			err = unpopulate(val, "TotalUsedFreeHours", &b.TotalUsedFreeHours)
			delete(rawMsg, key)
		case "usageEntriesGroupedByUpdateType":
			err = unpopulate(val, "UsageEntriesGroupedByUpdateType", &b.UsageEntriesGroupedByUpdateType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubUsage.
func (b BillingHubUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", b.ApplicationName)
	populate(objectMap, "applicationVersion", b.ApplicationVersion)
	populate(objectMap, "azureResourceUri", b.AzureResourceURI)
	populate(objectMap, "totalCharges", b.TotalCharges)
	populate(objectMap, "totalUsedBillableHours", b.TotalUsedBillableHours)
	populate(objectMap, "totalUsedFreeHours", b.TotalUsedFreeHours)
	populate(objectMap, "usageGroups", b.UsageGroups)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubUsage.
func (b *BillingHubUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &b.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, "ApplicationVersion", &b.ApplicationVersion)
			delete(rawMsg, key)
		case "azureResourceUri":
			err = unpopulate(val, "AzureResourceURI", &b.AzureResourceURI)
			delete(rawMsg, key)
		case "totalCharges":
			err = unpopulate(val, "TotalCharges", &b.TotalCharges)
			delete(rawMsg, key)
		case "totalUsedBillableHours":
			err = unpopulate(val, "TotalUsedBillableHours", &b.TotalUsedBillableHours)
			delete(rawMsg, key)
		case "totalUsedFreeHours":
			err = unpopulate(val, "TotalUsedFreeHours", &b.TotalUsedFreeHours)
			delete(rawMsg, key)
		case "usageGroups":
			err = unpopulate(val, "UsageGroups", &b.UsageGroups)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubUsageGroup.
func (b BillingHubUsageGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "executionUsageDetails", b.ExecutionUsageDetails)
	populate(objectMap, "osBuild", b.OSBuild)
	populate(objectMap, "productFamily", b.ProductFamily)
	populate(objectMap, "release", b.Release)
	populateTimeRFC3339(objectMap, "releaseBuildDate", b.ReleaseBuildDate)
	populate(objectMap, "releaseBuildNumber", b.ReleaseBuildNumber)
	populate(objectMap, "releaseBuildRevision", b.ReleaseBuildRevision)
	populate(objectMap, "testType", b.TestType)
	populate(objectMap, "totalCharges", b.TotalCharges)
	populate(objectMap, "totalUsedBillableHours", b.TotalUsedBillableHours)
	populate(objectMap, "totalUsedFreeHours", b.TotalUsedFreeHours)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubUsageGroup.
func (b *BillingHubUsageGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionUsageDetails":
			err = unpopulate(val, "ExecutionUsageDetails", &b.ExecutionUsageDetails)
			delete(rawMsg, key)
		case "osBuild":
			err = unpopulate(val, "OSBuild", &b.OSBuild)
			delete(rawMsg, key)
		case "productFamily":
			err = unpopulate(val, "ProductFamily", &b.ProductFamily)
			delete(rawMsg, key)
		case "release":
			err = unpopulate(val, "Release", &b.Release)
			delete(rawMsg, key)
		case "releaseBuildDate":
			err = unpopulateTimeRFC3339(val, "ReleaseBuildDate", &b.ReleaseBuildDate)
			delete(rawMsg, key)
		case "releaseBuildNumber":
			err = unpopulate(val, "ReleaseBuildNumber", &b.ReleaseBuildNumber)
			delete(rawMsg, key)
		case "releaseBuildRevision":
			err = unpopulate(val, "ReleaseBuildRevision", &b.ReleaseBuildRevision)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &b.TestType)
			delete(rawMsg, key)
		case "totalCharges":
			err = unpopulate(val, "TotalCharges", &b.TotalCharges)
			delete(rawMsg, key)
		case "totalUsedBillableHours":
			err = unpopulate(val, "TotalUsedBillableHours", &b.TotalUsedBillableHours)
			delete(rawMsg, key)
		case "totalUsedFreeHours":
			err = unpopulate(val, "TotalUsedFreeHours", &b.TotalUsedFreeHours)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BillingHubUsageGroupedByUpdateType.
func (b BillingHubUsageGroupedByUpdateType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "totalCharges", b.TotalCharges)
	populate(objectMap, "totalUsedBillableHours", b.TotalUsedBillableHours)
	populate(objectMap, "totalUsedFreeHours", b.TotalUsedFreeHours)
	populate(objectMap, "updateType", b.UpdateType)
	populate(objectMap, "usageGroups", b.UsageGroups)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BillingHubUsageGroupedByUpdateType.
func (b *BillingHubUsageGroupedByUpdateType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "totalCharges":
			err = unpopulate(val, "TotalCharges", &b.TotalCharges)
			delete(rawMsg, key)
		case "totalUsedBillableHours":
			err = unpopulate(val, "TotalUsedBillableHours", &b.TotalUsedBillableHours)
			delete(rawMsg, key)
		case "totalUsedFreeHours":
			err = unpopulate(val, "TotalUsedFreeHours", &b.TotalUsedFreeHours)
			delete(rawMsg, key)
		case "updateType":
			err = unpopulate(val, "UpdateType", &b.UpdateType)
			delete(rawMsg, key)
		case "usageGroups":
			err = unpopulate(val, "UsageGroups", &b.UsageGroups)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CPURegressionResultSingletonResourceProperties.
func (c CPURegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeCPURegression
	populate(objectMap, "cpuRegressionResults", c.CPURegressionResults)
	populate(objectMap, "grade", c.Grade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CPURegressionResultSingletonResourceProperties.
func (c *CPURegressionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &c.AnalysisResultType)
			delete(rawMsg, key)
		case "cpuRegressionResults":
			err = unpopulate(val, "CPURegressionResults", &c.CPURegressionResults)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &c.Grade)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CPUUtilizationResultSingletonResourceProperties.
func (c CPUUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeCPUUtilization
	populate(objectMap, "cpuUtilizationResults", c.CPUUtilizationResults)
	populate(objectMap, "grade", c.Grade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CPUUtilizationResultSingletonResourceProperties.
func (c *CPUUtilizationResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &c.AnalysisResultType)
			delete(rawMsg, key)
		case "cpuUtilizationResults":
			err = unpopulate(val, "CPUUtilizationResults", &c.CPUUtilizationResults)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &c.Grade)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatRequest.
func (c ChatRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "question", c.Question)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatRequest.
func (c *ChatRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "question":
			err = unpopulate(val, "Question", &c.Question)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatResponse.
func (c ChatResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatResponse.
func (c *ChatResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatResponseProperties.
func (c ChatResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "answer", c.Answer)
	populate(objectMap, "citations", c.Citations)
	populate(objectMap, "limit", c.Limit)
	populate(objectMap, "question", c.Question)
	populate(objectMap, "usage", c.Usage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatResponseProperties.
func (c *ChatResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "answer":
			err = unpopulate(val, "Answer", &c.Answer)
			delete(rawMsg, key)
		case "citations":
			err = unpopulate(val, "Citations", &c.Citations)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, "Limit", &c.Limit)
			delete(rawMsg, key)
		case "question":
			err = unpopulate(val, "Question", &c.Question)
			delete(rawMsg, key)
		case "usage":
			err = unpopulate(val, "Usage", &c.Usage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatSessionProperties.
func (c ChatSessionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatSessionProperties.
func (c *ChatSessionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatSessionResource.
func (c ChatSessionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatSessionResource.
func (c *ChatSessionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ChatSessionResourceListResult.
func (c ChatSessionResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChatSessionResourceListResult.
func (c *ChatSessionResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CheckNameAvailabilityResult.
func (c CheckNameAvailabilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "nameAvailable", c.NameAvailable)
	populate(objectMap, "reason", c.Reason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CheckNameAvailabilityResult.
func (c *CheckNameAvailabilityResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "message":
			err = unpopulate(val, "Message", &c.Message)
			delete(rawMsg, key)
		case "nameAvailable":
			err = unpopulate(val, "NameAvailable", &c.NameAvailable)
			delete(rawMsg, key)
		case "reason":
			err = unpopulate(val, "Reason", &c.Reason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Command.
func (c Command) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", c.Action)
	populate(objectMap, "alwaysRun", c.AlwaysRun)
	populate(objectMap, "applyUpdateBefore", c.ApplyUpdateBefore)
	populate(objectMap, "content", c.Content)
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "enrollIntuneBefore", c.EnrollIntuneBefore)
	populate(objectMap, "install1PAppBefore", c.Install1PAppBefore)
	populate(objectMap, "maxRunTime", c.MaxRunTime)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "postUpgrade", c.PostUpgrade)
	populate(objectMap, "preUpgrade", c.PreUpgrade)
	populate(objectMap, "restartAfter", c.RestartAfter)
	populate(objectMap, "runAsInteractive", c.RunAsInteractive)
	populate(objectMap, "runElevated", c.RunElevated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Command.
func (c *Command) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &c.Action)
			delete(rawMsg, key)
		case "alwaysRun":
			err = unpopulate(val, "AlwaysRun", &c.AlwaysRun)
			delete(rawMsg, key)
		case "applyUpdateBefore":
			err = unpopulate(val, "ApplyUpdateBefore", &c.ApplyUpdateBefore)
			delete(rawMsg, key)
		case "content":
			err = unpopulate(val, "Content", &c.Content)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, "ContentType", &c.ContentType)
			delete(rawMsg, key)
		case "enrollIntuneBefore":
			err = unpopulate(val, "EnrollIntuneBefore", &c.EnrollIntuneBefore)
			delete(rawMsg, key)
		case "install1PAppBefore":
			err = unpopulate(val, "Install1PAppBefore", &c.Install1PAppBefore)
			delete(rawMsg, key)
		case "maxRunTime":
			err = unpopulate(val, "MaxRunTime", &c.MaxRunTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "postUpgrade":
			err = unpopulate(val, "PostUpgrade", &c.PostUpgrade)
			delete(rawMsg, key)
		case "preUpgrade":
			err = unpopulate(val, "PreUpgrade", &c.PreUpgrade)
			delete(rawMsg, key)
		case "restartAfter":
			err = unpopulate(val, "RestartAfter", &c.RestartAfter)
			delete(rawMsg, key)
		case "runAsInteractive":
			err = unpopulate(val, "RunAsInteractive", &c.RunAsInteractive)
			delete(rawMsg, key)
		case "runElevated":
			err = unpopulate(val, "RunElevated", &c.RunElevated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyFromPackageOperationParameters.
func (c CopyFromPackageOperationParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "packageId", c.PackageID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyFromPackageOperationParameters.
func (c *CopyFromPackageOperationParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packageId":
			err = unpopulate(val, "PackageID", &c.PackageID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CredentialListResult.
func (c CredentialListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialListResult.
func (c *CredentialListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CredentialProperties.
func (c CredentialProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = c.CredentialType
	populate(objectMap, "displayName", c.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialProperties.
func (c *CredentialProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &c.CredentialType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CredentialResource.
func (c CredentialResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CredentialResource.
func (c *CredentialResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			c.Properties, err = unmarshalCredentialPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomImageListResult.
func (c CustomImageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomImageListResult.
func (c *CustomImageListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomImageProperties.
func (c CustomImageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "creationTime", c.CreationTime)
	populate(objectMap, "definitionName", c.DefinitionName)
	populate(objectMap, "osDiskImageSizeInGB", c.OSDiskImageSizeInGB)
	populate(objectMap, "product", c.Product)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "release", c.Release)
	populateTimeRFC3339(objectMap, "releaseVersionDate", c.ReleaseVersionDate)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "validationResults", c.ValidationResults)
	populate(objectMap, "versionName", c.VersionName)
	populate(objectMap, "vhdFileName", c.VhdFileName)
	populate(objectMap, "vhdId", c.VhdID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomImageProperties.
func (c *CustomImageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, "CreationTime", &c.CreationTime)
			delete(rawMsg, key)
		case "definitionName":
			err = unpopulate(val, "DefinitionName", &c.DefinitionName)
			delete(rawMsg, key)
		case "osDiskImageSizeInGB":
			err = unpopulate(val, "OSDiskImageSizeInGB", &c.OSDiskImageSizeInGB)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &c.Product)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "release":
			err = unpopulate(val, "Release", &c.Release)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, "ReleaseVersionDate", &c.ReleaseVersionDate)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "validationResults":
			err = unpopulate(val, "ValidationResults", &c.ValidationResults)
			delete(rawMsg, key)
		case "versionName":
			err = unpopulate(val, "VersionName", &c.VersionName)
			delete(rawMsg, key)
		case "vhdFileName":
			err = unpopulate(val, "VhdFileName", &c.VhdFileName)
			delete(rawMsg, key)
		case "vhdId":
			err = unpopulate(val, "VhdID", &c.VhdID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomImageResource.
func (c CustomImageResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomImageResource.
func (c *CustomImageResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEventListResult.
func (c CustomerEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerEventListResult.
func (c *CustomerEventListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEventProperties.
func (c CustomerEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eventName", c.EventName)
	populate(objectMap, "receivers", c.Receivers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerEventProperties.
func (c *CustomerEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eventName":
			err = unpopulate(val, "EventName", &c.EventName)
			delete(rawMsg, key)
		case "receivers":
			err = unpopulate(val, "Receivers", &c.Receivers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEventResource.
func (c CustomerEventResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerEventResource.
func (c *CustomerEventResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionGroupListReceiverValue.
func (d DistributionGroupListReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionGroups", d.DistributionGroups)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionGroupListReceiverValue.
func (d *DistributionGroupListReceiverValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionGroups":
			err = unpopulate(val, "DistributionGroups", &d.DistributionGroups)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DownloadURLResponse.
func (d DownloadURLResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "downloadUrl", d.DownloadURL)
	populateTimeRFC3339(objectMap, "expirationTime", d.ExpirationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadURLResponse.
func (d *DownloadURLResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "downloadUrl":
			err = unpopulate(val, "DownloadURL", &d.DownloadURL)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, "ExpirationTime", &d.ExpirationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageGetPathResponse.
func (d DraftPackageGetPathResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseUrl", d.BaseURL)
	populate(objectMap, "draftPackagePath", d.DraftPackagePath)
	populateTimeRFC3339(objectMap, "expirationTime", d.ExpirationTime)
	populate(objectMap, "sasToken", d.SasToken)
	populate(objectMap, "workingPath", d.WorkingPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageGetPathResponse.
func (d *DraftPackageGetPathResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUrl":
			err = unpopulate(val, "BaseURL", &d.BaseURL)
			delete(rawMsg, key)
		case "draftPackagePath":
			err = unpopulate(val, "DraftPackagePath", &d.DraftPackagePath)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, "ExpirationTime", &d.ExpirationTime)
			delete(rawMsg, key)
		case "sasToken":
			err = unpopulate(val, "SasToken", &d.SasToken)
			delete(rawMsg, key)
		case "workingPath":
			err = unpopulate(val, "WorkingPath", &d.WorkingPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageIntuneAppMetadata.
func (d DraftPackageIntuneAppMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "intuneApp", d.IntuneApp)
	populate(objectMap, "intuneAppDependencies", d.IntuneAppDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageIntuneAppMetadata.
func (d *DraftPackageIntuneAppMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "intuneApp":
			err = unpopulate(val, "IntuneApp", &d.IntuneApp)
			delete(rawMsg, key)
		case "intuneAppDependencies":
			err = unpopulate(val, "IntuneAppDependencies", &d.IntuneAppDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageIntuneAppMetadataItem.
func (d DraftPackageIntuneAppMetadataItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appId", d.AppID)
	populate(objectMap, "appName", d.AppName)
	populateTimeRFC3339(objectMap, "createDate", d.CreateDate)
	populate(objectMap, "dependencyIds", d.DependencyIDs)
	populate(objectMap, "dependentAppCount", d.DependentAppCount)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "expectedExitCodes", d.ExpectedExitCodes)
	populate(objectMap, "installCommand", d.InstallCommand)
	populate(objectMap, "lastProcessed", d.LastProcessed)
	populate(objectMap, "minimumSupportedOS", d.MinimumSupportedOS)
	populate(objectMap, "owner", d.Owner)
	populate(objectMap, "publisher", d.Publisher)
	populate(objectMap, "setupFile", d.SetupFile)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "uninstallCommand", d.UninstallCommand)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageIntuneAppMetadataItem.
func (d *DraftPackageIntuneAppMetadataItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
			err = unpopulate(val, "AppID", &d.AppID)
			delete(rawMsg, key)
		case "appName":
			err = unpopulate(val, "AppName", &d.AppName)
			delete(rawMsg, key)
		case "createDate":
			err = unpopulateTimeRFC3339(val, "CreateDate", &d.CreateDate)
			delete(rawMsg, key)
		case "dependencyIds":
			err = unpopulate(val, "DependencyIDs", &d.DependencyIDs)
			delete(rawMsg, key)
		case "dependentAppCount":
			err = unpopulate(val, "DependentAppCount", &d.DependentAppCount)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "expectedExitCodes":
			err = unpopulate(val, "ExpectedExitCodes", &d.ExpectedExitCodes)
			delete(rawMsg, key)
		case "installCommand":
			err = unpopulate(val, "InstallCommand", &d.InstallCommand)
			delete(rawMsg, key)
		case "lastProcessed":
			err = unpopulate(val, "LastProcessed", &d.LastProcessed)
			delete(rawMsg, key)
		case "minimumSupportedOS":
			err = unpopulate(val, "MinimumSupportedOS", &d.MinimumSupportedOS)
			delete(rawMsg, key)
		case "owner":
			err = unpopulate(val, "Owner", &d.Owner)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &d.Publisher)
			delete(rawMsg, key)
		case "setupFile":
			err = unpopulate(val, "SetupFile", &d.SetupFile)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "uninstallCommand":
			err = unpopulate(val, "UninstallCommand", &d.UninstallCommand)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageListResult.
func (d DraftPackageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageListResult.
func (d *DraftPackageListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageProperties.
func (d DraftPackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appFileName", d.AppFileName)
	populate(objectMap, "applicationName", d.ApplicationName)
	populate(objectMap, "comments", d.Comments)
	populate(objectMap, "draftPackagePath", d.DraftPackagePath)
	populate(objectMap, "editPackage", d.EditPackage)
	populate(objectMap, "executableLaunchCommand", d.ExecutableLaunchCommand)
	populate(objectMap, "firstPartyApps", d.FirstPartyApps)
	populate(objectMap, "flightingRing", d.FlightingRing)
	populate(objectMap, "galleryApps", d.GalleryApps)
	populate(objectMap, "highlightedFiles", d.HighlightedFiles)
	populate(objectMap, "inplaceUpgradeOSPair", d.InplaceUpgradeOSPair)
	populate(objectMap, "intuneEnrollmentMetadata", d.IntuneEnrollmentMetadata)
	populate(objectMap, "intuneMetadata", d.IntuneMetadata)
	populateTimeRFC3339(objectMap, "lastModifiedTime", d.LastModifiedTime)
	populate(objectMap, "packageId", d.PackageID)
	populate(objectMap, "packageTags", d.PackageTags)
	populate(objectMap, "processName", d.ProcessName)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "sourceType", d.SourceType)
	populate(objectMap, "tabState", d.TabState)
	populate(objectMap, "targetOSList", d.TargetOSList)
	populate(objectMap, "testTypes", d.TestTypes)
	populate(objectMap, "tests", d.Tests)
	populate(objectMap, "useAutofill", d.UseAutofill)
	populate(objectMap, "useSample", d.UseSample)
	populate(objectMap, "version", d.Version)
	populate(objectMap, "workingPath", d.WorkingPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageProperties.
func (d *DraftPackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appFileName":
			err = unpopulate(val, "AppFileName", &d.AppFileName)
			delete(rawMsg, key)
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &d.ApplicationName)
			delete(rawMsg, key)
		case "comments":
			err = unpopulate(val, "Comments", &d.Comments)
			delete(rawMsg, key)
		case "draftPackagePath":
			err = unpopulate(val, "DraftPackagePath", &d.DraftPackagePath)
			delete(rawMsg, key)
		case "editPackage":
			err = unpopulate(val, "EditPackage", &d.EditPackage)
			delete(rawMsg, key)
		case "executableLaunchCommand":
			err = unpopulate(val, "ExecutableLaunchCommand", &d.ExecutableLaunchCommand)
			delete(rawMsg, key)
		case "firstPartyApps":
			err = unpopulate(val, "FirstPartyApps", &d.FirstPartyApps)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &d.FlightingRing)
			delete(rawMsg, key)
		case "galleryApps":
			err = unpopulate(val, "GalleryApps", &d.GalleryApps)
			delete(rawMsg, key)
		case "highlightedFiles":
			err = unpopulate(val, "HighlightedFiles", &d.HighlightedFiles)
			delete(rawMsg, key)
		case "inplaceUpgradeOSPair":
			err = unpopulate(val, "InplaceUpgradeOSPair", &d.InplaceUpgradeOSPair)
			delete(rawMsg, key)
		case "intuneEnrollmentMetadata":
			err = unpopulate(val, "IntuneEnrollmentMetadata", &d.IntuneEnrollmentMetadata)
			delete(rawMsg, key)
		case "intuneMetadata":
			err = unpopulate(val, "IntuneMetadata", &d.IntuneMetadata)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &d.LastModifiedTime)
			delete(rawMsg, key)
		case "packageId":
			err = unpopulate(val, "PackageID", &d.PackageID)
			delete(rawMsg, key)
		case "packageTags":
			err = unpopulate(val, "PackageTags", &d.PackageTags)
			delete(rawMsg, key)
		case "processName":
			err = unpopulate(val, "ProcessName", &d.ProcessName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, "SourceType", &d.SourceType)
			delete(rawMsg, key)
		case "tabState":
			err = unpopulate(val, "TabState", &d.TabState)
			delete(rawMsg, key)
		case "targetOSList":
			err = unpopulate(val, "TargetOSList", &d.TargetOSList)
			delete(rawMsg, key)
		case "testTypes":
			err = unpopulate(val, "TestTypes", &d.TestTypes)
			delete(rawMsg, key)
		case "tests":
			err = unpopulate(val, "Tests", &d.Tests)
			delete(rawMsg, key)
		case "useAutofill":
			err = unpopulate(val, "UseAutofill", &d.UseAutofill)
			delete(rawMsg, key)
		case "useSample":
			err = unpopulate(val, "UseSample", &d.UseSample)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		case "workingPath":
			err = unpopulate(val, "WorkingPath", &d.WorkingPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageResource.
func (d DraftPackageResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageResource.
func (d *DraftPackageResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageUpdateParameterProperties.
func (d DraftPackageUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appFileName", d.AppFileName)
	populate(objectMap, "applicationName", d.ApplicationName)
	populate(objectMap, "comments", d.Comments)
	populate(objectMap, "executableLaunchCommand", d.ExecutableLaunchCommand)
	populate(objectMap, "firstPartyApps", d.FirstPartyApps)
	populate(objectMap, "flightingRing", d.FlightingRing)
	populate(objectMap, "galleryApps", d.GalleryApps)
	populate(objectMap, "highlightedFiles", d.HighlightedFiles)
	populate(objectMap, "inplaceUpgradeOSPair", d.InplaceUpgradeOSPair)
	populate(objectMap, "intuneEnrollmentMetadata", d.IntuneEnrollmentMetadata)
	populate(objectMap, "intuneMetadata", d.IntuneMetadata)
	populate(objectMap, "packageId", d.PackageID)
	populate(objectMap, "packageTags", d.PackageTags)
	populate(objectMap, "processName", d.ProcessName)
	populate(objectMap, "sourceType", d.SourceType)
	populate(objectMap, "tabState", d.TabState)
	populate(objectMap, "targetOSList", d.TargetOSList)
	populate(objectMap, "testTypes", d.TestTypes)
	populate(objectMap, "tests", d.Tests)
	populate(objectMap, "useAutofill", d.UseAutofill)
	populate(objectMap, "useSample", d.UseSample)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageUpdateParameterProperties.
func (d *DraftPackageUpdateParameterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appFileName":
			err = unpopulate(val, "AppFileName", &d.AppFileName)
			delete(rawMsg, key)
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &d.ApplicationName)
			delete(rawMsg, key)
		case "comments":
			err = unpopulate(val, "Comments", &d.Comments)
			delete(rawMsg, key)
		case "executableLaunchCommand":
			err = unpopulate(val, "ExecutableLaunchCommand", &d.ExecutableLaunchCommand)
			delete(rawMsg, key)
		case "firstPartyApps":
			err = unpopulate(val, "FirstPartyApps", &d.FirstPartyApps)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &d.FlightingRing)
			delete(rawMsg, key)
		case "galleryApps":
			err = unpopulate(val, "GalleryApps", &d.GalleryApps)
			delete(rawMsg, key)
		case "highlightedFiles":
			err = unpopulate(val, "HighlightedFiles", &d.HighlightedFiles)
			delete(rawMsg, key)
		case "inplaceUpgradeOSPair":
			err = unpopulate(val, "InplaceUpgradeOSPair", &d.InplaceUpgradeOSPair)
			delete(rawMsg, key)
		case "intuneEnrollmentMetadata":
			err = unpopulate(val, "IntuneEnrollmentMetadata", &d.IntuneEnrollmentMetadata)
			delete(rawMsg, key)
		case "intuneMetadata":
			err = unpopulate(val, "IntuneMetadata", &d.IntuneMetadata)
			delete(rawMsg, key)
		case "packageId":
			err = unpopulate(val, "PackageID", &d.PackageID)
			delete(rawMsg, key)
		case "packageTags":
			err = unpopulate(val, "PackageTags", &d.PackageTags)
			delete(rawMsg, key)
		case "processName":
			err = unpopulate(val, "ProcessName", &d.ProcessName)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, "SourceType", &d.SourceType)
			delete(rawMsg, key)
		case "tabState":
			err = unpopulate(val, "TabState", &d.TabState)
			delete(rawMsg, key)
		case "targetOSList":
			err = unpopulate(val, "TargetOSList", &d.TargetOSList)
			delete(rawMsg, key)
		case "testTypes":
			err = unpopulate(val, "TestTypes", &d.TestTypes)
			delete(rawMsg, key)
		case "tests":
			err = unpopulate(val, "Tests", &d.Tests)
			delete(rawMsg, key)
		case "useAutofill":
			err = unpopulate(val, "UseAutofill", &d.UseAutofill)
			delete(rawMsg, key)
		case "useSample":
			err = unpopulate(val, "UseSample", &d.UseSample)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DraftPackageUpdateParameters.
func (d DraftPackageUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DraftPackageUpdateParameters.
func (d *DraftPackageUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailEventListResult.
func (e EmailEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailEventListResult.
func (e *EmailEventListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailEventProperties.
func (e EmailEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "eventId", e.EventID)
	populate(objectMap, "eventName", e.EventName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailEventProperties.
func (e *EmailEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "eventId":
			err = unpopulate(val, "EventID", &e.EventID)
			delete(rawMsg, key)
		case "eventName":
			err = unpopulate(val, "EventName", &e.EventName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailEventResource.
func (e EmailEventResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailEventResource.
func (e *EmailEventResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnrolledIntuneApp.
func (e EnrolledIntuneApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appId", e.AppID)
	populate(objectMap, "appName", e.AppName)
	populate(objectMap, "expectedInstallationPath", e.ExpectedInstallationPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnrolledIntuneApp.
func (e *EnrolledIntuneApp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
			err = unpopulate(val, "AppID", &e.AppID)
			delete(rawMsg, key)
		case "appName":
			err = unpopulate(val, "AppName", &e.AppName)
			delete(rawMsg, key)
		case "expectedInstallationPath":
			err = unpopulate(val, "ExpectedInstallationPath", &e.ExpectedInstallationPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
			err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtractFileOperationParameters.
func (e ExtractFileOperationParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileType", e.FileType)
	populate(objectMap, "intuneAppId", e.IntuneAppID)
	populate(objectMap, "sourceFile", e.SourceFile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtractFileOperationParameters.
func (e *ExtractFileOperationParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileType":
			err = unpopulate(val, "FileType", &e.FileType)
			delete(rawMsg, key)
		case "intuneAppId":
			err = unpopulate(val, "IntuneAppID", &e.IntuneAppID)
			delete(rawMsg, key)
		case "sourceFile":
			err = unpopulate(val, "SourceFile", &e.SourceFile)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FavoriteProcessListResult.
func (f FavoriteProcessListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FavoriteProcessListResult.
func (f *FavoriteProcessListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FavoriteProcessProperties.
func (f FavoriteProcessProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualProcessName", f.ActualProcessName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FavoriteProcessProperties.
func (f *FavoriteProcessProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualProcessName":
			err = unpopulate(val, "ActualProcessName", &f.ActualProcessName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FavoriteProcessResource.
func (f FavoriteProcessResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FavoriteProcessResource.
func (f *FavoriteProcessResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FeatureUpdateSupportedOsesProperties.
func (f FeatureUpdateSupportedOsesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baselineProducts", f.BaselineProducts)
	populate(objectMap, "displayText", f.DisplayText)
	populate(objectMap, "insiderChannel", f.InsiderChannel)
	populate(objectMap, "osId", f.OSID)
	populate(objectMap, "osName", f.OSName)
	populateTimeRFC3339(objectMap, "startTime", f.StartTime)
	populate(objectMap, "state", f.State)
	populate(objectMap, "version", f.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FeatureUpdateSupportedOsesProperties.
func (f *FeatureUpdateSupportedOsesProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baselineProducts":
			err = unpopulate(val, "BaselineProducts", &f.BaselineProducts)
			delete(rawMsg, key)
		case "displayText":
			err = unpopulate(val, "DisplayText", &f.DisplayText)
			delete(rawMsg, key)
		case "insiderChannel":
			err = unpopulate(val, "InsiderChannel", &f.InsiderChannel)
			delete(rawMsg, key)
		case "osId":
			err = unpopulate(val, "OSID", &f.OSID)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &f.OSName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &f.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &f.State)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &f.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FeatureUpdateSupportedOsesResource.
func (f FeatureUpdateSupportedOsesResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FeatureUpdateSupportedOsesResource.
func (f *FeatureUpdateSupportedOsesResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FeatureUpdateSupportedOsesResult.
func (f FeatureUpdateSupportedOsesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FeatureUpdateSupportedOsesResult.
func (f *FeatureUpdateSupportedOsesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileUploadURLResponse.
func (f FileUploadURLResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobPath", f.BlobPath)
	populate(objectMap, "uploadUrl", f.UploadURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileUploadURLResponse.
func (f *FileUploadURLResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobPath":
			err = unpopulate(val, "BlobPath", &f.BlobPath)
			delete(rawMsg, key)
		case "uploadUrl":
			err = unpopulate(val, "UploadURL", &f.UploadURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FirstPartyAppDefinition.
func (f FirstPartyAppDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", f.Architecture)
	populate(objectMap, "channel", f.Channel)
	populate(objectMap, "interopExecutionMode", f.InteropExecutionMode)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "ring", f.Ring)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FirstPartyAppDefinition.
func (f *FirstPartyAppDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &f.Architecture)
			delete(rawMsg, key)
		case "channel":
			err = unpopulate(val, "Channel", &f.Channel)
			delete(rawMsg, key)
		case "interopExecutionMode":
			err = unpopulate(val, "InteropExecutionMode", &f.InteropExecutionMode)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "ring":
			err = unpopulate(val, "Ring", &f.Ring)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FirstPartyAppListResult.
func (f FirstPartyAppListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FirstPartyAppListResult.
func (f *FirstPartyAppListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FirstPartyAppProperties.
func (f FirstPartyAppProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", f.Architecture)
	populate(objectMap, "channel", f.Channel)
	populate(objectMap, "mediaType", f.MediaType)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "ring", f.Ring)
	populate(objectMap, "supportedProducts", f.SupportedProducts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FirstPartyAppProperties.
func (f *FirstPartyAppProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &f.Architecture)
			delete(rawMsg, key)
		case "channel":
			err = unpopulate(val, "Channel", &f.Channel)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, "MediaType", &f.MediaType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &f.ProvisioningState)
			delete(rawMsg, key)
		case "ring":
			err = unpopulate(val, "Ring", &f.Ring)
			delete(rawMsg, key)
		case "supportedProducts":
			err = unpopulate(val, "SupportedProducts", &f.SupportedProducts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FirstPartyAppResource.
func (f FirstPartyAppResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FirstPartyAppResource.
func (f *FirstPartyAppResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlightingRingListResult.
func (f FlightingRingListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlightingRingListResult.
func (f *FlightingRingListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlightingRingProperties.
func (f FlightingRingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualFlightingRingName", f.ActualFlightingRingName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlightingRingProperties.
func (f *FlightingRingProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualFlightingRingName":
			err = unpopulate(val, "ActualFlightingRingName", &f.ActualFlightingRingName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlightingRingResource.
func (f FlightingRingResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlightingRingResource.
func (f *FlightingRingResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FreeHourBalanceResource.
func (f FreeHourBalanceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FreeHourBalanceResource.
func (f *FreeHourBalanceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FreeHourBalancesListResult.
func (f FreeHourBalancesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FreeHourBalancesListResult.
func (f *FreeHourBalancesListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppDefinition.
func (g GalleryAppDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isConsented", g.IsConsented)
	populate(objectMap, "skuId", g.SKUID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppDefinition.
func (g *GalleryAppDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isConsented":
			err = unpopulate(val, "IsConsented", &g.IsConsented)
			delete(rawMsg, key)
		case "skuId":
			err = unpopulate(val, "SKUID", &g.SKUID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppListResult.
func (g GalleryAppListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppListResult.
func (g *GalleryAppListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppProperties.
func (g GalleryAppProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", g.ApplicationID)
	populate(objectMap, "applicationName", g.ApplicationName)
	populate(objectMap, "applicationType", g.ApplicationType)
	populate(objectMap, "popularity", g.Popularity)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppProperties.
func (g *GalleryAppProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &g.ApplicationID)
			delete(rawMsg, key)
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &g.ApplicationName)
			delete(rawMsg, key)
		case "applicationType":
			err = unpopulate(val, "ApplicationType", &g.ApplicationType)
			delete(rawMsg, key)
		case "popularity":
			err = unpopulate(val, "Popularity", &g.Popularity)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppResource.
func (g GalleryAppResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppResource.
func (g *GalleryAppResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppSKUListResult.
func (g GalleryAppSKUListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppSKUListResult.
func (g *GalleryAppSKUListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppSKUProperties.
func (g GalleryAppSKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["applicationType"] = g.ApplicationType
	populate(objectMap, "provisioningState", g.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppSKUProperties.
func (g *GalleryAppSKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationType":
			err = unpopulate(val, "ApplicationType", &g.ApplicationType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GalleryAppSKUResource.
func (g GalleryAppSKUResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GalleryAppSKUResource.
func (g *GalleryAppSKUResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			g.Properties, err = unmarshalGalleryAppSKUPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateOperationParameters.
func (g GenerateOperationParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "forceGenerate", g.ForceGenerate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateOperationParameters.
func (g *GenerateOperationParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceGenerate":
			err = unpopulate(val, "ForceGenerate", &g.ForceGenerate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetFileUploadURLParameters.
func (g GetFileUploadURLParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobName", g.BlobName)
	populate(objectMap, "resourceType", g.ResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetFileUploadURLParameters.
func (g *GetFileUploadURLParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobName":
			err = unpopulate(val, "BlobName", &g.BlobName)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &g.ResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetImageDefinitionParameters.
func (g GetImageDefinitionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "definitionName", g.DefinitionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetImageDefinitionParameters.
func (g *GetImageDefinitionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definitionName":
			err = unpopulate(val, "DefinitionName", &g.DefinitionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HighlightedFile.
func (h HighlightedFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "path", h.Path)
	populate(objectMap, "sections", h.Sections)
	populate(objectMap, "visited", h.Visited)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HighlightedFile.
func (h *HighlightedFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &h.Path)
			delete(rawMsg, key)
		case "sections":
			err = unpopulate(val, "Sections", &h.Sections)
			delete(rawMsg, key)
		case "visited":
			err = unpopulate(val, "Visited", &h.Visited)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentifiedFailure.
func (i IdentifiedFailure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", i.Category)
	populate(objectMap, "errorMessage", i.ErrorMessage)
	populate(objectMap, "failureId", i.FailureID)
	populate(objectMap, "guidance", i.Guidance)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentifiedFailure.
func (i *IdentifiedFailure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &i.Category)
			delete(rawMsg, key)
		case "errorMessage":
			err = unpopulate(val, "ErrorMessage", &i.ErrorMessage)
			delete(rawMsg, key)
		case "failureId":
			err = unpopulate(val, "FailureID", &i.FailureID)
			delete(rawMsg, key)
		case "guidance":
			err = unpopulate(val, "Guidance", &i.Guidance)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageDefinitionListResult.
func (i ImageDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageDefinitionListResult.
func (i *ImageDefinitionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageDefinitionProperties.
func (i ImageDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", i.Architecture)
	populate(objectMap, "osState", i.OSState)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "securityType", i.SecurityType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageDefinitionProperties.
func (i *ImageDefinitionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &i.Architecture)
			delete(rawMsg, key)
		case "osState":
			err = unpopulate(val, "OSState", &i.OSState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		case "securityType":
			err = unpopulate(val, "SecurityType", &i.SecurityType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageDefinitionResource.
func (i ImageDefinitionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageDefinitionResource.
func (i *ImageDefinitionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageDefinitionsListResult.
func (i ImageDefinitionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageDefinitionsListResult.
func (i *ImageDefinitionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageNameCheckAvailabilityParameters.
func (i ImageNameCheckAvailabilityParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "definitionName", i.DefinitionName)
	populate(objectMap, "versionName", i.VersionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageNameCheckAvailabilityParameters.
func (i *ImageNameCheckAvailabilityParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definitionName":
			err = unpopulate(val, "DefinitionName", &i.DefinitionName)
			delete(rawMsg, key)
		case "versionName":
			err = unpopulate(val, "VersionName", &i.VersionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageValidationResults.
func (i ImageValidationResults) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "results", i.Results)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageValidationResults.
func (i *ImageValidationResults) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "results":
			err = unpopulate(val, "Results", &i.Results)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InplaceUpgradeOSInfo.
func (i InplaceUpgradeOSInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baselineOS", i.BaselineOS)
	populate(objectMap, "targetOS", i.TargetOS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InplaceUpgradeOSInfo.
func (i *InplaceUpgradeOSInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baselineOS":
			err = unpopulate(val, "BaselineOS", &i.BaselineOS)
			delete(rawMsg, key)
		case "targetOS":
			err = unpopulate(val, "TargetOS", &i.TargetOS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InplaceUpgradeProperties.
func (i InplaceUpgradeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baselineBuildNumber", i.BaselineBuildNumber)
	populate(objectMap, "baselineBuildRevision", i.BaselineBuildRevision)
	populate(objectMap, "baselineKbNumber", i.BaselineKbNumber)
	populate(objectMap, "baselineOsName", i.BaselineOsName)
	populate(objectMap, "baselineReleaseName", i.BaselineReleaseName)
	populateTimeRFC3339(objectMap, "baselineReleaseVersionDate", i.BaselineReleaseVersionDate)
	populate(objectMap, "customImageDisplayName", i.CustomImageDisplayName)
	populate(objectMap, "customImageId", i.CustomImageID)
	populateTimeRFC3339(objectMap, "upgradeEndTime", i.UpgradeEndTime)
	populateTimeRFC3339(objectMap, "upgradeStartTime", i.UpgradeStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InplaceUpgradeProperties.
func (i *InplaceUpgradeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baselineBuildNumber":
			err = unpopulate(val, "BaselineBuildNumber", &i.BaselineBuildNumber)
			delete(rawMsg, key)
		case "baselineBuildRevision":
			err = unpopulate(val, "BaselineBuildRevision", &i.BaselineBuildRevision)
			delete(rawMsg, key)
		case "baselineKbNumber":
			err = unpopulate(val, "BaselineKbNumber", &i.BaselineKbNumber)
			delete(rawMsg, key)
		case "baselineOsName":
			err = unpopulate(val, "BaselineOsName", &i.BaselineOsName)
			delete(rawMsg, key)
		case "baselineReleaseName":
			err = unpopulate(val, "BaselineReleaseName", &i.BaselineReleaseName)
			delete(rawMsg, key)
		case "baselineReleaseVersionDate":
			err = unpopulateTimeRFC3339(val, "BaselineReleaseVersionDate", &i.BaselineReleaseVersionDate)
			delete(rawMsg, key)
		case "customImageDisplayName":
			err = unpopulate(val, "CustomImageDisplayName", &i.CustomImageDisplayName)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &i.CustomImageID)
			delete(rawMsg, key)
		case "upgradeEndTime":
			err = unpopulateTimeRFC3339(val, "UpgradeEndTime", &i.UpgradeEndTime)
			delete(rawMsg, key)
		case "upgradeStartTime":
			err = unpopulateTimeRFC3339(val, "UpgradeStartTime", &i.UpgradeStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntuneEnrollmentMetadata.
func (i IntuneEnrollmentMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appList", i.AppList)
	populate(objectMap, "credentialId", i.CredentialID)
	populate(objectMap, "expectedDeploymentDurationInMinute", i.ExpectedDeploymentDurationInMinute)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntuneEnrollmentMetadata.
func (i *IntuneEnrollmentMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appList":
			err = unpopulate(val, "AppList", &i.AppList)
			delete(rawMsg, key)
		case "credentialId":
			err = unpopulate(val, "CredentialID", &i.CredentialID)
			delete(rawMsg, key)
		case "expectedDeploymentDurationInMinute":
			err = unpopulate(val, "ExpectedDeploymentDurationInMinute", &i.ExpectedDeploymentDurationInMinute)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IntuneSingletonResourceProperties.
func (i IntuneSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeIntuneAccount
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "passwordKeyVaultSecretPath", i.PasswordKeyVaultSecretPath)
	populate(objectMap, "userNameKeyVaultSecretPath", i.UserNameKeyVaultSecretPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntuneSingletonResourceProperties.
func (i *IntuneSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &i.CredentialType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &i.DisplayName)
			delete(rawMsg, key)
		case "passwordKeyVaultSecretPath":
			err = unpopulate(val, "PasswordKeyVaultSecretPath", &i.PasswordKeyVaultSecretPath)
			delete(rawMsg, key)
		case "userNameKeyVaultSecretPath":
			err = unpopulate(val, "UserNameKeyVaultSecretPath", &i.UserNameKeyVaultSecretPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MemoryRegressionResultSingletonResourceProperties.
func (m MemoryRegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeMemoryRegression
	populate(objectMap, "grade", m.Grade)
	populate(objectMap, "memoryRegressionResults", m.MemoryRegressionResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MemoryRegressionResultSingletonResourceProperties.
func (m *MemoryRegressionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &m.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &m.Grade)
			delete(rawMsg, key)
		case "memoryRegressionResults":
			err = unpopulate(val, "MemoryRegressionResults", &m.MemoryRegressionResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MemoryUtilizationResultSingletonResourceProperties.
func (m MemoryUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeMemoryUtilization
	populate(objectMap, "grade", m.Grade)
	populate(objectMap, "memoryUtilizationResults", m.MemoryUtilizationResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MemoryUtilizationResultSingletonResourceProperties.
func (m *MemoryUtilizationResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &m.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &m.Grade)
			delete(rawMsg, key)
		case "memoryUtilizationResults":
			err = unpopulate(val, "MemoryUtilizationResults", &m.MemoryUtilizationResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NotificationEventReceiver.
func (n NotificationEventReceiver) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "receiverType", n.ReceiverType)
	populate(objectMap, "receiverValue", n.ReceiverValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotificationEventReceiver.
func (n *NotificationEventReceiver) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "receiverType":
			err = unpopulate(val, "ReceiverType", &n.ReceiverType)
			delete(rawMsg, key)
		case "receiverValue":
			err = unpopulate(val, "ReceiverValue", &n.ReceiverValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NotificationReceiverValue.
func (n NotificationReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionGroupListReceiverValue", n.DistributionGroupListReceiverValue)
	populate(objectMap, "subscriptionReceiverValue", n.SubscriptionReceiverValue)
	populate(objectMap, "userObjectReceiverValue", n.UserObjectReceiverValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotificationReceiverValue.
func (n *NotificationReceiverValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionGroupListReceiverValue":
			err = unpopulate(val, "DistributionGroupListReceiverValue", &n.DistributionGroupListReceiverValue)
			delete(rawMsg, key)
		case "subscriptionReceiverValue":
			err = unpopulate(val, "SubscriptionReceiverValue", &n.SubscriptionReceiverValue)
			delete(rawMsg, key)
		case "userObjectReceiverValue":
			err = unpopulate(val, "UserObjectReceiverValue", &n.UserObjectReceiverValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateListResult.
func (o OSUpdateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateListResult.
func (o *OSUpdateListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateProperties.
func (o OSUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "buildRevision", o.BuildRevision)
	populate(objectMap, "buildVersion", o.BuildVersion)
	populate(objectMap, "customImageDisplayName", o.CustomImageDisplayName)
	populate(objectMap, "customImageId", o.CustomImageID)
	populate(objectMap, "flightingRing", o.FlightingRing)
	populate(objectMap, "inplaceUpgradeBaselineProperties", o.InplaceUpgradeBaselineProperties)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "release", o.Release)
	populateTimeRFC3339(objectMap, "releaseVersionDate", o.ReleaseVersionDate)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateProperties.
func (o *OSUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "buildRevision":
			err = unpopulate(val, "BuildRevision", &o.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, "BuildVersion", &o.BuildVersion)
			delete(rawMsg, key)
		case "customImageDisplayName":
			err = unpopulate(val, "CustomImageDisplayName", &o.CustomImageDisplayName)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &o.CustomImageID)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &o.FlightingRing)
			delete(rawMsg, key)
		case "inplaceUpgradeBaselineProperties":
			err = unpopulate(val, "InplaceUpgradeBaselineProperties", &o.InplaceUpgradeBaselineProperties)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &o.OSName)
			delete(rawMsg, key)
		case "release":
			err = unpopulate(val, "Release", &o.Release)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, "ReleaseVersionDate", &o.ReleaseVersionDate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateResource.
func (o OSUpdateResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateResource.
func (o *OSUpdateResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateTestSummary.
func (o OSUpdateTestSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "buildRevision", o.BuildRevision)
	populate(objectMap, "buildVersion", o.BuildVersion)
	populate(objectMap, "customImageDisplayName", o.CustomImageDisplayName)
	populate(objectMap, "customImageId", o.CustomImageID)
	populate(objectMap, "executionStatus", o.ExecutionStatus)
	populate(objectMap, "flightingRing", o.FlightingRing)
	populate(objectMap, "grade", o.Grade)
	populate(objectMap, "inplaceUpgradeBaselineProperties", o.InplaceUpgradeBaselineProperties)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "releaseName", o.ReleaseName)
	populateTimeRFC3339(objectMap, "releaseVersionDate", o.ReleaseVersionDate)
	populate(objectMap, "testRunTime", o.TestRunTime)
	populate(objectMap, "testStatus", o.TestStatus)
	populate(objectMap, "testType", o.TestType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateTestSummary.
func (o *OSUpdateTestSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "buildRevision":
			err = unpopulate(val, "BuildRevision", &o.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, "BuildVersion", &o.BuildVersion)
			delete(rawMsg, key)
		case "customImageDisplayName":
			err = unpopulate(val, "CustomImageDisplayName", &o.CustomImageDisplayName)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &o.CustomImageID)
			delete(rawMsg, key)
		case "executionStatus":
			err = unpopulate(val, "ExecutionStatus", &o.ExecutionStatus)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &o.FlightingRing)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &o.Grade)
			delete(rawMsg, key)
		case "inplaceUpgradeBaselineProperties":
			err = unpopulate(val, "InplaceUpgradeBaselineProperties", &o.InplaceUpgradeBaselineProperties)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &o.OSName)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, "ReleaseName", &o.ReleaseName)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, "ReleaseVersionDate", &o.ReleaseVersionDate)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, "TestRunTime", &o.TestRunTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, "TestStatus", &o.TestStatus)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &o.TestType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdatesTestSummary.
func (o OSUpdatesTestSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "executionStatus", o.ExecutionStatus)
	populate(objectMap, "grade", o.Grade)
	populate(objectMap, "osUpdateTestSummaries", o.OSUpdateTestSummaries)
	populate(objectMap, "testRunTime", o.TestRunTime)
	populate(objectMap, "testStatus", o.TestStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdatesTestSummary.
func (o *OSUpdatesTestSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionStatus":
			err = unpopulate(val, "ExecutionStatus", &o.ExecutionStatus)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &o.Grade)
			delete(rawMsg, key)
		case "osUpdateTestSummaries":
			err = unpopulate(val, "OSUpdateTestSummaries", &o.OSUpdateTestSummaries)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, "TestRunTime", &o.TestRunTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, "TestStatus", &o.TestStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsProperties.
func (o OsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customImageDisplayName", o.CustomImageDisplayName)
	populate(objectMap, "customImageId", o.CustomImageID)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "releaseProperties", o.ReleaseProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsProperties.
func (o *OsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customImageDisplayName":
			err = unpopulate(val, "CustomImageDisplayName", &o.CustomImageDisplayName)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &o.CustomImageID)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &o.OSName)
			delete(rawMsg, key)
		case "releaseProperties":
			err = unpopulate(val, "ReleaseProperties", &o.ReleaseProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageCheckNameAvailabilityParameters.
func (p PackageCheckNameAvailabilityParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", p.ApplicationName)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "type", p.Type)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageCheckNameAvailabilityParameters.
func (p *PackageCheckNameAvailabilityParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &p.ApplicationName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageListResult.
func (p PackageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageListResult.
func (p *PackageListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageProperties.
func (p PackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", p.ApplicationName)
	populate(objectMap, "blobPath", p.BlobPath)
	populate(objectMap, "draftPackageId", p.DraftPackageID)
	populate(objectMap, "firstPartyApps", p.FirstPartyApps)
	populate(objectMap, "flightingRing", p.FlightingRing)
	populate(objectMap, "galleryApps", p.GalleryApps)
	populate(objectMap, "inplaceUpgradeOSPair", p.InplaceUpgradeOSPair)
	populate(objectMap, "intuneEnrollmentMetadata", p.IntuneEnrollmentMetadata)
	populate(objectMap, "isEnabled", p.IsEnabled)
	populateTimeRFC3339(objectMap, "lastModifiedTime", p.LastModifiedTime)
	populate(objectMap, "packageStatus", p.PackageStatus)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "targetOSList", p.TargetOSList)
	populate(objectMap, "testTypes", p.TestTypes)
	populate(objectMap, "tests", p.Tests)
	populate(objectMap, "validationResults", p.ValidationResults)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageProperties.
func (p *PackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &p.ApplicationName)
			delete(rawMsg, key)
		case "blobPath":
			err = unpopulate(val, "BlobPath", &p.BlobPath)
			delete(rawMsg, key)
		case "draftPackageId":
			err = unpopulate(val, "DraftPackageID", &p.DraftPackageID)
			delete(rawMsg, key)
		case "firstPartyApps":
			err = unpopulate(val, "FirstPartyApps", &p.FirstPartyApps)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &p.FlightingRing)
			delete(rawMsg, key)
		case "galleryApps":
			err = unpopulate(val, "GalleryApps", &p.GalleryApps)
			delete(rawMsg, key)
		case "inplaceUpgradeOSPair":
			err = unpopulate(val, "InplaceUpgradeOSPair", &p.InplaceUpgradeOSPair)
			delete(rawMsg, key)
		case "intuneEnrollmentMetadata":
			err = unpopulate(val, "IntuneEnrollmentMetadata", &p.IntuneEnrollmentMetadata)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &p.IsEnabled)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &p.LastModifiedTime)
			delete(rawMsg, key)
		case "packageStatus":
			err = unpopulate(val, "PackageStatus", &p.PackageStatus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "targetOSList":
			err = unpopulate(val, "TargetOSList", &p.TargetOSList)
			delete(rawMsg, key)
		case "testTypes":
			err = unpopulate(val, "TestTypes", &p.TestTypes)
			delete(rawMsg, key)
		case "tests":
			err = unpopulate(val, "Tests", &p.Tests)
			delete(rawMsg, key)
		case "validationResults":
			err = unpopulate(val, "ValidationResults", &p.ValidationResults)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageResource.
func (p PackageResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageResource.
func (p *PackageResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &p.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageRunTestParameters.
func (p PackageRunTestParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customImageId", p.CustomImageID)
	populate(objectMap, "flightingRing", p.FlightingRing)
	populate(objectMap, "osName", p.OSName)
	populate(objectMap, "osUpdateType", p.OSUpdateType)
	populate(objectMap, "releaseName", p.ReleaseName)
	populate(objectMap, "testType", p.TestType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageRunTestParameters.
func (p *PackageRunTestParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &p.CustomImageID)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &p.FlightingRing)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &p.OSName)
			delete(rawMsg, key)
		case "osUpdateType":
			err = unpopulate(val, "OSUpdateType", &p.OSUpdateType)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, "ReleaseName", &p.ReleaseName)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &p.TestType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageUpdateParameterProperties.
func (p PackageUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobPath", p.BlobPath)
	populate(objectMap, "draftPackageId", p.DraftPackageID)
	populate(objectMap, "firstPartyApps", p.FirstPartyApps)
	populate(objectMap, "flightingRing", p.FlightingRing)
	populate(objectMap, "inplaceUpgradeOSPair", p.InplaceUpgradeOSPair)
	populate(objectMap, "intuneEnrollmentMetadata", p.IntuneEnrollmentMetadata)
	populate(objectMap, "isEnabled", p.IsEnabled)
	populate(objectMap, "targetOSList", p.TargetOSList)
	populate(objectMap, "tests", p.Tests)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageUpdateParameterProperties.
func (p *PackageUpdateParameterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobPath":
			err = unpopulate(val, "BlobPath", &p.BlobPath)
			delete(rawMsg, key)
		case "draftPackageId":
			err = unpopulate(val, "DraftPackageID", &p.DraftPackageID)
			delete(rawMsg, key)
		case "firstPartyApps":
			err = unpopulate(val, "FirstPartyApps", &p.FirstPartyApps)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &p.FlightingRing)
			delete(rawMsg, key)
		case "inplaceUpgradeOSPair":
			err = unpopulate(val, "InplaceUpgradeOSPair", &p.InplaceUpgradeOSPair)
			delete(rawMsg, key)
		case "intuneEnrollmentMetadata":
			err = unpopulate(val, "IntuneEnrollmentMetadata", &p.IntuneEnrollmentMetadata)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &p.IsEnabled)
			delete(rawMsg, key)
		case "targetOSList":
			err = unpopulate(val, "TargetOSList", &p.TargetOSList)
			delete(rawMsg, key)
		case "tests":
			err = unpopulate(val, "Tests", &p.Tests)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageUpdateParameters.
func (p PackageUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageUpdateParameters.
func (p *PackageUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PackageValidationResult.
func (p PackageValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", p.Errors)
	populate(objectMap, "isValid", p.IsValid)
	populate(objectMap, "validationName", p.ValidationName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageValidationResult.
func (p *PackageValidationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &p.Errors)
			delete(rawMsg, key)
		case "isValid":
			err = unpopulate(val, "IsValid", &p.IsValid)
			delete(rawMsg, key)
		case "validationName":
			err = unpopulate(val, "ValidationName", &p.ValidationName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PreReleaseAccessRequestSpec.
func (p PreReleaseAccessRequestSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "city", p.City)
	populate(objectMap, "companyWebsite", p.CompanyWebsite)
	populate(objectMap, "countryAndRegion", p.CountryAndRegion)
	populate(objectMap, "email", p.Email)
	populate(objectMap, "engagements", p.Engagements)
	populate(objectMap, "organizationName", p.OrganizationName)
	populate(objectMap, "stateOrProvince", p.StateOrProvince)
	populate(objectMap, "streetAddress", p.StreetAddress)
	populate(objectMap, "zipCode", p.ZipCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PreReleaseAccessRequestSpec.
func (p *PreReleaseAccessRequestSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "city":
			err = unpopulate(val, "City", &p.City)
			delete(rawMsg, key)
		case "companyWebsite":
			err = unpopulate(val, "CompanyWebsite", &p.CompanyWebsite)
			delete(rawMsg, key)
		case "countryAndRegion":
			err = unpopulate(val, "CountryAndRegion", &p.CountryAndRegion)
			delete(rawMsg, key)
		case "email":
			err = unpopulate(val, "Email", &p.Email)
			delete(rawMsg, key)
		case "engagements":
			err = unpopulate(val, "Engagements", &p.Engagements)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, "OrganizationName", &p.OrganizationName)
			delete(rawMsg, key)
		case "stateOrProvince":
			err = unpopulate(val, "StateOrProvince", &p.StateOrProvince)
			delete(rawMsg, key)
		case "streetAddress":
			err = unpopulate(val, "StreetAddress", &p.StreetAddress)
			delete(rawMsg, key)
		case "zipCode":
			err = unpopulate(val, "ZipCode", &p.ZipCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProxyResource.
func (p ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyResource.
func (p *ProxyResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegressionResult.
func (r RegressionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", r.Details)
	populate(objectMap, "diff", r.Diff)
	populate(objectMap, "fileName", r.FileName)
	populate(objectMap, "grade", r.Grade)
	populate(objectMap, "isRegressed", r.IsRegressed)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegressionResult.
func (r *RegressionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
			err = unpopulate(val, "Details", &r.Details)
			delete(rawMsg, key)
		case "diff":
			err = unpopulate(val, "Diff", &r.Diff)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &r.FileName)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &r.Grade)
			delete(rawMsg, key)
		case "isRegressed":
			err = unpopulate(val, "IsRegressed", &r.IsRegressed)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegressionTestDetails.
func (r RegressionTestDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diff", r.Diff)
	populate(objectMap, "isRegressed", r.IsRegressed)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegressionTestDetails.
func (r *RegressionTestDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diff":
			err = unpopulate(val, "Diff", &r.Diff)
			delete(rawMsg, key)
		case "isRegressed":
			err = unpopulate(val, "IsRegressed", &r.IsRegressed)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReleaseProperties.
func (r ReleaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "buildNumber", r.BuildNumber)
	populate(objectMap, "buildRevision", r.BuildRevision)
	populate(objectMap, "releaseName", r.ReleaseName)
	populateTimeRFC3339(objectMap, "releaseVersionDate", r.ReleaseVersionDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReleaseProperties.
func (r *ReleaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "buildNumber":
			err = unpopulate(val, "BuildNumber", &r.BuildNumber)
			delete(rawMsg, key)
		case "buildRevision":
			err = unpopulate(val, "BuildRevision", &r.BuildRevision)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, "ReleaseName", &r.ReleaseName)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, "ReleaseVersionDate", &r.ReleaseVersionDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReliabilityResult.
func (r ReliabilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "crashCount", r.CrashCount)
	populate(objectMap, "crashRegressionGrade", r.CrashRegressionGrade)
	populate(objectMap, "crashRegressionTestDetails", r.CrashRegressionTestDetails)
	populate(objectMap, "fileName", r.FileName)
	populate(objectMap, "hangCount", r.HangCount)
	populate(objectMap, "hangRegressionGrade", r.HangRegressionGrade)
	populate(objectMap, "hangRegressionTestDetails", r.HangRegressionTestDetails)
	populate(objectMap, "launchCount", r.LaunchCount)
	populate(objectMap, "regressionGrade", r.RegressionGrade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReliabilityResult.
func (r *ReliabilityResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crashCount":
			err = unpopulate(val, "CrashCount", &r.CrashCount)
			delete(rawMsg, key)
		case "crashRegressionGrade":
			err = unpopulate(val, "CrashRegressionGrade", &r.CrashRegressionGrade)
			delete(rawMsg, key)
		case "crashRegressionTestDetails":
			err = unpopulate(val, "CrashRegressionTestDetails", &r.CrashRegressionTestDetails)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &r.FileName)
			delete(rawMsg, key)
		case "hangCount":
			err = unpopulate(val, "HangCount", &r.HangCount)
			delete(rawMsg, key)
		case "hangRegressionGrade":
			err = unpopulate(val, "HangRegressionGrade", &r.HangRegressionGrade)
			delete(rawMsg, key)
		case "hangRegressionTestDetails":
			err = unpopulate(val, "HangRegressionTestDetails", &r.HangRegressionTestDetails)
			delete(rawMsg, key)
		case "launchCount":
			err = unpopulate(val, "LaunchCount", &r.LaunchCount)
			delete(rawMsg, key)
		case "regressionGrade":
			err = unpopulate(val, "RegressionGrade", &r.RegressionGrade)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReliabilityResultSingletonResourceProperties.
func (r ReliabilityResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeReliability
	populate(objectMap, "grade", r.Grade)
	populate(objectMap, "inplaceUpgradeBaselineReliabilityResults", r.InplaceUpgradeBaselineReliabilityResults)
	populate(objectMap, "reliabilityResults", r.ReliabilityResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReliabilityResultSingletonResourceProperties.
func (r *ReliabilityResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &r.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &r.Grade)
			delete(rawMsg, key)
		case "inplaceUpgradeBaselineReliabilityResults":
			err = unpopulate(val, "InplaceUpgradeBaselineReliabilityResults", &r.InplaceUpgradeBaselineReliabilityResults)
			delete(rawMsg, key)
		case "reliabilityResults":
			err = unpopulate(val, "ReliabilityResults", &r.ReliabilityResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionResult.
func (s ScriptExecutionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "exitCode", s.ExitCode)
	populate(objectMap, "scriptName", s.ScriptName)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "stderrLogFileName", s.StderrLogFileName)
	populate(objectMap, "stdoutLogFileName", s.StdoutLogFileName)
	populate(objectMap, "timedOut", s.TimedOut)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionResult.
func (s *ScriptExecutionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, "ExitCode", &s.ExitCode)
			delete(rawMsg, key)
		case "scriptName":
			err = unpopulate(val, "ScriptName", &s.ScriptName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "stderrLogFileName":
			err = unpopulate(val, "StderrLogFileName", &s.StderrLogFileName)
			delete(rawMsg, key)
		case "stdoutLogFileName":
			err = unpopulate(val, "StdoutLogFileName", &s.StdoutLogFileName)
			delete(rawMsg, key)
		case "timedOut":
			err = unpopulate(val, "TimedOut", &s.TimedOut)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionResultSingletonResourceProperties.
func (s ScriptExecutionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeScriptExecution
	populate(objectMap, "grade", s.Grade)
	populate(objectMap, "scriptExecutionResults", s.ScriptExecutionResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionResultSingletonResourceProperties.
func (s *ScriptExecutionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &s.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &s.Grade)
			delete(rawMsg, key)
		case "scriptExecutionResults":
			err = unpopulate(val, "ScriptExecutionResults", &s.ScriptExecutionResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionReceiverValue.
func (s SubscriptionReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "role", s.Role)
	populate(objectMap, "subscriptionId", s.SubscriptionID)
	populate(objectMap, "subscriptionName", s.SubscriptionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionReceiverValue.
func (s *SubscriptionReceiverValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "role":
			err = unpopulate(val, "Role", &s.Role)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &s.SubscriptionID)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, "SubscriptionName", &s.SubscriptionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemAssignedServiceIdentity.
func (s SystemAssignedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", s.PrincipalID)
	populate(objectMap, "tenantId", s.TenantID)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemAssignedServiceIdentity.
func (s *SystemAssignedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &s.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &s.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TabState.
func (t TabState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentTab", t.CurrentTab)
	populate(objectMap, "visitedTabs", t.VisitedTabs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabState.
func (t *TabState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentTab":
			err = unpopulate(val, "CurrentTab", &t.CurrentTab)
			delete(rawMsg, key)
		case "visitedTabs":
			err = unpopulate(val, "VisitedTabs", &t.VisitedTabs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetOSInfo.
func (t TargetOSInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baselineOSs", t.BaselineOSs)
	populate(objectMap, "insiderChannelIds", t.InsiderChannelIDs)
	populate(objectMap, "osUpdateType", t.OSUpdateType)
	populate(objectMap, "targetOSImageIds", t.TargetOSImageIDs)
	populate(objectMap, "targetOSs", t.TargetOSs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetOSInfo.
func (t *TargetOSInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baselineOSs":
			err = unpopulate(val, "BaselineOSs", &t.BaselineOSs)
			delete(rawMsg, key)
		case "insiderChannelIds":
			err = unpopulate(val, "InsiderChannelIDs", &t.InsiderChannelIDs)
			delete(rawMsg, key)
		case "osUpdateType":
			err = unpopulate(val, "OSUpdateType", &t.OSUpdateType)
			delete(rawMsg, key)
		case "targetOSImageIds":
			err = unpopulate(val, "TargetOSImageIDs", &t.TargetOSImageIDs)
			delete(rawMsg, key)
		case "targetOSs":
			err = unpopulate(val, "TargetOSs", &t.TargetOSs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Test.
func (t Test) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commands", t.Commands)
	populate(objectMap, "isActive", t.IsActive)
	populate(objectMap, "testType", t.TestType)
	populate(objectMap, "validationResultId", t.ValidationResultID)
	populate(objectMap, "validationRunStatus", t.ValidationRunStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Test.
func (t *Test) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commands":
			err = unpopulate(val, "Commands", &t.Commands)
			delete(rawMsg, key)
		case "isActive":
			err = unpopulate(val, "IsActive", &t.IsActive)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &t.TestType)
			delete(rawMsg, key)
		case "validationResultId":
			err = unpopulate(val, "ValidationResultID", &t.ValidationResultID)
			delete(rawMsg, key)
		case "validationRunStatus":
			err = unpopulate(val, "ValidationRunStatus", &t.ValidationRunStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestAnalysisResult.
func (t TestAnalysisResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobData", t.BlobData)
	populate(objectMap, "identifiedFailures", t.IdentifiedFailures)
	populate(objectMap, "testAnalysisStatus", t.TestAnalysisStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestAnalysisResult.
func (t *TestAnalysisResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobData":
			err = unpopulate(val, "BlobData", &t.BlobData)
			delete(rawMsg, key)
		case "identifiedFailures":
			err = unpopulate(val, "IdentifiedFailures", &t.IdentifiedFailures)
			delete(rawMsg, key)
		case "testAnalysisStatus":
			err = unpopulate(val, "TestAnalysisStatus", &t.TestAnalysisStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestAnalysisResultSingletonResourceProperties.
func (t TestAnalysisResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["analysisResultType"] = AnalysisResultTypeTestAnalysis
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "testAnalysisResult", t.TestAnalysisResult)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestAnalysisResultSingletonResourceProperties.
func (t *TestAnalysisResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, "AnalysisResultType", &t.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &t.Grade)
			delete(rawMsg, key)
		case "testAnalysisResult":
			err = unpopulate(val, "TestAnalysisResult", &t.TestAnalysisResult)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultAnalysisSummary.
func (t TestResultAnalysisSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "analysisStatus", t.AnalysisStatus)
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "name", t.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultAnalysisSummary.
func (t *TestResultAnalysisSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisStatus":
			err = unpopulate(val, "AnalysisStatus", &t.AnalysisStatus)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &t.Grade)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultConsoleLogDownloadURLParameters.
func (t TestResultConsoleLogDownloadURLParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logFileName", t.LogFileName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultConsoleLogDownloadURLParameters.
func (t *TestResultConsoleLogDownloadURLParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logFileName":
			err = unpopulate(val, "LogFileName", &t.LogFileName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultFirstPartyAppDefinition.
func (t TestResultFirstPartyAppDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "architecture", t.Architecture)
	populate(objectMap, "channel", t.Channel)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "ring", t.Ring)
	populate(objectMap, "version", t.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultFirstPartyAppDefinition.
func (t *TestResultFirstPartyAppDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "architecture":
			err = unpopulate(val, "Architecture", &t.Architecture)
			delete(rawMsg, key)
		case "channel":
			err = unpopulate(val, "Channel", &t.Channel)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "ring":
			err = unpopulate(val, "Ring", &t.Ring)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &t.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultListResult.
func (t TestResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultListResult.
func (t *TestResultListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultProperties.
func (t TestResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "analysisSummaries", t.AnalysisSummaries)
	populate(objectMap, "applicationName", t.ApplicationName)
	populate(objectMap, "applicationVersion", t.ApplicationVersion)
	populate(objectMap, "baselineTestResultId", t.BaselineTestResultID)
	populate(objectMap, "buildRevision", t.BuildRevision)
	populate(objectMap, "buildVersion", t.BuildVersion)
	populate(objectMap, "customImageDisplayName", t.CustomImageDisplayName)
	populate(objectMap, "customImageId", t.CustomImageID)
	populate(objectMap, "executionStatus", t.ExecutionStatus)
	populate(objectMap, "firstPartyApps", t.FirstPartyApps)
	populate(objectMap, "flightingRing", t.FlightingRing)
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "inplaceUpgradeProperties", t.InplaceUpgradeProperties)
	populate(objectMap, "interopMediaType", t.InteropMediaType)
	populate(objectMap, "interopMediaVersion", t.InteropMediaVersion)
	populate(objectMap, "isDownloadDataAvailable", t.IsDownloadDataAvailable)
	populate(objectMap, "isVideoAvailable", t.IsVideoAvailable)
	populate(objectMap, "kbNumber", t.KbNumber)
	populate(objectMap, "osName", t.OSName)
	populate(objectMap, "packageId", t.PackageID)
	populate(objectMap, "packageVersion", t.PackageVersion)
	populate(objectMap, "releaseName", t.ReleaseName)
	populateTimeRFC3339(objectMap, "releaseVersionDate", t.ReleaseVersionDate)
	populateTimeRFC3339(objectMap, "testEndTime", t.TestEndTime)
	populate(objectMap, "testRunTime", t.TestRunTime)
	populateTimeRFC3339(objectMap, "testStartTime", t.TestStartTime)
	populate(objectMap, "testStatus", t.TestStatus)
	populate(objectMap, "testType", t.TestType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultProperties.
func (t *TestResultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisSummaries":
			err = unpopulate(val, "AnalysisSummaries", &t.AnalysisSummaries)
			delete(rawMsg, key)
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &t.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, "ApplicationVersion", &t.ApplicationVersion)
			delete(rawMsg, key)
		case "baselineTestResultId":
			err = unpopulate(val, "BaselineTestResultID", &t.BaselineTestResultID)
			delete(rawMsg, key)
		case "buildRevision":
			err = unpopulate(val, "BuildRevision", &t.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, "BuildVersion", &t.BuildVersion)
			delete(rawMsg, key)
		case "customImageDisplayName":
			err = unpopulate(val, "CustomImageDisplayName", &t.CustomImageDisplayName)
			delete(rawMsg, key)
		case "customImageId":
			err = unpopulate(val, "CustomImageID", &t.CustomImageID)
			delete(rawMsg, key)
		case "executionStatus":
			err = unpopulate(val, "ExecutionStatus", &t.ExecutionStatus)
			delete(rawMsg, key)
		case "firstPartyApps":
			err = unpopulate(val, "FirstPartyApps", &t.FirstPartyApps)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, "FlightingRing", &t.FlightingRing)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &t.Grade)
			delete(rawMsg, key)
		case "inplaceUpgradeProperties":
			err = unpopulate(val, "InplaceUpgradeProperties", &t.InplaceUpgradeProperties)
			delete(rawMsg, key)
		case "interopMediaType":
			err = unpopulate(val, "InteropMediaType", &t.InteropMediaType)
			delete(rawMsg, key)
		case "interopMediaVersion":
			err = unpopulate(val, "InteropMediaVersion", &t.InteropMediaVersion)
			delete(rawMsg, key)
		case "isDownloadDataAvailable":
			err = unpopulate(val, "IsDownloadDataAvailable", &t.IsDownloadDataAvailable)
			delete(rawMsg, key)
		case "isVideoAvailable":
			err = unpopulate(val, "IsVideoAvailable", &t.IsVideoAvailable)
			delete(rawMsg, key)
		case "kbNumber":
			err = unpopulate(val, "KbNumber", &t.KbNumber)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &t.OSName)
			delete(rawMsg, key)
		case "packageId":
			err = unpopulate(val, "PackageID", &t.PackageID)
			delete(rawMsg, key)
		case "packageVersion":
			err = unpopulate(val, "PackageVersion", &t.PackageVersion)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, "ReleaseName", &t.ReleaseName)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, "ReleaseVersionDate", &t.ReleaseVersionDate)
			delete(rawMsg, key)
		case "testEndTime":
			err = unpopulateTimeRFC3339(val, "TestEndTime", &t.TestEndTime)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, "TestRunTime", &t.TestRunTime)
			delete(rawMsg, key)
		case "testStartTime":
			err = unpopulateTimeRFC3339(val, "TestStartTime", &t.TestStartTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, "TestStatus", &t.TestStatus)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, "TestType", &t.TestType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestResultResource.
func (t TestResultResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultResource.
func (t *TestResultResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestSummaryListResult.
func (t TestSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestSummaryListResult.
func (t *TestSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestSummaryProperties.
func (t TestSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationName", t.ApplicationName)
	populate(objectMap, "applicationVersion", t.ApplicationVersion)
	populate(objectMap, "executionStatus", t.ExecutionStatus)
	populate(objectMap, "featureUpdatesTestSummary", t.FeatureUpdatesTestSummary)
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "inplaceUpgradesTestSummary", t.InplaceUpgradesTestSummary)
	populate(objectMap, "packageId", t.PackageID)
	populate(objectMap, "packageTags", t.PackageTags)
	populate(objectMap, "securityUpdatesTestSummary", t.SecurityUpdatesTestSummary)
	populate(objectMap, "testRunTime", t.TestRunTime)
	populate(objectMap, "testStatus", t.TestStatus)
	populate(objectMap, "testSummaryId", t.TestSummaryID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestSummaryProperties.
func (t *TestSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, "ApplicationName", &t.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, "ApplicationVersion", &t.ApplicationVersion)
			delete(rawMsg, key)
		case "executionStatus":
			err = unpopulate(val, "ExecutionStatus", &t.ExecutionStatus)
			delete(rawMsg, key)
		case "featureUpdatesTestSummary":
			err = unpopulate(val, "FeatureUpdatesTestSummary", &t.FeatureUpdatesTestSummary)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, "Grade", &t.Grade)
			delete(rawMsg, key)
		case "inplaceUpgradesTestSummary":
			err = unpopulate(val, "InplaceUpgradesTestSummary", &t.InplaceUpgradesTestSummary)
			delete(rawMsg, key)
		case "packageId":
			err = unpopulate(val, "PackageID", &t.PackageID)
			delete(rawMsg, key)
		case "packageTags":
			err = unpopulate(val, "PackageTags", &t.PackageTags)
			delete(rawMsg, key)
		case "securityUpdatesTestSummary":
			err = unpopulate(val, "SecurityUpdatesTestSummary", &t.SecurityUpdatesTestSummary)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, "TestRunTime", &t.TestRunTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, "TestStatus", &t.TestStatus)
			delete(rawMsg, key)
		case "testSummaryId":
			err = unpopulate(val, "TestSummaryID", &t.TestSummaryID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestSummaryResource.
func (t TestSummaryResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestSummaryResource.
func (t *TestSummaryResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestTypeListResult.
func (t TestTypeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestTypeListResult.
func (t *TestTypeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &t.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestTypeProperties.
func (t TestTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualTestTypeName", t.ActualTestTypeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestTypeProperties.
func (t *TestTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualTestTypeName":
			err = unpopulate(val, "ActualTestTypeName", &t.ActualTestTypeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestTypeResource.
func (t TestTypeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestTypeResource.
func (t *TestTypeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserObjectReceiverValue.
func (u UserObjectReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "userObjectIds", u.UserObjectIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserObjectReceiverValue.
func (u *UserObjectReceiverValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "userObjectIds":
			err = unpopulate(val, "UserObjectIDs", &u.UserObjectIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationBound.
func (u UtilizationBound) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "percentile", u.Percentile)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UtilizationBound.
func (u *UtilizationBound) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "percentile":
			err = unpopulate(val, "Percentile", &u.Percentile)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationEntry.
func (u UtilizationEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "timestamp", u.Timestamp)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UtilizationEntry.
func (u *UtilizationEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &u.Timestamp)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationResult.
func (u UtilizationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lowerBound", u.LowerBound)
	populate(objectMap, "process", u.Process)
	populate(objectMap, "upperBound", u.UpperBound)
	populate(objectMap, "utilization", u.Utilization)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UtilizationResult.
func (u *UtilizationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lowerBound":
			err = unpopulate(val, "LowerBound", &u.LowerBound)
			delete(rawMsg, key)
		case "process":
			err = unpopulate(val, "Process", &u.Process)
			delete(rawMsg, key)
		case "upperBound":
			err = unpopulate(val, "UpperBound", &u.UpperBound)
			delete(rawMsg, key)
		case "utilization":
			err = unpopulate(val, "Utilization", &u.Utilization)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VHDListResult.
func (v VHDListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VHDListResult.
func (v *VHDListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VHDProperties.
func (v VHDProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "creationTime", v.CreationTime)
	populate(objectMap, "fileName", v.FileName)
	populate(objectMap, "fileSize", v.FileSize)
	populate(objectMap, "path", v.Path)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VHDProperties.
func (v *VHDProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, "CreationTime", &v.CreationTime)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &v.FileName)
			delete(rawMsg, key)
		case "fileSize":
			err = unpopulate(val, "FileSize", &v.FileSize)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &v.Path)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VHDResource.
func (v VHDResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VHDResource.
func (v *VHDResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VerificationResult.
func (v VerificationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "message", v.Message)
	populate(objectMap, "result", v.Result)
	populate(objectMap, "verificationName", v.VerificationName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerificationResult.
func (v *VerificationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "message":
			err = unpopulate(val, "Message", &v.Message)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, "Result", &v.Result)
			delete(rawMsg, key)
		case "verificationName":
			err = unpopulate(val, "VerificationName", &v.VerificationName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WingetAppSKUProperties.
func (w WingetAppSKUProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["applicationType"] = ApplicationTypeWinget
	populate(objectMap, "license", w.License)
	populate(objectMap, "licenseUrl", w.LicenseURL)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "version", w.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WingetAppSKUProperties.
func (w *WingetAppSKUProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationType":
			err = unpopulate(val, "ApplicationType", &w.ApplicationType)
			delete(rawMsg, key)
		case "license":
			err = unpopulate(val, "License", &w.License)
			delete(rawMsg, key)
		case "licenseUrl":
			err = unpopulate(val, "LicenseURL", &w.LicenseURL)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &w.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
