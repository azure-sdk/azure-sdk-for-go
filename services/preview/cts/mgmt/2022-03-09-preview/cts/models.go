package cts

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/cts/mgmt/2022-03-09-preview/cts"

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Connection the connection resource definition.
type Connection struct {
	autorest.Response `json:"-"`
	Properties        *ConnectionProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Connection.
func (c Connection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.Properties != nil {
		objectMap["properties"] = c.Properties
	}
	if c.Tags != nil {
		objectMap["tags"] = c.Tags
	}
	if c.Location != nil {
		objectMap["location"] = c.Location
	}
	return json.Marshal(objectMap)
}

// ConnectionBody the connection to approve or reject.
type ConnectionBody struct {
	// ID - ID of the connection to approve or reject.
	ID *string `json:"id,omitempty"`
	// StatusReason - Reason for approval or rejection.
	StatusReason *string `json:"statusReason,omitempty"`
}

// ConnectionProperties properties of connection
type ConnectionProperties struct {
	// RemoteCloud - Destination cloud of the data to be transferred
	RemoteCloud *string `json:"remoteCloud,omitempty"`
	// Justification - Justification for the connection request
	Justification *string `json:"justification,omitempty"`
	// Status - READ-ONLY; Status of the connection. Possible values include: 'InReview', 'Approved', 'Rejected', 'Accepted'
	Status Status `json:"status,omitempty"`
	// StatusReason - READ-ONLY; Reason for status
	StatusReason *string `json:"statusReason,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the connection. Possible values include: 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateCanceled', 'ProvisioningStateAccepted'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionProperties.
func (cp ConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.RemoteCloud != nil {
		objectMap["remoteCloud"] = cp.RemoteCloud
	}
	if cp.Justification != nil {
		objectMap["justification"] = cp.Justification
	}
	return json.Marshal(objectMap)
}

// ConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionsClient) (Connection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionsCreateOrUpdateFuture.Result.
func (future *ConnectionsCreateOrUpdateFuture) result(client ConnectionsClient) (c Connection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.ConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		c.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.ConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if c.Response.Response, err = future.GetResult(sender); err == nil && c.Response.Response.StatusCode != http.StatusNoContent {
		c, err = client.CreateOrUpdateResponder(c.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.ConnectionsCreateOrUpdateFuture", "Result", c.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionsDeleteFuture.Result.
func (future *ConnectionsDeleteFuture) result(client ConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.ConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.ConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ConnectionsListResult the connections list result.
type ConnectionsListResult struct {
	autorest.Response `json:"-"`
	// Value - Connections array.
	Value *[]Connection `json:"value,omitempty"`
	// NextLink - Link to next results
	NextLink *string `json:"nextLink,omitempty"`
}

// ConnectionsListResultIterator provides access to a complete listing of Connection values.
type ConnectionsListResultIterator struct {
	i    int
	page ConnectionsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConnectionsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConnectionsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConnectionsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConnectionsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConnectionsListResultIterator) Response() ConnectionsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConnectionsListResultIterator) Value() Connection {
	if !iter.page.NotDone() {
		return Connection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConnectionsListResultIterator type.
func NewConnectionsListResultIterator(page ConnectionsListResultPage) ConnectionsListResultIterator {
	return ConnectionsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (clr ConnectionsListResult) IsEmpty() bool {
	return clr.Value == nil || len(*clr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (clr ConnectionsListResult) hasNextLink() bool {
	return clr.NextLink != nil && len(*clr.NextLink) != 0
}

// connectionsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (clr ConnectionsListResult) connectionsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !clr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(clr.NextLink)))
}

// ConnectionsListResultPage contains a page of Connection values.
type ConnectionsListResultPage struct {
	fn  func(context.Context, ConnectionsListResult) (ConnectionsListResult, error)
	clr ConnectionsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConnectionsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConnectionsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.clr)
		if err != nil {
			return err
		}
		page.clr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConnectionsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConnectionsListResultPage) NotDone() bool {
	return !page.clr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConnectionsListResultPage) Response() ConnectionsListResult {
	return page.clr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConnectionsListResultPage) Values() []Connection {
	if page.clr.IsEmpty() {
		return nil
	}
	return *page.clr.Value
}

// Creates a new instance of the ConnectionsListResultPage type.
func NewConnectionsListResultPage(cur ConnectionsListResult, getNextPage func(context.Context, ConnectionsListResult) (ConnectionsListResult, error)) ConnectionsListResultPage {
	return ConnectionsListResultPage{
		fn:  getNextPage,
		clr: cur,
	}
}

// ConnectionsPatch the connections resource patch definition.
type ConnectionsPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ConnectionsPatch.
func (cp ConnectionsPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.Tags != nil {
		objectMap["tags"] = cp.Tags
	}
	return json.Marshal(objectMap)
}

// ConnectionsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConnectionsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionsClient) (Connection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionsUpdateFuture.Result.
func (future *ConnectionsUpdateFuture) result(client ConnectionsClient) (c Connection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.ConnectionsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		c.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.ConnectionsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if c.Response.Response, err = future.GetResult(sender); err == nil && c.Response.Response.StatusCode != http.StatusNoContent {
		c, err = client.UpdateResponder(c.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.ConnectionsUpdateFuture", "Result", c.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// Flow the flow resource definition.
type Flow struct {
	autorest.Response `json:"-"`
	Properties        *FlowProperties `json:"properties,omitempty"`
	Plan              *Plan           `json:"plan,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Flow.
func (f Flow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if f.Properties != nil {
		objectMap["properties"] = f.Properties
	}
	if f.Plan != nil {
		objectMap["plan"] = f.Plan
	}
	if f.Tags != nil {
		objectMap["tags"] = f.Tags
	}
	if f.Location != nil {
		objectMap["location"] = f.Location
	}
	return json.Marshal(objectMap)
}

// FlowProperties properties of flow
type FlowProperties struct {
	// AcceptableUsePolicyForm - Link to signed Acceptable Use Policy (AUP) form
	AcceptableUsePolicyForm *string `json:"acceptableUsePolicyForm,omitempty"`
	// AverageDailyData - Daily estimate on data size (GB)
	AverageDailyData *int64 `json:"averageDailyData,omitempty"`
	// Connection - The connection associated with this flow
	Connection *SelectedResource `json:"connection,omitempty"`
	// DataflowGUID - READ-ONLY; Dataflow GUID associated with this flow
	DataflowGUID *string `json:"dataflowGuid,omitempty"`
	// StorageLocation - Data currently stored in CloudVault?. Possible values include: 'StorageLocationCloudVault', 'StorageLocationOther'
	StorageLocation StorageLocation `json:"storageLocation,omitempty"`
	// DataTypes - List of data types that this Dataflow will service
	DataTypes *[]DataTypes `json:"dataTypes,omitempty"`
	// DataUse - How will the data be used on the high side?
	DataUse *string `json:"dataUse,omitempty"`
	// Destination - What is the destination of this data? (beyond the high-side Storage Account?)
	Destination *string `json:"destination,omitempty"`
	// Email - Microsoft corporate e-mail address
	Email *string `json:"email,omitempty"`
	// IncidentNumber - ICM (Incident Management) number in high side where onboarding details are entered
	IncidentNumber *int64 `json:"incidentNumber,omitempty"`
	// AccessForManualTransfers - Please confirm JIT will be used for manual transfers, whether that be access to the source Storage Container or any service which interacts with the Storage Account. Possible values include: 'JIT', 'None'
	AccessForManualTransfers AccessForManualTransfers `json:"accessForManualTransfers,omitempty"`
	// KeyVaultURI - AME, PME, or TORUS only! AKV Chain Containing SAS Token
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`
	// Usage - Does your service have manual upload through the Teleport pipeline. Possible values include: 'Manual', 'Automatic'
	Usage Usage `json:"usage,omitempty"`
	// ManualUsersStatus - Status of manual users. Possible values include: 'Tented', 'Standard'
	ManualUsersStatus ManualUsersStatus `json:"manualUsersStatus,omitempty"`
	// MaxData - Enter the max (99th percentile) data sent in a day (GB)
	MaxData *int64 `json:"maxData,omitempty"`
	// Origin - What is the system of origin for this data?
	Origin *string `json:"origin,omitempty"`
	// PrimaryContactAlias - Primary contact's alias for this data flow
	PrimaryContactAlias *string `json:"primaryContactAlias,omitempty"`
	// SecondaryContactsAliases - Secondary contacts' aliases for this dataflow
	SecondaryContactsAliases *[]string `json:"secondaryContactsAliases,omitempty"`
	// ServiceName - Service Name
	ServiceName *string `json:"serviceName,omitempty"`
	// ServiceTreeID - Service Tree ID of the service
	ServiceTreeID *string `json:"serviceTreeId,omitempty"`
	// Status - Status of the current flow. Possible values include: 'Enabled', 'Disabled'
	Status FlowStatus `json:"status,omitempty"`
	// StorageAccountName - Storage Account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// StorageContainerName - Storage Container
	StorageContainerName *string `json:"storageContainerName,omitempty"`
	// StorageContainerType - Transfer Storage Blobs or Tables. Possible values include: 'Blob', 'Table'
	StorageContainerType StorageContainerType `json:"storageContainerType,omitempty"`
	// SubscriptionID - Subscription ID for the storage account to be onboarded
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// Title - Title of flow
	Title *string `json:"title,omitempty"`
	// UseCase - Use case for this data flow.
	UseCase *string `json:"useCase,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the flow. Possible values include: 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateCanceled', 'ProvisioningStateAccepted'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for FlowProperties.
func (fp FlowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fp.AcceptableUsePolicyForm != nil {
		objectMap["acceptableUsePolicyForm"] = fp.AcceptableUsePolicyForm
	}
	if fp.AverageDailyData != nil {
		objectMap["averageDailyData"] = fp.AverageDailyData
	}
	if fp.Connection != nil {
		objectMap["connection"] = fp.Connection
	}
	if fp.StorageLocation != "" {
		objectMap["storageLocation"] = fp.StorageLocation
	}
	if fp.DataTypes != nil {
		objectMap["dataTypes"] = fp.DataTypes
	}
	if fp.DataUse != nil {
		objectMap["dataUse"] = fp.DataUse
	}
	if fp.Destination != nil {
		objectMap["destination"] = fp.Destination
	}
	if fp.Email != nil {
		objectMap["email"] = fp.Email
	}
	if fp.IncidentNumber != nil {
		objectMap["incidentNumber"] = fp.IncidentNumber
	}
	if fp.AccessForManualTransfers != "" {
		objectMap["accessForManualTransfers"] = fp.AccessForManualTransfers
	}
	if fp.KeyVaultURI != nil {
		objectMap["keyVaultUri"] = fp.KeyVaultURI
	}
	if fp.Usage != "" {
		objectMap["usage"] = fp.Usage
	}
	if fp.ManualUsersStatus != "" {
		objectMap["manualUsersStatus"] = fp.ManualUsersStatus
	}
	if fp.MaxData != nil {
		objectMap["maxData"] = fp.MaxData
	}
	if fp.Origin != nil {
		objectMap["origin"] = fp.Origin
	}
	if fp.PrimaryContactAlias != nil {
		objectMap["primaryContactAlias"] = fp.PrimaryContactAlias
	}
	if fp.SecondaryContactsAliases != nil {
		objectMap["secondaryContactsAliases"] = fp.SecondaryContactsAliases
	}
	if fp.ServiceName != nil {
		objectMap["serviceName"] = fp.ServiceName
	}
	if fp.ServiceTreeID != nil {
		objectMap["serviceTreeId"] = fp.ServiceTreeID
	}
	if fp.Status != "" {
		objectMap["status"] = fp.Status
	}
	if fp.StorageAccountName != nil {
		objectMap["storageAccountName"] = fp.StorageAccountName
	}
	if fp.StorageContainerName != nil {
		objectMap["storageContainerName"] = fp.StorageContainerName
	}
	if fp.StorageContainerType != "" {
		objectMap["storageContainerType"] = fp.StorageContainerType
	}
	if fp.SubscriptionID != nil {
		objectMap["subscriptionId"] = fp.SubscriptionID
	}
	if fp.Title != nil {
		objectMap["title"] = fp.Title
	}
	if fp.UseCase != nil {
		objectMap["useCase"] = fp.UseCase
	}
	return json.Marshal(objectMap)
}

// FlowsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FlowsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowsClient) (Flow, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowsCreateOrUpdateFuture.Result.
func (future *FlowsCreateOrUpdateFuture) result(client FlowsClient) (f Flow, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.FlowsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		f.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.FlowsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if f.Response.Response, err = future.GetResult(sender); err == nil && f.Response.Response.StatusCode != http.StatusNoContent {
		f, err = client.CreateOrUpdateResponder(f.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.FlowsCreateOrUpdateFuture", "Result", f.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FlowsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type FlowsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowsDeleteFuture.Result.
func (future *FlowsDeleteFuture) result(client FlowsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.FlowsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.FlowsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// FlowsDisableFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type FlowsDisableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowsClient) (Flow, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowsDisableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowsDisableFuture.Result.
func (future *FlowsDisableFuture) result(client FlowsClient) (f Flow, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.FlowsDisableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		f.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.FlowsDisableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if f.Response.Response, err = future.GetResult(sender); err == nil && f.Response.Response.StatusCode != http.StatusNoContent {
		f, err = client.DisableResponder(f.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.FlowsDisableFuture", "Result", f.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FlowsEnableFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type FlowsEnableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowsClient) (Flow, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowsEnableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowsEnableFuture.Result.
func (future *FlowsEnableFuture) result(client FlowsClient) (f Flow, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.FlowsEnableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		f.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.FlowsEnableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if f.Response.Response, err = future.GetResult(sender); err == nil && f.Response.Response.StatusCode != http.StatusNoContent {
		f, err = client.EnableResponder(f.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.FlowsEnableFuture", "Result", f.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FlowsListResult the flows list result.
type FlowsListResult struct {
	autorest.Response `json:"-"`
	// Value - Flows array.
	Value *[]Flow `json:"value,omitempty"`
	// NextLink - Link to next results
	NextLink *string `json:"nextLink,omitempty"`
}

// FlowsListResultIterator provides access to a complete listing of Flow values.
type FlowsListResultIterator struct {
	i    int
	page FlowsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FlowsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlowsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FlowsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FlowsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FlowsListResultIterator) Response() FlowsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FlowsListResultIterator) Value() Flow {
	if !iter.page.NotDone() {
		return Flow{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FlowsListResultIterator type.
func NewFlowsListResultIterator(page FlowsListResultPage) FlowsListResultIterator {
	return FlowsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (flr FlowsListResult) IsEmpty() bool {
	return flr.Value == nil || len(*flr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (flr FlowsListResult) hasNextLink() bool {
	return flr.NextLink != nil && len(*flr.NextLink) != 0
}

// flowsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (flr FlowsListResult) flowsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !flr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(flr.NextLink)))
}

// FlowsListResultPage contains a page of Flow values.
type FlowsListResultPage struct {
	fn  func(context.Context, FlowsListResult) (FlowsListResult, error)
	flr FlowsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FlowsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlowsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.flr)
		if err != nil {
			return err
		}
		page.flr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FlowsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FlowsListResultPage) NotDone() bool {
	return !page.flr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FlowsListResultPage) Response() FlowsListResult {
	return page.flr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FlowsListResultPage) Values() []Flow {
	if page.flr.IsEmpty() {
		return nil
	}
	return *page.flr.Value
}

// Creates a new instance of the FlowsListResultPage type.
func NewFlowsListResultPage(cur FlowsListResult, getNextPage func(context.Context, FlowsListResult) (FlowsListResult, error)) FlowsListResultPage {
	return FlowsListResultPage{
		fn:  getNextPage,
		flr: cur,
	}
}

// FlowsPatch the flows resource patch definition.
type FlowsPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for FlowsPatch.
func (fp FlowsPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fp.Tags != nil {
		objectMap["tags"] = fp.Tags
	}
	return json.Marshal(objectMap)
}

// FlowsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type FlowsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowsClient) (Flow, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowsUpdateFuture.Result.
func (future *FlowsUpdateFuture) result(client FlowsClient) (f Flow, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.FlowsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		f.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.FlowsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if f.Response.Response, err = future.GetResult(sender); err == nil && f.Response.Response.StatusCode != http.StatusNoContent {
		f, err = client.UpdateResponder(f.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.FlowsUpdateFuture", "Result", f.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// InternalMetadataProperties internal metadata of the connection inside pipeline.
type InternalMetadataProperties struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{}     `json:""`
	OperationStatus      *OperationStatusProperties `json:"operationStatus,omitempty"`
	// StatusSetBy - READ-ONLY; User that last set the approved status for this connection
	StatusSetBy *string `json:"statusSetBy,omitempty"`
}

// MarshalJSON is the custom marshaler for InternalMetadataProperties.
func (imp InternalMetadataProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if imp.OperationStatus != nil {
		objectMap["operationStatus"] = imp.OperationStatus
	}
	for k, v := range imp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InternalMetadataProperties struct.
func (imp *InternalMetadataProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if imp.AdditionalProperties == nil {
					imp.AdditionalProperties = make(map[string]interface{})
				}
				imp.AdditionalProperties[k] = additionalProperties
			}
		case "operationStatus":
			if v != nil {
				var operationStatus OperationStatusProperties
				err = json.Unmarshal(*v, &operationStatus)
				if err != nil {
					return err
				}
				imp.OperationStatus = &operationStatus
			}
		case "statusSetBy":
			if v != nil {
				var statusSetBy string
				err = json.Unmarshal(*v, &statusSetBy)
				if err != nil {
					return err
				}
				imp.StatusSetBy = &statusSetBy
			}
		}
	}

	return nil
}

// Operation details of a REST API operation, returned from the Resource Provider Operations API
type Operation struct {
	// Name - READ-ONLY; The name of the operation, as per Resource-Based Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action"
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Whether the operation applies to data-plane. This is "true" for data-plane operations and "false" for ARM/control-plane operations.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Localized display information for this particular operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit logs UX. Default value is "user,system". Possible values include: 'OriginUser', 'OriginSystem', 'OriginUsersystem'
	Origin Origin `json:"origin,omitempty"`
	// ActionType - READ-ONLY; Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs. Possible values include: 'Internal'
	ActionType ActionType `json:"actionType,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay localized display information for this particular operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The localized friendly form of the resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft Compute".
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; The localized friendly name of the resource type related to this operation. E.g. "Virtual Machines" or "Job Schedule Collections".
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; The concise, localized friendly name for the operation; suitable for dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; The short, localized friendly description of the operation; suitable for tool tips and detailed views.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of REST API operations supported by an Azure Resource Provider. It contains
// an URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of operations supported by the resource provider
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results (if there are any).
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// OperationStatusProperties operation status associated with the last patch request
type OperationStatusProperties struct {
	// Status - READ-ONLY; Operation status for the last patch request for this connection. Possible values include: 'Failed', 'Succeeded'
	Status OperationStatusEnum `json:"status,omitempty"`
	// ID - READ-ONLY; Operation status ID of the last patch request for this connection.
	ID *string `json:"id,omitempty"`
	// Message - READ-ONLY; Message for the operation for the last patch request for this connection.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationStatusProperties.
func (osp OperationStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Pipeline the pipeline resource definition.
type Pipeline struct {
	autorest.Response `json:"-"`
	Properties        *PipelineProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Pipeline.
func (p Pipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Properties != nil {
		objectMap["properties"] = p.Properties
	}
	if p.Tags != nil {
		objectMap["tags"] = p.Tags
	}
	if p.Location != nil {
		objectMap["location"] = p.Location
	}
	return json.Marshal(objectMap)
}

// PipelineConnection connection body inside a pipeline
type PipelineConnection struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ID - Connection id inside pipeline
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Connection name inside pipeline
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Connection type inside pipeline
	Type *string `json:"type,omitempty"`
	// Location - READ-ONLY; Connection location inside pipeline
	Location *string `json:"location,omitempty"`
	// Etag - READ-ONLY; Connection etag inside pipeline
	Etag *string `json:"etag,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Properties - Connection properties inside pipeline
	Properties *PipelineConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineConnection.
func (pc PipelineConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.ID != nil {
		objectMap["id"] = pc.ID
	}
	if pc.Properties != nil {
		objectMap["properties"] = pc.Properties
	}
	for k, v := range pc.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineConnection struct.
func (pc *PipelineConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if pc.AdditionalProperties == nil {
					pc.AdditionalProperties = make(map[string]interface{})
				}
				pc.AdditionalProperties[k] = additionalProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pc.Location = &location
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pc.Etag = &etag
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pc.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var properties PipelineConnectionProperties
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				pc.Properties = &properties
			}
		}
	}

	return nil
}

// PipelineConnectionProperties connection properties inside pipeline
type PipelineConnectionProperties struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{}      `json:""`
	InternalMetadata     *InternalMetadataProperties `json:"internalMetadata,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineConnectionProperties.
func (pc PipelineConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.InternalMetadata != nil {
		objectMap["internalMetadata"] = pc.InternalMetadata
	}
	for k, v := range pc.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineConnectionProperties struct.
func (pc *PipelineConnectionProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if pc.AdditionalProperties == nil {
					pc.AdditionalProperties = make(map[string]interface{})
				}
				pc.AdditionalProperties[k] = additionalProperties
			}
		case "internalMetadata":
			if v != nil {
				var internalMetadata InternalMetadataProperties
				err = json.Unmarshal(*v, &internalMetadata)
				if err != nil {
					return err
				}
				pc.InternalMetadata = &internalMetadata
			}
		}
	}

	return nil
}

// PipelineProperties properties of pipeline
type PipelineProperties struct {
	// RemoteCloud - Remote cloud of the data to be transferred or received
	RemoteCloud *string `json:"remoteCloud,omitempty"`
	// Connections - READ-ONLY; Connections associated with pipeline
	Connections *[]PipelineConnection `json:"connections,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the pipeline. Possible values include: 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateCanceled', 'ProvisioningStateAccepted'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineProperties.
func (pp PipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.RemoteCloud != nil {
		objectMap["remoteCloud"] = pp.RemoteCloud
	}
	return json.Marshal(objectMap)
}

// PipelinesApproveConnectionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PipelinesApproveConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (Pipeline, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesApproveConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesApproveConnectionFuture.Result.
func (future *PipelinesApproveConnectionFuture) result(client PipelinesClient) (p Pipeline, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.PipelinesApproveConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.PipelinesApproveConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.ApproveConnectionResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.PipelinesApproveConnectionFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelinesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (Pipeline, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesCreateOrUpdateFuture.Result.
func (future *PipelinesCreateOrUpdateFuture) result(client PipelinesClient) (p Pipeline, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.PipelinesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.PipelinesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.CreateOrUpdateResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.PipelinesCreateOrUpdateFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelinesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesDeleteFuture.Result.
func (future *PipelinesDeleteFuture) result(client PipelinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.PipelinesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.PipelinesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PipelinesListResult the pipelines list result.
type PipelinesListResult struct {
	autorest.Response `json:"-"`
	// Value - Pipelines array.
	Value *[]Pipeline `json:"value,omitempty"`
	// NextLink - Link to next results
	NextLink *string `json:"nextLink,omitempty"`
}

// PipelinesListResultIterator provides access to a complete listing of Pipeline values.
type PipelinesListResultIterator struct {
	i    int
	page PipelinesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelinesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelinesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelinesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelinesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelinesListResultIterator) Response() PipelinesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelinesListResultIterator) Value() Pipeline {
	if !iter.page.NotDone() {
		return Pipeline{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelinesListResultIterator type.
func NewPipelinesListResultIterator(page PipelinesListResultPage) PipelinesListResultIterator {
	return PipelinesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr PipelinesListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr PipelinesListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// pipelinesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr PipelinesListResult) pipelinesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// PipelinesListResultPage contains a page of Pipeline values.
type PipelinesListResultPage struct {
	fn  func(context.Context, PipelinesListResult) (PipelinesListResult, error)
	plr PipelinesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelinesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelinesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelinesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelinesListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelinesListResultPage) Response() PipelinesListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelinesListResultPage) Values() []Pipeline {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the PipelinesListResultPage type.
func NewPipelinesListResultPage(cur PipelinesListResult, getNextPage func(context.Context, PipelinesListResult) (PipelinesListResult, error)) PipelinesListResultPage {
	return PipelinesListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// PipelinesPatch the pipelines resource patch definition.
type PipelinesPatch struct {
	// Properties - Properties of pipelines patch body.
	Properties *PipelinesPatchProperties `json:"properties,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PipelinesPatch.
func (pp PipelinesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Properties != nil {
		objectMap["properties"] = pp.Properties
	}
	if pp.Tags != nil {
		objectMap["tags"] = pp.Tags
	}
	return json.Marshal(objectMap)
}

// PipelinesPatchProperties properties of pipelines patch body.
type PipelinesPatchProperties struct {
	// Connections - Connections associated with pipeline
	Connections *[]PipelineConnection `json:"connections,omitempty"`
}

// PipelinesRejectConnectionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PipelinesRejectConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (Pipeline, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesRejectConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesRejectConnectionFuture.Result.
func (future *PipelinesRejectConnectionFuture) result(client PipelinesClient) (p Pipeline, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.PipelinesRejectConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.PipelinesRejectConnectionFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.RejectConnectionResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.PipelinesRejectConnectionFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelinesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (Pipeline, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesUpdateFuture.Result.
func (future *PipelinesUpdateFuture) result(client PipelinesClient) (p Pipeline, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "cts.PipelinesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("cts.PipelinesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.UpdateResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "cts.PipelinesUpdateFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySet the resource model definition containing the full set of allowed
// properties for a resource. Except properties bag, there cannot be a top level property outside of this
// set.
type ResourceModelWithAllowedPropertySet struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ManagedBy - The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// Etag - READ-ONLY; The etag field is *not* required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty"`
	// Tags - Resource tags.
	Tags     map[string]*string                           `json:"tags"`
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`
	Sku      *ResourceModelWithAllowedPropertySetSku      `json:"sku,omitempty"`
	Plan     *ResourceModelWithAllowedPropertySetPlan     `json:"plan,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySet.
func (rmwaps ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.Location != nil {
		objectMap["location"] = rmwaps.Location
	}
	if rmwaps.ManagedBy != nil {
		objectMap["managedBy"] = rmwaps.ManagedBy
	}
	if rmwaps.Kind != nil {
		objectMap["kind"] = rmwaps.Kind
	}
	if rmwaps.Tags != nil {
		objectMap["tags"] = rmwaps.Tags
	}
	if rmwaps.Identity != nil {
		objectMap["identity"] = rmwaps.Identity
	}
	if rmwaps.Sku != nil {
		objectMap["sku"] = rmwaps.Sku
	}
	if rmwaps.Plan != nil {
		objectMap["plan"] = rmwaps.Plan
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetIdentity ...
type ResourceModelWithAllowedPropertySetIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySetIdentity.
func (rmwaps ResourceModelWithAllowedPropertySetIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.Type != "" {
		objectMap["type"] = rmwaps.Type
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetPlan ...
type ResourceModelWithAllowedPropertySetPlan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ResourceModelWithAllowedPropertySetSku ...
type ResourceModelWithAllowedPropertySetSku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'SkuTierFree', 'SkuTierBasic', 'SkuTierStandard', 'SkuTierPremium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SelectedResource a resource selected from ARM
type SelectedResource struct {
	// Name - Name of the connection
	Name *string `json:"name,omitempty"`
	// ID - Id of the connection
	ID *string `json:"id,omitempty"`
	// Location - Location of the connection
	Location *string `json:"location,omitempty"`
	// SubscriptionName - Name of the subscription with the connection
	SubscriptionName *string `json:"subscriptionName,omitempty"`
}

// Sku the resource model definition representing SKU
type Sku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'SkuTierFree', 'SkuTierBasic', 'SkuTierStandard', 'SkuTierPremium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}
