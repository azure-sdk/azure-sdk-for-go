//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmigrationhub

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AADAppDetails.
func (a AADAppDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", a.ApplicationID)
	populate(objectMap, "tenantId", a.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADAppDetails.
func (a *AADAppDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &a.ApplicationID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &a.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentDetails.
func (a AssessmentDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentId", a.AssessmentID)
	populate(objectMap, "biosId", a.BiosID)
	populate(objectMap, "enqueueTime", a.EnqueueTime)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "fabricType", a.FabricType)
	populate(objectMap, "fqdn", a.Fqdn)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "ipAddresses", a.IPAddresses)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", a.LastUpdatedTime)
	populate(objectMap, "macAddresses", a.MacAddresses)
	populate(objectMap, "machineId", a.MachineID)
	populate(objectMap, "machineManagerId", a.MachineManagerID)
	populate(objectMap, "machineName", a.MachineName)
	populate(objectMap, "solutionName", a.SolutionName)
	populate(objectMap, "targetStorageType", a.TargetStorageType)
	populate(objectMap, "targetVMLocation", a.TargetVMLocation)
	populate(objectMap, "targetVMSize", a.TargetVMSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentDetails.
func (a *AssessmentDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentId":
			err = unpopulate(val, "AssessmentID", &a.AssessmentID)
			delete(rawMsg, key)
		case "biosId":
			err = unpopulate(val, "BiosID", &a.BiosID)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &a.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "fabricType":
			err = unpopulate(val, "FabricType", &a.FabricType)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &a.Fqdn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &a.IPAddresses)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &a.LastUpdatedTime)
			delete(rawMsg, key)
		case "macAddresses":
			err = unpopulate(val, "MacAddresses", &a.MacAddresses)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &a.MachineID)
			delete(rawMsg, key)
		case "machineManagerId":
			err = unpopulate(val, "MachineManagerID", &a.MachineManagerID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &a.MachineName)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &a.SolutionName)
			delete(rawMsg, key)
		case "targetStorageType":
			err = unpopulate(val, "TargetStorageType", &a.TargetStorageType)
			delete(rawMsg, key)
		case "targetVMLocation":
			err = unpopulate(val, "TargetVMLocation", &a.TargetVMLocation)
			delete(rawMsg, key)
		case "targetVMSize":
			err = unpopulate(val, "TargetVMSize", &a.TargetVMSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Database.
func (d Database) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Database.
func (d *Database) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseAssessmentDetails.
func (d DatabaseAssessmentDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentId", d.AssessmentID)
	populate(objectMap, "assessmentTargetType", d.AssessmentTargetType)
	populate(objectMap, "breakingChangesCount", d.BreakingChangesCount)
	populate(objectMap, "compatibilityLevel", d.CompatibilityLevel)
	populate(objectMap, "databaseName", d.DatabaseName)
	populate(objectMap, "databaseSizeInMB", d.DatabaseSizeInMB)
	populate(objectMap, "enqueueTime", d.EnqueueTime)
	populate(objectMap, "extendedInfo", d.ExtendedInfo)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "instanceId", d.InstanceID)
	populate(objectMap, "isReadyForMigration", d.IsReadyForMigration)
	populateDateTimeRFC3339(objectMap, "lastAssessedTime", d.LastAssessedTime)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "migrationBlockersCount", d.MigrationBlockersCount)
	populate(objectMap, "solutionName", d.SolutionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseAssessmentDetails.
func (d *DatabaseAssessmentDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentId":
			err = unpopulate(val, "AssessmentID", &d.AssessmentID)
			delete(rawMsg, key)
		case "assessmentTargetType":
			err = unpopulate(val, "AssessmentTargetType", &d.AssessmentTargetType)
			delete(rawMsg, key)
		case "breakingChangesCount":
			err = unpopulate(val, "BreakingChangesCount", &d.BreakingChangesCount)
			delete(rawMsg, key)
		case "compatibilityLevel":
			err = unpopulate(val, "CompatibilityLevel", &d.CompatibilityLevel)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &d.DatabaseName)
			delete(rawMsg, key)
		case "databaseSizeInMB":
			err = unpopulate(val, "DatabaseSizeInMB", &d.DatabaseSizeInMB)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &d.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &d.ExtendedInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, "InstanceID", &d.InstanceID)
			delete(rawMsg, key)
		case "isReadyForMigration":
			err = unpopulate(val, "IsReadyForMigration", &d.IsReadyForMigration)
			delete(rawMsg, key)
		case "lastAssessedTime":
			err = unpopulateDateTimeRFC3339(val, "LastAssessedTime", &d.LastAssessedTime)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "migrationBlockersCount":
			err = unpopulate(val, "MigrationBlockersCount", &d.MigrationBlockersCount)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &d.SolutionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseCollection.
func (d DatabaseCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseCollection.
func (d *DatabaseCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseInstance.
func (d DatabaseInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseInstance.
func (d *DatabaseInstance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseInstanceCollection.
func (d DatabaseInstanceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseInstanceCollection.
func (d *DatabaseInstanceCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseInstanceDiscoveryDetails.
func (d DatabaseInstanceDiscoveryDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enqueueTime", d.EnqueueTime)
	populate(objectMap, "extendedInfo", d.ExtendedInfo)
	populate(objectMap, "hostName", d.HostName)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "ipAddress", d.IPAddress)
	populate(objectMap, "instanceId", d.InstanceID)
	populate(objectMap, "instanceName", d.InstanceName)
	populate(objectMap, "instanceType", d.InstanceType)
	populate(objectMap, "instanceVersion", d.InstanceVersion)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "portNumber", d.PortNumber)
	populate(objectMap, "solutionName", d.SolutionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseInstanceDiscoveryDetails.
func (d *DatabaseInstanceDiscoveryDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &d.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &d.ExtendedInfo)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &d.HostName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &d.IPAddress)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, "InstanceID", &d.InstanceID)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, "InstanceName", &d.InstanceName)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &d.InstanceType)
			delete(rawMsg, key)
		case "instanceVersion":
			err = unpopulate(val, "InstanceVersion", &d.InstanceVersion)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "portNumber":
			err = unpopulate(val, "PortNumber", &d.PortNumber)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &d.SolutionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseInstanceProperties.
func (d DatabaseInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "discoveryData", d.DiscoveryData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "summary", d.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseInstanceProperties.
func (d *DatabaseInstanceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "discoveryData":
			err = unpopulate(val, "DiscoveryData", &d.DiscoveryData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &d.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseInstanceSummary.
func (d DatabaseInstanceSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "databasesAssessedCount", d.DatabasesAssessedCount)
	populate(objectMap, "migrationReadyCount", d.MigrationReadyCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseInstanceSummary.
func (d *DatabaseInstanceSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databasesAssessedCount":
			err = unpopulate(val, "DatabasesAssessedCount", &d.DatabasesAssessedCount)
			delete(rawMsg, key)
		case "migrationReadyCount":
			err = unpopulate(val, "MigrationReadyCount", &d.MigrationReadyCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseProperties.
func (d DatabaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentData", d.AssessmentData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseProperties.
func (d *DatabaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentData":
			err = unpopulate(val, "AssessmentData", &d.AssessmentData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiscoveryDetails.
func (d DiscoveryDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "biosId", d.BiosID)
	populate(objectMap, "enqueueTime", d.EnqueueTime)
	populate(objectMap, "extendedInfo", d.ExtendedInfo)
	populate(objectMap, "fabricType", d.FabricType)
	populate(objectMap, "fqdn", d.Fqdn)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "ipAddresses", d.IPAddresses)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "macAddresses", d.MacAddresses)
	populate(objectMap, "machineId", d.MachineID)
	populate(objectMap, "machineManagerId", d.MachineManagerID)
	populate(objectMap, "machineName", d.MachineName)
	populate(objectMap, "osName", d.OSName)
	populate(objectMap, "osType", d.OSType)
	populate(objectMap, "osVersion", d.OSVersion)
	populate(objectMap, "solutionName", d.SolutionName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiscoveryDetails.
func (d *DiscoveryDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "biosId":
			err = unpopulate(val, "BiosID", &d.BiosID)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &d.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &d.ExtendedInfo)
			delete(rawMsg, key)
		case "fabricType":
			err = unpopulate(val, "FabricType", &d.FabricType)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &d.Fqdn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &d.IPAddresses)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "macAddresses":
			err = unpopulate(val, "MacAddresses", &d.MacAddresses)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &d.MachineID)
			delete(rawMsg, key)
		case "machineManagerId":
			err = unpopulate(val, "MachineManagerID", &d.MachineManagerID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &d.MachineName)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &d.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &d.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &d.OSVersion)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &d.SolutionName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventCollection.
func (e EventCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventCollection.
func (e *EventCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupConnectivityInformation.
func (g GroupConnectivityInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customerVisibleFqdns", g.CustomerVisibleFqdns)
	populate(objectMap, "groupId", g.GroupID)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "internalFqdn", g.InternalFqdn)
	populate(objectMap, "memberName", g.MemberName)
	populate(objectMap, "privateLinkServiceArmRegion", g.PrivateLinkServiceArmRegion)
	populate(objectMap, "redirectMapId", g.RedirectMapID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupConnectivityInformation.
func (g *GroupConnectivityInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customerVisibleFqdns":
			err = unpopulate(val, "CustomerVisibleFqdns", &g.CustomerVisibleFqdns)
			delete(rawMsg, key)
		case "groupId":
			err = unpopulate(val, "GroupID", &g.GroupID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "internalFqdn":
			err = unpopulate(val, "InternalFqdn", &g.InternalFqdn)
			delete(rawMsg, key)
		case "memberName":
			err = unpopulate(val, "MemberName", &g.MemberName)
			delete(rawMsg, key)
		case "privateLinkServiceArmRegion":
			err = unpopulate(val, "PrivateLinkServiceArmRegion", &g.PrivateLinkServiceArmRegion)
			delete(rawMsg, key)
		case "redirectMapId":
			err = unpopulate(val, "RedirectMapID", &g.RedirectMapID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPConfiguration.
func (i IPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", i.GroupID)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "linkIdentifier", i.LinkIdentifier)
	populate(objectMap, "memberName", i.MemberName)
	populate(objectMap, "privateIpAddress", i.PrivateIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPConfiguration.
func (i *IPConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &i.GroupID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "linkIdentifier":
			err = unpopulate(val, "LinkIdentifier", &i.LinkIdentifier)
			delete(rawMsg, key)
		case "memberName":
			err = unpopulate(val, "MemberName", &i.MemberName)
			delete(rawMsg, key)
		case "privateIpAddress":
			err = unpopulate(val, "PrivateIPAddress", &i.PrivateIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Machine.
func (m Machine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Machine.
func (m *Machine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineCollection.
func (m MachineCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineCollection.
func (m *MachineCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineProperties.
func (m MachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentData", m.AssessmentData)
	populate(objectMap, "discoveryData", m.DiscoveryData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", m.LastUpdatedTime)
	populate(objectMap, "migrationData", m.MigrationData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineProperties.
func (m *MachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentData":
			err = unpopulate(val, "AssessmentData", &m.AssessmentData)
			delete(rawMsg, key)
		case "discoveryData":
			err = unpopulate(val, "DiscoveryData", &m.DiscoveryData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &m.LastUpdatedTime)
			delete(rawMsg, key)
		case "migrationData":
			err = unpopulate(val, "MigrationData", &m.MigrationData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrateEvent.
func (m MigrateEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateEvent.
func (m *MigrateEvent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrateEventProperties.
func (m MigrateEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientRequestId", m.ClientRequestID)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "instanceType", m.InstanceType)
	populate(objectMap, "possibleCauses", m.PossibleCauses)
	populate(objectMap, "recommendation", m.Recommendation)
	populate(objectMap, "solution", m.Solution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateEventProperties.
func (m *MigrateEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientRequestId":
			err = unpopulate(val, "ClientRequestID", &m.ClientRequestID)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &m.ErrorCode)
			delete(rawMsg, key)
		case "errorMessage":
			err = unpopulate(val, "ErrorMessage", &m.ErrorMessage)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &m.InstanceType)
			delete(rawMsg, key)
		case "possibleCauses":
			err = unpopulate(val, "PossibleCauses", &m.PossibleCauses)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, "Recommendation", &m.Recommendation)
			delete(rawMsg, key)
		case "solution":
			err = unpopulate(val, "Solution", &m.Solution)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrateProject.
func (m MigrateProject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", m.ETag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateProject.
func (m *MigrateProject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &m.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrateProjectProperties.
func (m MigrateProjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastSummaryRefreshedTime", m.LastSummaryRefreshedTime)
	populate(objectMap, "privateEndpointConnections", m.PrivateEndpointConnections)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "refreshSummaryState", m.RefreshSummaryState)
	populate(objectMap, "registeredTools", m.RegisteredTools)
	populate(objectMap, "serviceEndpoint", m.ServiceEndpoint)
	populate(objectMap, "summary", m.Summary)
	populate(objectMap, "utilityStorageAccountId", m.UtilityStorageAccountID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateProjectProperties.
func (m *MigrateProjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastSummaryRefreshedTime":
			err = unpopulateDateTimeRFC3339(val, "LastSummaryRefreshedTime", &m.LastSummaryRefreshedTime)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, "PrivateEndpointConnections", &m.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &m.PublicNetworkAccess)
			delete(rawMsg, key)
		case "refreshSummaryState":
			err = unpopulate(val, "RefreshSummaryState", &m.RefreshSummaryState)
			delete(rawMsg, key)
		case "registeredTools":
			err = unpopulate(val, "RegisteredTools", &m.RegisteredTools)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &m.ServiceEndpoint)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &m.Summary)
			delete(rawMsg, key)
		case "utilityStorageAccountId":
			err = unpopulate(val, "UtilityStorageAccountID", &m.UtilityStorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrationDetails.
func (m MigrationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "biosId", m.BiosID)
	populate(objectMap, "enqueueTime", m.EnqueueTime)
	populate(objectMap, "extendedInfo", m.ExtendedInfo)
	populate(objectMap, "fabricType", m.FabricType)
	populate(objectMap, "fqdn", m.Fqdn)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "ipAddresses", m.IPAddresses)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", m.LastUpdatedTime)
	populate(objectMap, "macAddresses", m.MacAddresses)
	populate(objectMap, "machineId", m.MachineID)
	populate(objectMap, "machineManagerId", m.MachineManagerID)
	populate(objectMap, "machineName", m.MachineName)
	populate(objectMap, "migrationPhase", m.MigrationPhase)
	populate(objectMap, "migrationTested", m.MigrationTested)
	populate(objectMap, "replicationProgressPercentage", m.ReplicationProgressPercentage)
	populate(objectMap, "solutionName", m.SolutionName)
	populate(objectMap, "targetVMArmId", m.TargetVMArmID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationDetails.
func (m *MigrationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "biosId":
			err = unpopulate(val, "BiosID", &m.BiosID)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &m.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &m.ExtendedInfo)
			delete(rawMsg, key)
		case "fabricType":
			err = unpopulate(val, "FabricType", &m.FabricType)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &m.Fqdn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &m.IPAddresses)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &m.LastUpdatedTime)
			delete(rawMsg, key)
		case "macAddresses":
			err = unpopulate(val, "MacAddresses", &m.MacAddresses)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &m.MachineID)
			delete(rawMsg, key)
		case "machineManagerId":
			err = unpopulate(val, "MachineManagerID", &m.MachineManagerID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &m.MachineName)
			delete(rawMsg, key)
		case "migrationPhase":
			err = unpopulate(val, "MigrationPhase", &m.MigrationPhase)
			delete(rawMsg, key)
		case "migrationTested":
			err = unpopulate(val, "MigrationTested", &m.MigrationTested)
			delete(rawMsg, key)
		case "replicationProgressPercentage":
			err = unpopulate(val, "ReplicationProgressPercentage", &m.ReplicationProgressPercentage)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &m.SolutionName)
			delete(rawMsg, key)
		case "targetVMArmId":
			err = unpopulate(val, "TargetVMArmID", &m.TargetVMArmID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", p.ETag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &p.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionCollection.
func (p PrivateEndpointConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionCollection.
func (p *PrivateEndpointConnectionCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProperties.
func (p PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProperties.
func (p *PrivateEndpointConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &p.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &p.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxy.
func (p PrivateEndpointConnectionProxy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", p.ETag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxy.
func (p *PrivateEndpointConnectionProxy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &p.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxyCollection.
func (p PrivateEndpointConnectionProxyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxyCollection.
func (p *PrivateEndpointConnectionProxyCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxyProperties.
func (p PrivateEndpointConnectionProxyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "remotePrivateEndpoint", p.RemotePrivateEndpoint)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxyProperties.
func (p *PrivateEndpointConnectionProxyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "remotePrivateEndpoint":
			err = unpopulate(val, "RemotePrivateEndpoint", &p.RemotePrivateEndpoint)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointDetails.
func (p PrivateEndpointDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", p.ConnectionDetails)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "manualPrivateLinkServiceConnections", p.ManualPrivateLinkServiceConnections)
	populate(objectMap, "privateLinkServiceConnections", p.PrivateLinkServiceConnections)
	populate(objectMap, "privateLinkServiceProxies", p.PrivateLinkServiceProxies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointDetails.
func (p *PrivateEndpointDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &p.ConnectionDetails)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "manualPrivateLinkServiceConnections":
			err = unpopulate(val, "ManualPrivateLinkServiceConnections", &p.ManualPrivateLinkServiceConnections)
			delete(rawMsg, key)
		case "privateLinkServiceConnections":
			err = unpopulate(val, "PrivateLinkServiceConnections", &p.PrivateLinkServiceConnections)
			delete(rawMsg, key)
		case "privateLinkServiceProxies":
			err = unpopulate(val, "PrivateLinkServiceProxies", &p.PrivateLinkServiceProxies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceCollection.
func (p PrivateLinkResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceCollection.
func (p *PrivateLinkResourceCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceProperties.
func (p *PrivateLinkResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &p.GroupID)
			delete(rawMsg, key)
		case "requiredMembers":
			err = unpopulate(val, "RequiredMembers", &p.RequiredMembers)
			delete(rawMsg, key)
		case "requiredZoneNames":
			err = unpopulate(val, "RequiredZoneNames", &p.RequiredZoneNames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnection.
func (p PrivateLinkServiceConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "requestMessage", p.RequestMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnection.
func (p *PrivateLinkServiceConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupIds":
			err = unpopulate(val, "GroupIDs", &p.GroupIDs)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "requestMessage":
			err = unpopulate(val, "RequestMessage", &p.RequestMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnectionState.
func (p PrivateLinkServiceConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnectionState.
func (p *PrivateLinkServiceConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceProxy.
func (p PrivateLinkServiceProxy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupConnectivityInformation", p.GroupConnectivityInformation)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "remotePrivateEndpointConnection", p.RemotePrivateEndpointConnection)
	populate(objectMap, "remotePrivateLinkServiceConnectionState", p.RemotePrivateLinkServiceConnectionState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceProxy.
func (p *PrivateLinkServiceProxy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupConnectivityInformation":
			err = unpopulate(val, "GroupConnectivityInformation", &p.GroupConnectivityInformation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "remotePrivateEndpointConnection":
			err = unpopulate(val, "RemotePrivateEndpointConnection", &p.RemotePrivateEndpointConnection)
			delete(rawMsg, key)
		case "remotePrivateLinkServiceConnectionState":
			err = unpopulate(val, "RemotePrivateLinkServiceConnectionState", &p.RemotePrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectResultList.
func (p ProjectResultList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectResultList.
func (p *ProjectResultList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectSummary.
func (p ProjectSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedSummary", p.ExtendedSummary)
	populate(objectMap, "instanceType", p.InstanceType)
	populateDateTimeRFC3339(objectMap, "lastSummaryRefreshedTime", p.LastSummaryRefreshedTime)
	populate(objectMap, "refreshSummaryState", p.RefreshSummaryState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectSummary.
func (p *ProjectSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedSummary":
			err = unpopulate(val, "ExtendedSummary", &p.ExtendedSummary)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &p.InstanceType)
			delete(rawMsg, key)
		case "lastSummaryRefreshedTime":
			err = unpopulateDateTimeRFC3339(val, "LastSummaryRefreshedTime", &p.LastSummaryRefreshedTime)
			delete(rawMsg, key)
		case "refreshSummaryState":
			err = unpopulate(val, "RefreshSummaryState", &p.RefreshSummaryState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RefreshSummaryInput.
func (r RefreshSummaryInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "goal", r.Goal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RefreshSummaryInput.
func (r *RefreshSummaryInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "goal":
			err = unpopulate(val, "Goal", &r.Goal)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RefreshSummaryResult.
func (r RefreshSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isRefreshed", r.IsRefreshed)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RefreshSummaryResult.
func (r *RefreshSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isRefreshed":
			err = unpopulate(val, "IsRefreshed", &r.IsRefreshed)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegisterToolInput.
func (r RegisterToolInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tool", r.Tool)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegisterToolInput.
func (r *RegisterToolInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tool":
			err = unpopulate(val, "Tool", &r.Tool)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistrationDetailsInput.
func (r RegistrationDetailsInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationDetails", r.ApplicationDetails)
	populate(objectMap, "tool", r.Tool)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistrationDetailsInput.
func (r *RegistrationDetailsInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationDetails":
			err = unpopulate(val, "ApplicationDetails", &r.ApplicationDetails)
			delete(rawMsg, key)
		case "tool":
			err = unpopulate(val, "Tool", &r.Tool)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistrationDetailsResponse.
func (r RegistrationDetailsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "oneTimeKey", r.OneTimeKey)
	populate(objectMap, "serviceEndpoint", r.ServiceEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistrationDetailsResponse.
func (r *RegistrationDetailsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oneTimeKey":
			err = unpopulate(val, "OneTimeKey", &r.OneTimeKey)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &r.ServiceEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistrationResult.
func (r RegistrationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isRegistered", r.IsRegistered)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistrationResult.
func (r *RegistrationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isRegistered":
			err = unpopulate(val, "IsRegistered", &r.IsRegistered)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceID.
func (r ResourceID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceID.
func (r *ResourceID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Solution.
func (s Solution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Solution.
func (s *Solution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &s.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SolutionConfig.
func (s SolutionConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "publisherSasUri", s.PublisherSasURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SolutionConfig.
func (s *SolutionConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publisherSasUri":
			err = unpopulate(val, "PublisherSasURI", &s.PublisherSasURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SolutionDetails.
func (s SolutionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentCount", s.AssessmentCount)
	populate(objectMap, "extendedDetails", s.ExtendedDetails)
	populate(objectMap, "groupCount", s.GroupCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SolutionDetails.
func (s *SolutionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentCount":
			err = unpopulate(val, "AssessmentCount", &s.AssessmentCount)
			delete(rawMsg, key)
		case "extendedDetails":
			err = unpopulate(val, "ExtendedDetails", &s.ExtendedDetails)
			delete(rawMsg, key)
		case "groupCount":
			err = unpopulate(val, "GroupCount", &s.GroupCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SolutionProperties.
func (s SolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cleanupState", s.CleanupState)
	populate(objectMap, "details", s.Details)
	populate(objectMap, "goal", s.Goal)
	populate(objectMap, "purpose", s.Purpose)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "summary", s.Summary)
	populate(objectMap, "tool", s.Tool)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SolutionProperties.
func (s *SolutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanupState":
			err = unpopulate(val, "CleanupState", &s.CleanupState)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &s.Details)
			delete(rawMsg, key)
		case "goal":
			err = unpopulate(val, "Goal", &s.Goal)
			delete(rawMsg, key)
		case "purpose":
			err = unpopulate(val, "Purpose", &s.Purpose)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &s.Summary)
			delete(rawMsg, key)
		case "tool":
			err = unpopulate(val, "Tool", &s.Tool)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SolutionSummary.
func (s SolutionSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", s.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SolutionSummary.
func (s *SolutionSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &s.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SolutionsCollection.
func (s SolutionsCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SolutionsCollection.
func (s *SolutionsCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualDesktopUser.
func (v VirtualDesktopUser) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualDesktopUser.
func (v *VirtualDesktopUser) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualDesktopUserAssessmentDetails.
func (v VirtualDesktopUserAssessmentDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activeWeeklyHours", v.ActiveWeeklyHours)
	populate(objectMap, "assessmentId", v.AssessmentID)
	populate(objectMap, "city", v.City)
	populate(objectMap, "country", v.Country)
	populate(objectMap, "criticalApplications", v.CriticalApplications)
	populate(objectMap, "devicesUsed", v.DevicesUsed)
	populate(objectMap, "egressBandwidthWeekly", v.EgressBandwidthWeekly)
	populate(objectMap, "enqueueTime", v.EnqueueTime)
	populate(objectMap, "extendedInfo", v.ExtendedInfo)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "isReadyForMigration", v.IsReadyForMigration)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", v.LastUpdatedTime)
	populate(objectMap, "multiUserWindows10", v.MultiUserWindows10)
	populate(objectMap, "osUsed", v.OSUsed)
	populate(objectMap, "persona", v.Persona)
	populate(objectMap, "solutionName", v.SolutionName)
	populate(objectMap, "state", v.State)
	populate(objectMap, "targetAzureVmSize", v.TargetAzureVMSize)
	populate(objectMap, "targetLocation", v.TargetLocation)
	populate(objectMap, "targetStorageType", v.TargetStorageType)
	populate(objectMap, "totalApplicationsCount", v.TotalApplicationsCount)
	populate(objectMap, "userAccount", v.UserAccount)
	populate(objectMap, "userExperienceScore", v.UserExperienceScore)
	populate(objectMap, "userId", v.UserID)
	populate(objectMap, "userName", v.UserName)
	populate(objectMap, "virtualization", v.Virtualization)
	populate(objectMap, "windows7", v.Windows7)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualDesktopUserAssessmentDetails.
func (v *VirtualDesktopUserAssessmentDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeWeeklyHours":
			err = unpopulate(val, "ActiveWeeklyHours", &v.ActiveWeeklyHours)
			delete(rawMsg, key)
		case "assessmentId":
			err = unpopulate(val, "AssessmentID", &v.AssessmentID)
			delete(rawMsg, key)
		case "city":
			err = unpopulate(val, "City", &v.City)
			delete(rawMsg, key)
		case "country":
			err = unpopulate(val, "Country", &v.Country)
			delete(rawMsg, key)
		case "criticalApplications":
			err = unpopulate(val, "CriticalApplications", &v.CriticalApplications)
			delete(rawMsg, key)
		case "devicesUsed":
			err = unpopulate(val, "DevicesUsed", &v.DevicesUsed)
			delete(rawMsg, key)
		case "egressBandwidthWeekly":
			err = unpopulate(val, "EgressBandwidthWeekly", &v.EgressBandwidthWeekly)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &v.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &v.ExtendedInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "isReadyForMigration":
			err = unpopulate(val, "IsReadyForMigration", &v.IsReadyForMigration)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &v.LastUpdatedTime)
			delete(rawMsg, key)
		case "multiUserWindows10":
			err = unpopulate(val, "MultiUserWindows10", &v.MultiUserWindows10)
			delete(rawMsg, key)
		case "osUsed":
			err = unpopulate(val, "OSUsed", &v.OSUsed)
			delete(rawMsg, key)
		case "persona":
			err = unpopulate(val, "Persona", &v.Persona)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &v.SolutionName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "targetAzureVmSize":
			err = unpopulate(val, "TargetAzureVMSize", &v.TargetAzureVMSize)
			delete(rawMsg, key)
		case "targetLocation":
			err = unpopulate(val, "TargetLocation", &v.TargetLocation)
			delete(rawMsg, key)
		case "targetStorageType":
			err = unpopulate(val, "TargetStorageType", &v.TargetStorageType)
			delete(rawMsg, key)
		case "totalApplicationsCount":
			err = unpopulate(val, "TotalApplicationsCount", &v.TotalApplicationsCount)
			delete(rawMsg, key)
		case "userAccount":
			err = unpopulate(val, "UserAccount", &v.UserAccount)
			delete(rawMsg, key)
		case "userExperienceScore":
			err = unpopulate(val, "UserExperienceScore", &v.UserExperienceScore)
			delete(rawMsg, key)
		case "userId":
			err = unpopulate(val, "UserID", &v.UserID)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, "UserName", &v.UserName)
			delete(rawMsg, key)
		case "virtualization":
			err = unpopulate(val, "Virtualization", &v.Virtualization)
			delete(rawMsg, key)
		case "windows7":
			err = unpopulate(val, "Windows7", &v.Windows7)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualDesktopUserCollection.
func (v VirtualDesktopUserCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualDesktopUserCollection.
func (v *VirtualDesktopUserCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualDesktopUserProperties.
func (v VirtualDesktopUserProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentData", v.AssessmentData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", v.LastUpdatedTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualDesktopUserProperties.
func (v *VirtualDesktopUserProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentData":
			err = unpopulate(val, "AssessmentData", &v.AssessmentData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &v.LastUpdatedTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebServer.
func (w WebServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebServer.
func (w *WebServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebServerCollection.
func (w WebServerCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebServerCollection.
func (w *WebServerCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebServerDiscoveryDetails.
func (w WebServerDiscoveryDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuCores", w.CPUCores)
	populate(objectMap, "enqueueTime", w.EnqueueTime)
	populate(objectMap, "extendedInfo", w.ExtendedInfo)
	populate(objectMap, "id", w.ID)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "memoryInMb", w.MemoryInMb)
	populate(objectMap, "osName", w.OSName)
	populate(objectMap, "osVersion", w.OSVersion)
	populate(objectMap, "portList", w.PortList)
	populate(objectMap, "solutionName", w.SolutionName)
	populate(objectMap, "webServerId", w.WebServerID)
	populate(objectMap, "webServerName", w.WebServerName)
	populate(objectMap, "webServerType", w.WebServerType)
	populate(objectMap, "webServerVersion", w.WebServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebServerDiscoveryDetails.
func (w *WebServerDiscoveryDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuCores":
			err = unpopulate(val, "CPUCores", &w.CPUCores)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &w.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &w.ExtendedInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "memoryInMb":
			err = unpopulate(val, "MemoryInMb", &w.MemoryInMb)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &w.OSName)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &w.OSVersion)
			delete(rawMsg, key)
		case "portList":
			err = unpopulate(val, "PortList", &w.PortList)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &w.SolutionName)
			delete(rawMsg, key)
		case "webServerId":
			err = unpopulate(val, "WebServerID", &w.WebServerID)
			delete(rawMsg, key)
		case "webServerName":
			err = unpopulate(val, "WebServerName", &w.WebServerName)
			delete(rawMsg, key)
		case "webServerType":
			err = unpopulate(val, "WebServerType", &w.WebServerType)
			delete(rawMsg, key)
		case "webServerVersion":
			err = unpopulate(val, "WebServerVersion", &w.WebServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebServerProperties.
func (w WebServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "discoveryData", w.DiscoveryData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "summary", w.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebServerProperties.
func (w *WebServerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "discoveryData":
			err = unpopulate(val, "DiscoveryData", &w.DiscoveryData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &w.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebServerSummary.
func (w WebServerSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessedCount", w.AssessedCount)
	populate(objectMap, "discoveredCount", w.DiscoveredCount)
	populate(objectMap, "migratedCount", w.MigratedCount)
	populate(objectMap, "migratingCount", w.MigratingCount)
	populate(objectMap, "readyForMigration", w.ReadyForMigration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebServerSummary.
func (w *WebServerSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedCount":
			err = unpopulate(val, "AssessedCount", &w.AssessedCount)
			delete(rawMsg, key)
		case "discoveredCount":
			err = unpopulate(val, "DiscoveredCount", &w.DiscoveredCount)
			delete(rawMsg, key)
		case "migratedCount":
			err = unpopulate(val, "MigratedCount", &w.MigratedCount)
			delete(rawMsg, key)
		case "migratingCount":
			err = unpopulate(val, "MigratingCount", &w.MigratingCount)
			delete(rawMsg, key)
		case "readyForMigration":
			err = unpopulate(val, "ReadyForMigration", &w.ReadyForMigration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSite.
func (w WebSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSite.
func (w *WebSite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSiteAssessmentDetails.
func (w WebSiteAssessmentDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentId", w.AssessmentID)
	populate(objectMap, "assessmentTargetType", w.AssessmentTargetType)
	populate(objectMap, "enqueueTime", w.EnqueueTime)
	populate(objectMap, "errorList", w.ErrorList)
	populate(objectMap, "extendedInfo", w.ExtendedInfo)
	populate(objectMap, "framework", w.Framework)
	populate(objectMap, "frameworkVersion", w.FrameworkVersion)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "isReadyForMigration", w.IsReadyForMigration)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "migrationBlockersCount", w.MigrationBlockersCount)
	populate(objectMap, "port", w.Port)
	populate(objectMap, "solutionName", w.SolutionName)
	populate(objectMap, "successList", w.SuccessList)
	populate(objectMap, "warningList", w.WarningList)
	populate(objectMap, "webServerId", w.WebServerID)
	populate(objectMap, "webServerType", w.WebServerType)
	populate(objectMap, "webSiteName", w.WebSiteName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSiteAssessmentDetails.
func (w *WebSiteAssessmentDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentId":
			err = unpopulate(val, "AssessmentID", &w.AssessmentID)
			delete(rawMsg, key)
		case "assessmentTargetType":
			err = unpopulate(val, "AssessmentTargetType", &w.AssessmentTargetType)
			delete(rawMsg, key)
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &w.EnqueueTime)
			delete(rawMsg, key)
		case "errorList":
			err = unpopulate(val, "ErrorList", &w.ErrorList)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &w.ExtendedInfo)
			delete(rawMsg, key)
		case "framework":
			err = unpopulate(val, "Framework", &w.Framework)
			delete(rawMsg, key)
		case "frameworkVersion":
			err = unpopulate(val, "FrameworkVersion", &w.FrameworkVersion)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "isReadyForMigration":
			err = unpopulate(val, "IsReadyForMigration", &w.IsReadyForMigration)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "migrationBlockersCount":
			err = unpopulate(val, "MigrationBlockersCount", &w.MigrationBlockersCount)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &w.Port)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &w.SolutionName)
			delete(rawMsg, key)
		case "successList":
			err = unpopulate(val, "SuccessList", &w.SuccessList)
			delete(rawMsg, key)
		case "warningList":
			err = unpopulate(val, "WarningList", &w.WarningList)
			delete(rawMsg, key)
		case "webServerId":
			err = unpopulate(val, "WebServerID", &w.WebServerID)
			delete(rawMsg, key)
		case "webServerType":
			err = unpopulate(val, "WebServerType", &w.WebServerType)
			delete(rawMsg, key)
		case "webSiteName":
			err = unpopulate(val, "WebSiteName", &w.WebSiteName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSiteCollection.
func (w WebSiteCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSiteCollection.
func (w *WebSiteCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSiteDiscoveryDetails.
func (w WebSiteDiscoveryDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enqueueTime", w.EnqueueTime)
	populate(objectMap, "extendedInfo", w.ExtendedInfo)
	populate(objectMap, "id", w.ID)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "port", w.Port)
	populate(objectMap, "solutionName", w.SolutionName)
	populate(objectMap, "webServerId", w.WebServerID)
	populate(objectMap, "webServerType", w.WebServerType)
	populate(objectMap, "webSiteName", w.WebSiteName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSiteDiscoveryDetails.
func (w *WebSiteDiscoveryDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &w.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &w.ExtendedInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &w.Port)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &w.SolutionName)
			delete(rawMsg, key)
		case "webServerId":
			err = unpopulate(val, "WebServerID", &w.WebServerID)
			delete(rawMsg, key)
		case "webServerType":
			err = unpopulate(val, "WebServerType", &w.WebServerType)
			delete(rawMsg, key)
		case "webSiteName":
			err = unpopulate(val, "WebSiteName", &w.WebSiteName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSiteMigrationDetails.
func (w WebSiteMigrationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enqueueTime", w.EnqueueTime)
	populate(objectMap, "extendedInfo", w.ExtendedInfo)
	populate(objectMap, "id", w.ID)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "migrationPhase", w.MigrationPhase)
	populate(objectMap, "port", w.Port)
	populate(objectMap, "progressPercentage", w.ProgressPercentage)
	populate(objectMap, "solutionName", w.SolutionName)
	populate(objectMap, "targetAppServiceArmId", w.TargetAppServiceArmID)
	populate(objectMap, "webServerId", w.WebServerID)
	populate(objectMap, "webServerType", w.WebServerType)
	populate(objectMap, "webSiteName", w.WebSiteName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSiteMigrationDetails.
func (w *WebSiteMigrationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enqueueTime":
			err = unpopulate(val, "EnqueueTime", &w.EnqueueTime)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &w.ExtendedInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "migrationPhase":
			err = unpopulate(val, "MigrationPhase", &w.MigrationPhase)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &w.Port)
			delete(rawMsg, key)
		case "progressPercentage":
			err = unpopulate(val, "ProgressPercentage", &w.ProgressPercentage)
			delete(rawMsg, key)
		case "solutionName":
			err = unpopulate(val, "SolutionName", &w.SolutionName)
			delete(rawMsg, key)
		case "targetAppServiceArmId":
			err = unpopulate(val, "TargetAppServiceArmID", &w.TargetAppServiceArmID)
			delete(rawMsg, key)
		case "webServerId":
			err = unpopulate(val, "WebServerID", &w.WebServerID)
			delete(rawMsg, key)
		case "webServerType":
			err = unpopulate(val, "WebServerType", &w.WebServerType)
			delete(rawMsg, key)
		case "webSiteName":
			err = unpopulate(val, "WebSiteName", &w.WebSiteName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebSiteProperties.
func (w WebSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentData", w.AssessmentData)
	populate(objectMap, "discoveryData", w.DiscoveryData)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", w.LastUpdatedTime)
	populate(objectMap, "migrationData", w.MigrationData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebSiteProperties.
func (w *WebSiteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentData":
			err = unpopulate(val, "AssessmentData", &w.AssessmentData)
			delete(rawMsg, key)
		case "discoveryData":
			err = unpopulate(val, "DiscoveryData", &w.DiscoveryData)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &w.LastUpdatedTime)
			delete(rawMsg, key)
		case "migrationData":
			err = unpopulate(val, "MigrationData", &w.MigrationData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
