package datacollaboration

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/datacollaboration/mgmt/2020-05-04-preview/datacollaboration"

// AdapterBindingConstraint properties for adapter binding constraint
type AdapterBindingConstraint struct {
	// BindingKey - The key of script's source or sink.
	BindingKey *string `json:"bindingKey,omitempty"`
	// ScriptReferenceID - The unique identifier of the adapter script reference.
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
}

// ADLSGen2FileDataSet an ADLS Gen 2 file data set.
type ADLSGen2FileDataSet struct {
	// ADLSGen2FileProperties - AdlsGen2File data source properties.
	*ADLSGen2FileProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) MarshalJSON() ([]byte, error) {
	ag2fds.Kind = KindAdlsGen2File
	objectMap := make(map[string]interface{})
	if ag2fds.ADLSGen2FileProperties != nil {
		objectMap["properties"] = ag2fds.ADLSGen2FileProperties
	}
	if ag2fds.Kind != "" {
		objectMap["kind"] = ag2fds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return &ag2fds, true
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FileDataSet struct.
func (ag2fds *ADLSGen2FileDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FileProperties ADLSGen2FileProperties
				err = json.Unmarshal(*v, &aDLSGen2FileProperties)
				if err != nil {
					return err
				}
				ag2fds.ADLSGen2FileProperties = &aDLSGen2FileProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ag2fds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FileProperties properties of the ADLS Gen2 file data set.
type ADLSGen2FileProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FilePath - File path within the file system.
	FilePath *string `json:"filePath,omitempty"`
	// FileSystem - File system to which the file belongs.
	FileSystem *string `json:"fileSystem,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileProperties.
func (ag2fp ADLSGen2FileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fp.FilePath != nil {
		objectMap["filePath"] = ag2fp.FilePath
	}
	if ag2fp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fp.FileSystem
	}
	if ag2fp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// ADLSGen2FileSystemDataSet an ADLS Gen 2 file system data set.
type ADLSGen2FileSystemDataSet struct {
	// ADLSGen2FileSystemProperties - AdlsGen2FileSystem data source properties.
	*ADLSGen2FileSystemProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) MarshalJSON() ([]byte, error) {
	ag2fsds.Kind = KindAdlsGen2FileSystem
	objectMap := make(map[string]interface{})
	if ag2fsds.ADLSGen2FileSystemProperties != nil {
		objectMap["properties"] = ag2fsds.ADLSGen2FileSystemProperties
	}
	if ag2fsds.Kind != "" {
		objectMap["kind"] = ag2fsds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return &ag2fsds, true
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fsds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FileSystemDataSet struct.
func (ag2fsds *ADLSGen2FileSystemDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FileSystemProperties ADLSGen2FileSystemProperties
				err = json.Unmarshal(*v, &aDLSGen2FileSystemProperties)
				if err != nil {
					return err
				}
				ag2fsds.ADLSGen2FileSystemProperties = &aDLSGen2FileSystemProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fsds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fsds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fsds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ag2fsds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fsds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FileSystemProperties properties of the ADLS Gen2 file system data set.
type ADLSGen2FileSystemProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FileSystem - The file system name.
	FileSystem *string `json:"fileSystem,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileSystemProperties.
func (ag2fsp ADLSGen2FileSystemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fsp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fsp.FileSystem
	}
	if ag2fsp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fsp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// ADLSGen2FolderDataSet an ADLS Gen 2 folder data set.
type ADLSGen2FolderDataSet struct {
	// ADLSGen2FolderProperties - AdlsGen2FileSystem data source properties.
	*ADLSGen2FolderProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) MarshalJSON() ([]byte, error) {
	ag2fds.Kind = KindAdlsGen2Folder
	objectMap := make(map[string]interface{})
	if ag2fds.ADLSGen2FolderProperties != nil {
		objectMap["properties"] = ag2fds.ADLSGen2FolderProperties
	}
	if ag2fds.Kind != "" {
		objectMap["kind"] = ag2fds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return &ag2fds, true
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FolderDataSet struct.
func (ag2fds *ADLSGen2FolderDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FolderProperties ADLSGen2FolderProperties
				err = json.Unmarshal(*v, &aDLSGen2FolderProperties)
				if err != nil {
					return err
				}
				ag2fds.ADLSGen2FolderProperties = &aDLSGen2FolderProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ag2fds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FolderProperties properties of the ADLS Gen2 folder data set.
type ADLSGen2FolderProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FileSystem - File system to which the folder belongs.
	FileSystem *string `json:"fileSystem,omitempty"`
	// FolderPath - Folder path within the file system.
	FolderPath *string `json:"folderPath,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FolderProperties.
func (ag2fp ADLSGen2FolderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fp.FileSystem
	}
	if ag2fp.FolderPath != nil {
		objectMap["folderPath"] = ag2fp.FolderPath
	}
	if ag2fp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobContainerDataSet an Azure storage blob container data set.
type BlobContainerDataSet struct {
	// BlobContainerProperties - Blob container data source properties.
	*BlobContainerProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobContainerDataSet.
func (bcds BlobContainerDataSet) MarshalJSON() ([]byte, error) {
	bcds.Kind = KindContainer
	objectMap := make(map[string]interface{})
	if bcds.BlobContainerProperties != nil {
		objectMap["properties"] = bcds.BlobContainerProperties
	}
	if bcds.Kind != "" {
		objectMap["kind"] = bcds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return &bcds, true
}

// AsBlobDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bcds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobContainerDataSet struct.
func (bcds *BlobContainerDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobContainerProperties BlobContainerProperties
				err = json.Unmarshal(*v, &blobContainerProperties)
				if err != nil {
					return err
				}
				bcds.BlobContainerProperties = &blobContainerProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bcds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bcds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bcds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				bcds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bcds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobContainerProperties properties of the BLOB container data set.
type BlobContainerProperties struct {
	// ContainerName - BLOB Container name.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobContainerProperties.
func (bcp BlobContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bcp.ContainerName != nil {
		objectMap["containerName"] = bcp.ContainerName
	}
	if bcp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bcp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobDataSet an Azure storage blob data set.
type BlobDataSet struct {
	// BlobProperties - Blob data source properties.
	*BlobProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobDataSet.
func (bds BlobDataSet) MarshalJSON() ([]byte, error) {
	bds.Kind = KindBlob
	objectMap := make(map[string]interface{})
	if bds.BlobProperties != nil {
		objectMap["properties"] = bds.BlobProperties
	}
	if bds.Kind != "" {
		objectMap["kind"] = bds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return &bds, true
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobDataSet struct.
func (bds *BlobDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobProperties BlobProperties
				err = json.Unmarshal(*v, &blobProperties)
				if err != nil {
					return err
				}
				bds.BlobProperties = &blobProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				bds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobFolderDataSet an Azure storage blob folder data set.
type BlobFolderDataSet struct {
	// BlobFolderProperties - Blob folder data source properties.
	*BlobFolderProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobFolderDataSet.
func (bfds BlobFolderDataSet) MarshalJSON() ([]byte, error) {
	bfds.Kind = KindBlobFolder
	objectMap := make(map[string]interface{})
	if bfds.BlobFolderProperties != nil {
		objectMap["properties"] = bfds.BlobFolderProperties
	}
	if bfds.Kind != "" {
		objectMap["kind"] = bfds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return &bfds, true
}

// AsDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bfds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobFolderDataSet struct.
func (bfds *BlobFolderDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobFolderProperties BlobFolderProperties
				err = json.Unmarshal(*v, &blobFolderProperties)
				if err != nil {
					return err
				}
				bfds.BlobFolderProperties = &blobFolderProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bfds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bfds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bfds.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				bfds.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bfds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobFolderProperties properties of the blob folder data set.
type BlobFolderProperties struct {
	// ContainerName - Container that has the file path.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// Prefix - Prefix for blob folder
	Prefix *string `json:"prefix,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobFolderProperties.
func (bfp BlobFolderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bfp.ContainerName != nil {
		objectMap["containerName"] = bfp.ContainerName
	}
	if bfp.Prefix != nil {
		objectMap["prefix"] = bfp.Prefix
	}
	if bfp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bfp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobProperties properties of the internal blob data set.
type BlobProperties struct {
	// ContainerName - Container that has the file path.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FilePath - File path within the source data source
	FilePath *string `json:"filePath,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobProperties.
func (bp BlobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.ContainerName != nil {
		objectMap["containerName"] = bp.ContainerName
	}
	if bp.FilePath != nil {
		objectMap["filePath"] = bp.FilePath
	}
	if bp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BooleanPipelineRunParameterAssignment pipeline run boolean parameter assignment
type BooleanPipelineRunParameterAssignment struct {
	// Value - Parameter value
	Value *bool `json:"value,omitempty"`
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	bprpa.ParameterType = ParameterTypeBoolean
	objectMap := make(map[string]interface{})
	if bprpa.Value != nil {
		objectMap["value"] = bprpa.Value
	}
	if bprpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = bprpa.PipelineParameterID
	}
	if bprpa.ParameterType != "" {
		objectMap["parameterType"] = bprpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return &bprpa, true
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for BooleanPipelineRunParameterAssignment.
func (bprpa BooleanPipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &bprpa, true
}

// BooleanScriptParameter script parameter of type boolean
type BooleanScriptParameter struct {
	// DefaultValue - Default parameter value
	DefaultValue *bool `json:"defaultValue,omitempty"`
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for BooleanScriptParameter.
func (bsp BooleanScriptParameter) MarshalJSON() ([]byte, error) {
	bsp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeBoolean
	objectMap := make(map[string]interface{})
	if bsp.DefaultValue != nil {
		objectMap["defaultValue"] = bsp.DefaultValue
	}
	if bsp.Description != nil {
		objectMap["description"] = bsp.Description
	}
	if bsp.Name != nil {
		objectMap["name"] = bsp.Name
	}
	if bsp.ParameterID != nil {
		objectMap["parameterId"] = bsp.ParameterID
	}
	if bsp.ParameterType != "" {
		objectMap["parameterType"] = bsp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return &bsp, true
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return nil, false
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return nil, false
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return nil, false
}

// AsStringScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return nil, false
}

// AsScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return nil, false
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for BooleanScriptParameter.
func (bsp BooleanScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &bsp, true
}

// BoundAdapter bound adapter.
type BoundAdapter struct {
	// AdapterType - The adapter type. Possible values include: 'Standard', 'Custom'
	AdapterType AdapterType `json:"adapterType,omitempty"`
	// ScriptID - The adapter script id
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptRevision - The adapter script revision
	ScriptRevision *int32 `json:"scriptRevision,omitempty"`
}

// BasicBoundDataDescriptor base class for bound data descriptor
type BasicBoundDataDescriptor interface {
	AsDataAssetBoundDataDescriptor() (*DataAssetBoundDataDescriptor, bool)
	AsScriptOutputBoundDataDescriptor() (*ScriptOutputBoundDataDescriptor, bool)
	AsBoundDataDescriptor() (*BoundDataDescriptor, bool)
}

// BoundDataDescriptor base class for bound data descriptor
type BoundDataDescriptor struct {
	// Kind - Possible values include: 'KindBoundDataDescriptor', 'KindDataAsset', 'KindScriptOutput'
	Kind Kind `json:"kind,omitempty"`
}

func unmarshalBasicBoundDataDescriptor(body []byte) (BasicBoundDataDescriptor, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindDataAsset):
		var dabdd DataAssetBoundDataDescriptor
		err := json.Unmarshal(body, &dabdd)
		return dabdd, err
	case string(KindScriptOutput):
		var sobdd ScriptOutputBoundDataDescriptor
		err := json.Unmarshal(body, &sobdd)
		return sobdd, err
	default:
		var bdd BoundDataDescriptor
		err := json.Unmarshal(body, &bdd)
		return bdd, err
	}
}
func unmarshalBasicBoundDataDescriptorArray(body []byte) ([]BasicBoundDataDescriptor, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	bddArray := make([]BasicBoundDataDescriptor, len(rawMessages))

	for index, rawMessage := range rawMessages {
		bdd, err := unmarshalBasicBoundDataDescriptor(*rawMessage)
		if err != nil {
			return nil, err
		}
		bddArray[index] = bdd
	}
	return bddArray, nil
}

// MarshalJSON is the custom marshaler for BoundDataDescriptor.
func (bdd BoundDataDescriptor) MarshalJSON() ([]byte, error) {
	bdd.Kind = KindBoundDataDescriptor
	objectMap := make(map[string]interface{})
	if bdd.Kind != "" {
		objectMap["kind"] = bdd.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetBoundDataDescriptor is the BasicBoundDataDescriptor implementation for BoundDataDescriptor.
func (bdd BoundDataDescriptor) AsDataAssetBoundDataDescriptor() (*DataAssetBoundDataDescriptor, bool) {
	return nil, false
}

// AsScriptOutputBoundDataDescriptor is the BasicBoundDataDescriptor implementation for BoundDataDescriptor.
func (bdd BoundDataDescriptor) AsScriptOutputBoundDataDescriptor() (*ScriptOutputBoundDataDescriptor, bool) {
	return nil, false
}

// AsBoundDataDescriptor is the BasicBoundDataDescriptor implementation for BoundDataDescriptor.
func (bdd BoundDataDescriptor) AsBoundDataDescriptor() (*BoundDataDescriptor, bool) {
	return &bdd, true
}

// AsBasicBoundDataDescriptor is the BasicBoundDataDescriptor implementation for BoundDataDescriptor.
func (bdd BoundDataDescriptor) AsBasicBoundDataDescriptor() (BasicBoundDataDescriptor, bool) {
	return &bdd, true
}

// BasicConstrainedResource a constrained resource data transfer object
type BasicConstrainedResource interface {
	AsSynapseSparkPool() (*SynapseSparkPool, bool)
	AsConstrainedResource() (*ConstrainedResource, bool)
}

// ConstrainedResource a constrained resource data transfer object
type ConstrainedResource struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindConstrainedResource', 'KindSynapseSparkPool'
	Kind KindBasicConstrainedResource `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicConstrainedResource(body []byte) (BasicConstrainedResource, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindSynapseSparkPool):
		var ssp SynapseSparkPool
		err := json.Unmarshal(body, &ssp)
		return ssp, err
	default:
		var cr ConstrainedResource
		err := json.Unmarshal(body, &cr)
		return cr, err
	}
}
func unmarshalBasicConstrainedResourceArray(body []byte) ([]BasicConstrainedResource, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	crArray := make([]BasicConstrainedResource, len(rawMessages))

	for index, rawMessage := range rawMessages {
		cr, err := unmarshalBasicConstrainedResource(*rawMessage)
		if err != nil {
			return nil, err
		}
		crArray[index] = cr
	}
	return crArray, nil
}

// MarshalJSON is the custom marshaler for ConstrainedResource.
func (cr ConstrainedResource) MarshalJSON() ([]byte, error) {
	cr.Kind = KindConstrainedResource
	objectMap := make(map[string]interface{})
	if cr.Kind != "" {
		objectMap["kind"] = cr.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPool is the BasicConstrainedResource implementation for ConstrainedResource.
func (cr ConstrainedResource) AsSynapseSparkPool() (*SynapseSparkPool, bool) {
	return nil, false
}

// AsConstrainedResource is the BasicConstrainedResource implementation for ConstrainedResource.
func (cr ConstrainedResource) AsConstrainedResource() (*ConstrainedResource, bool) {
	return &cr, true
}

// AsBasicConstrainedResource is the BasicConstrainedResource implementation for ConstrainedResource.
func (cr ConstrainedResource) AsBasicConstrainedResource() (BasicConstrainedResource, bool) {
	return &cr, true
}

// ConstrainedResourceList list response for list ConstrainedResources
type ConstrainedResourceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicConstrainedResource `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstrainedResourceList struct.
func (crl *ConstrainedResourceList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				crl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicConstrainedResourceArray(*v)
				if err != nil {
					return err
				}
				crl.Value = &value
			}
		}
	}

	return nil
}

// ConstrainedResourceListIterator provides access to a complete listing of ConstrainedResource values.
type ConstrainedResourceListIterator struct {
	i    int
	page ConstrainedResourceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConstrainedResourceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstrainedResourceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConstrainedResourceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConstrainedResourceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConstrainedResourceListIterator) Response() ConstrainedResourceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConstrainedResourceListIterator) Value() BasicConstrainedResource {
	if !iter.page.NotDone() {
		return ConstrainedResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConstrainedResourceListIterator type.
func NewConstrainedResourceListIterator(page ConstrainedResourceListPage) ConstrainedResourceListIterator {
	return ConstrainedResourceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (crl ConstrainedResourceList) IsEmpty() bool {
	return crl.Value == nil || len(*crl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (crl ConstrainedResourceList) hasNextLink() bool {
	return crl.NextLink != nil && len(*crl.NextLink) != 0
}

// constrainedResourceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (crl ConstrainedResourceList) constrainedResourceListPreparer(ctx context.Context) (*http.Request, error) {
	if !crl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(crl.NextLink)))
}

// ConstrainedResourceListPage contains a page of BasicConstrainedResource values.
type ConstrainedResourceListPage struct {
	fn  func(context.Context, ConstrainedResourceList) (ConstrainedResourceList, error)
	crl ConstrainedResourceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConstrainedResourceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstrainedResourceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.crl)
		if err != nil {
			return err
		}
		page.crl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConstrainedResourceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConstrainedResourceListPage) NotDone() bool {
	return !page.crl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConstrainedResourceListPage) Response() ConstrainedResourceList {
	return page.crl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConstrainedResourceListPage) Values() []BasicConstrainedResource {
	if page.crl.IsEmpty() {
		return nil
	}
	return *page.crl.Value
}

// Creates a new instance of the ConstrainedResourceListPage type.
func NewConstrainedResourceListPage(cur ConstrainedResourceList, getNextPage func(context.Context, ConstrainedResourceList) (ConstrainedResourceList, error)) ConstrainedResourceListPage {
	return ConstrainedResourceListPage{
		fn:  getNextPage,
		crl: cur,
	}
}

// ConstrainedResourceModel ...
type ConstrainedResourceModel struct {
	autorest.Response `json:"-"`
	Value             BasicConstrainedResource `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstrainedResourceModel struct.
func (crm *ConstrainedResourceModel) UnmarshalJSON(body []byte) error {
	cr, err := unmarshalBasicConstrainedResource(body)
	if err != nil {
		return err
	}
	crm.Value = cr

	return nil
}

// ConstrainedResourcesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConstrainedResourcesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConstrainedResourcesClient) (ConstrainedResourceModel, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConstrainedResourcesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConstrainedResourcesCreateOrUpdateFuture.Result.
func (future *ConstrainedResourcesCreateOrUpdateFuture) result(client ConstrainedResourcesClient) (crm ConstrainedResourceModel, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstrainedResourcesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		crm.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ConstrainedResourcesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if crm.Response.Response, err = future.GetResult(sender); err == nil && crm.Response.Response.StatusCode != http.StatusNoContent {
		crm, err = client.CreateOrUpdateResponder(crm.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ConstrainedResourcesCreateOrUpdateFuture", "Result", crm.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConstrainedResourcesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConstrainedResourcesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConstrainedResourcesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConstrainedResourcesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConstrainedResourcesDeleteFuture.Result.
func (future *ConstrainedResourcesDeleteFuture) result(client ConstrainedResourcesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstrainedResourcesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ConstrainedResourcesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ConstrainedResourcesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicConstraint constraint for entitlement, restricts the access granted by it.
type BasicConstraint interface {
	AsLocationConstraint() (*LocationConstraint, bool)
	AsScriptConstraint() (*ScriptConstraint, bool)
	AsScriptParameterConstraint() (*ScriptParameterConstraint, bool)
	AsConstraint() (*Constraint, bool)
}

// Constraint constraint for entitlement, restricts the access granted by it.
type Constraint struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript', 'KindScriptParameter'
	Kind KindBasicConstraint `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicConstraint(body []byte) (BasicConstraint, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindLocation):
		var lc LocationConstraint
		err := json.Unmarshal(body, &lc)
		return lc, err
	case string(KindScript):
		var sc ScriptConstraint
		err := json.Unmarshal(body, &sc)
		return sc, err
	case string(KindScriptParameter):
		var spc ScriptParameterConstraint
		err := json.Unmarshal(body, &spc)
		return spc, err
	default:
		var c Constraint
		err := json.Unmarshal(body, &c)
		return c, err
	}
}
func unmarshalBasicConstraintArray(body []byte) ([]BasicConstraint, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	cArray := make([]BasicConstraint, len(rawMessages))

	for index, rawMessage := range rawMessages {
		c, err := unmarshalBasicConstraint(*rawMessage)
		if err != nil {
			return nil, err
		}
		cArray[index] = c
	}
	return cArray, nil
}

// MarshalJSON is the custom marshaler for Constraint.
func (c Constraint) MarshalJSON() ([]byte, error) {
	c.Kind = KindConstraint
	objectMap := make(map[string]interface{})
	if c.Kind != "" {
		objectMap["kind"] = c.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return nil, false
}

// AsScriptConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return nil, false
}

// AsScriptParameterConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsScriptParameterConstraint() (*ScriptParameterConstraint, bool) {
	return nil, false
}

// AsConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsConstraint() (*Constraint, bool) {
	return &c, true
}

// AsBasicConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &c, true
}

// ConstraintList list response for get Constraints
type ConstraintList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicConstraint `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstraintList struct.
func (cl *ConstraintList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				cl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicConstraintArray(*v)
				if err != nil {
					return err
				}
				cl.Value = &value
			}
		}
	}

	return nil
}

// ConstraintListIterator provides access to a complete listing of Constraint values.
type ConstraintListIterator struct {
	i    int
	page ConstraintListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConstraintListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConstraintListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConstraintListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConstraintListIterator) Response() ConstraintList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConstraintListIterator) Value() BasicConstraint {
	if !iter.page.NotDone() {
		return Constraint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConstraintListIterator type.
func NewConstraintListIterator(page ConstraintListPage) ConstraintListIterator {
	return ConstraintListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cl ConstraintList) IsEmpty() bool {
	return cl.Value == nil || len(*cl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cl ConstraintList) hasNextLink() bool {
	return cl.NextLink != nil && len(*cl.NextLink) != 0
}

// constraintListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cl ConstraintList) constraintListPreparer(ctx context.Context) (*http.Request, error) {
	if !cl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cl.NextLink)))
}

// ConstraintListPage contains a page of BasicConstraint values.
type ConstraintListPage struct {
	fn func(context.Context, ConstraintList) (ConstraintList, error)
	cl ConstraintList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConstraintListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cl)
		if err != nil {
			return err
		}
		page.cl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConstraintListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConstraintListPage) NotDone() bool {
	return !page.cl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConstraintListPage) Response() ConstraintList {
	return page.cl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConstraintListPage) Values() []BasicConstraint {
	if page.cl.IsEmpty() {
		return nil
	}
	return *page.cl.Value
}

// Creates a new instance of the ConstraintListPage type.
func NewConstraintListPage(cur ConstraintList, getNextPage func(context.Context, ConstraintList) (ConstraintList, error)) ConstraintListPage {
	return ConstraintListPage{
		fn: getNextPage,
		cl: cur,
	}
}

// ConstraintModel ...
type ConstraintModel struct {
	autorest.Response `json:"-"`
	Value             BasicConstraint `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstraintModel struct.
func (cm *ConstraintModel) UnmarshalJSON(body []byte) error {
	c, err := unmarshalBasicConstraint(body)
	if err != nil {
		return err
	}
	cm.Value = c

	return nil
}

// ConstraintsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConstraintsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConstraintsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConstraintsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConstraintsDeleteFuture.Result.
func (future *ConstraintsDeleteFuture) result(client ConstraintsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ConstraintsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConsumerInvitation a consumer Invitation data transfer object.
type ConsumerInvitation struct {
	autorest.Response `json:"-"`
	// Location - READ-ONLY; Invitation location
	Location *string `json:"location,omitempty"`
	// ConsumerInvitationProperties - Properties on the account
	*ConsumerInvitationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ConsumerInvitation.
func (ci ConsumerInvitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ci.ConsumerInvitationProperties != nil {
		objectMap["properties"] = ci.ConsumerInvitationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConsumerInvitation struct.
func (ci *ConsumerInvitation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ci.Location = &location
			}
		case "properties":
			if v != nil {
				var consumerInvitationProperties ConsumerInvitationProperties
				err = json.Unmarshal(*v, &consumerInvitationProperties)
				if err != nil {
					return err
				}
				ci.ConsumerInvitationProperties = &consumerInvitationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ci.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ci.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ci.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ci.Type = &typeVar
			}
		}
	}

	return nil
}

// ConsumerInvitationList list response for get InvitationList
type ConsumerInvitationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]ConsumerInvitation `json:"value,omitempty"`
}

// ConsumerInvitationListIterator provides access to a complete listing of ConsumerInvitation values.
type ConsumerInvitationListIterator struct {
	i    int
	page ConsumerInvitationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConsumerInvitationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConsumerInvitationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConsumerInvitationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConsumerInvitationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConsumerInvitationListIterator) Response() ConsumerInvitationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConsumerInvitationListIterator) Value() ConsumerInvitation {
	if !iter.page.NotDone() {
		return ConsumerInvitation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConsumerInvitationListIterator type.
func NewConsumerInvitationListIterator(page ConsumerInvitationListPage) ConsumerInvitationListIterator {
	return ConsumerInvitationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cil ConsumerInvitationList) IsEmpty() bool {
	return cil.Value == nil || len(*cil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cil ConsumerInvitationList) hasNextLink() bool {
	return cil.NextLink != nil && len(*cil.NextLink) != 0
}

// consumerInvitationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cil ConsumerInvitationList) consumerInvitationListPreparer(ctx context.Context) (*http.Request, error) {
	if !cil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cil.NextLink)))
}

// ConsumerInvitationListPage contains a page of ConsumerInvitation values.
type ConsumerInvitationListPage struct {
	fn  func(context.Context, ConsumerInvitationList) (ConsumerInvitationList, error)
	cil ConsumerInvitationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConsumerInvitationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConsumerInvitationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cil)
		if err != nil {
			return err
		}
		page.cil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConsumerInvitationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConsumerInvitationListPage) NotDone() bool {
	return !page.cil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConsumerInvitationListPage) Response() ConsumerInvitationList {
	return page.cil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConsumerInvitationListPage) Values() []ConsumerInvitation {
	if page.cil.IsEmpty() {
		return nil
	}
	return *page.cil.Value
}

// Creates a new instance of the ConsumerInvitationListPage type.
func NewConsumerInvitationListPage(cur ConsumerInvitationList, getNextPage func(context.Context, ConsumerInvitationList) (ConsumerInvitationList, error)) ConsumerInvitationListPage {
	return ConsumerInvitationListPage{
		fn:  getNextPage,
		cil: cur,
	}
}

// ConsumerInvitationProperties properties of consumer invitation
type ConsumerInvitationProperties struct {
	// Description - READ-ONLY; Description shared when the invitation was created
	Description *string `json:"description,omitempty"`
	// InvitationID - Unique id of the invitation.
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationStatus - READ-ONLY; The status of the invitation. Possible values include: 'Pending', 'Rejected', 'Accepted'
	InvitationStatus InvitationStatus `json:"invitationStatus,omitempty"`
	// ProposalName - READ-ONLY; Gets the source proposal Name.
	ProposalName *string `json:"proposalName,omitempty"`
	// ProviderEmail - READ-ONLY; Email of the provider who created the resource
	ProviderEmail *string `json:"providerEmail,omitempty"`
	// ProviderName - READ-ONLY; Name of the provider who created the resource
	ProviderName *string `json:"providerName,omitempty"`
	// ProviderTenantName - READ-ONLY; Tenant name of the provider who created the resource
	ProviderTenantName *string `json:"providerTenantName,omitempty"`
	// RespondedAt - READ-ONLY; The time the recipient responded to the invitation.
	RespondedAt *date.Time `json:"respondedAt,omitempty"`
	// SentAt - READ-ONLY; Gets the time at which the invitation was sent.
	SentAt *date.Time `json:"sentAt,omitempty"`
	// TermsOfUse - READ-ONLY; Terms of use proposal when the invitation was created
	TermsOfUse *string `json:"termsOfUse,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON is the custom marshaler for ConsumerInvitationProperties.
func (cip ConsumerInvitationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cip.InvitationID != nil {
		objectMap["invitationId"] = cip.InvitationID
	}
	return json.Marshal(objectMap)
}

// DataAsset data asset that can be referenced from a proposal.
type DataAsset struct {
	autorest.Response `json:"-"`
	// DataAssetProperties - The property bag of the DataAsset
	*DataAssetProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAsset.
func (da DataAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if da.DataAssetProperties != nil {
		objectMap["properties"] = da.DataAssetProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataAsset struct.
func (da *DataAsset) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetProperties DataAssetProperties
				err = json.Unmarshal(*v, &dataAssetProperties)
				if err != nil {
					return err
				}
				da.DataAssetProperties = &dataAssetProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				da.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				da.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				da.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				da.Type = &typeVar
			}
		}
	}

	return nil
}

// DataAssetBoundDataDescriptor data asset bound data descriptor
type DataAssetBoundDataDescriptor struct {
	// DataAssetID - The bounded data asset Id
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Kind - Possible values include: 'KindBoundDataDescriptor', 'KindDataAsset', 'KindScriptOutput'
	Kind Kind `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetBoundDataDescriptor.
func (dabdd DataAssetBoundDataDescriptor) MarshalJSON() ([]byte, error) {
	dabdd.Kind = KindDataAsset
	objectMap := make(map[string]interface{})
	if dabdd.DataAssetID != nil {
		objectMap["dataAssetId"] = dabdd.DataAssetID
	}
	if dabdd.Kind != "" {
		objectMap["kind"] = dabdd.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetBoundDataDescriptor is the BasicBoundDataDescriptor implementation for DataAssetBoundDataDescriptor.
func (dabdd DataAssetBoundDataDescriptor) AsDataAssetBoundDataDescriptor() (*DataAssetBoundDataDescriptor, bool) {
	return &dabdd, true
}

// AsScriptOutputBoundDataDescriptor is the BasicBoundDataDescriptor implementation for DataAssetBoundDataDescriptor.
func (dabdd DataAssetBoundDataDescriptor) AsScriptOutputBoundDataDescriptor() (*ScriptOutputBoundDataDescriptor, bool) {
	return nil, false
}

// AsBoundDataDescriptor is the BasicBoundDataDescriptor implementation for DataAssetBoundDataDescriptor.
func (dabdd DataAssetBoundDataDescriptor) AsBoundDataDescriptor() (*BoundDataDescriptor, bool) {
	return nil, false
}

// AsBasicBoundDataDescriptor is the BasicBoundDataDescriptor implementation for DataAssetBoundDataDescriptor.
func (dabdd DataAssetBoundDataDescriptor) AsBasicBoundDataDescriptor() (BasicBoundDataDescriptor, bool) {
	return &dabdd, true
}

// DataAssetList list response for get data assets
type DataAssetList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]DataAsset `json:"value,omitempty"`
}

// DataAssetListIterator provides access to a complete listing of DataAsset values.
type DataAssetListIterator struct {
	i    int
	page DataAssetListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataAssetListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataAssetListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataAssetListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataAssetListIterator) Response() DataAssetList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataAssetListIterator) Value() DataAsset {
	if !iter.page.NotDone() {
		return DataAsset{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataAssetListIterator type.
func NewDataAssetListIterator(page DataAssetListPage) DataAssetListIterator {
	return DataAssetListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dal DataAssetList) IsEmpty() bool {
	return dal.Value == nil || len(*dal.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dal DataAssetList) hasNextLink() bool {
	return dal.NextLink != nil && len(*dal.NextLink) != 0
}

// dataAssetListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dal DataAssetList) dataAssetListPreparer(ctx context.Context) (*http.Request, error) {
	if !dal.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dal.NextLink)))
}

// DataAssetListPage contains a page of DataAsset values.
type DataAssetListPage struct {
	fn  func(context.Context, DataAssetList) (DataAssetList, error)
	dal DataAssetList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataAssetListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dal)
		if err != nil {
			return err
		}
		page.dal = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataAssetListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataAssetListPage) NotDone() bool {
	return !page.dal.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataAssetListPage) Response() DataAssetList {
	return page.dal
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataAssetListPage) Values() []DataAsset {
	if page.dal.IsEmpty() {
		return nil
	}
	return *page.dal.Value
}

// Creates a new instance of the DataAssetListPage type.
func NewDataAssetListPage(cur DataAssetList, getNextPage func(context.Context, DataAssetList) (DataAssetList, error)) DataAssetListPage {
	return DataAssetListPage{
		fn:  getNextPage,
		dal: cur,
	}
}

// DataAssetProperties properties of the DataAsset
type DataAssetProperties struct {
	// DataAssetID - READ-ONLY; Unique id for identifying a data asset resource
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// DataProcessingStrategy - Data processing strategy to use for the the child DataSets. Possible values include: 'CopyBased', 'InPlace'
	DataProcessingStrategy DataProcessingStrategy `json:"dataProcessingStrategy,omitempty"`
	// Description - General Description of the DataSet content
	Description *string `json:"description,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the DataAsset. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetProperties.
func (dap DataAssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dap.DataProcessingStrategy != "" {
		objectMap["dataProcessingStrategy"] = dap.DataProcessingStrategy
	}
	if dap.Description != nil {
		objectMap["description"] = dap.Description
	}
	return json.Marshal(objectMap)
}

// DataAssetReference reference to a data asset.
type DataAssetReference struct {
	autorest.Response `json:"-"`
	// DataAssetReferenceProperties - Properties on the dataset reference
	*DataAssetReferenceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReference.
func (dar DataAssetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dar.DataAssetReferenceProperties != nil {
		objectMap["properties"] = dar.DataAssetReferenceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataAssetReference struct.
func (dar *DataAssetReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetReferenceProperties DataAssetReferenceProperties
				err = json.Unmarshal(*v, &dataAssetReferenceProperties)
				if err != nil {
					return err
				}
				dar.DataAssetReferenceProperties = &dataAssetReferenceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dar.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dar.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dar.Type = &typeVar
			}
		}
	}

	return nil
}

// DataAssetReferenceList list response for get dataSet references
type DataAssetReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]DataAssetReference `json:"value,omitempty"`
}

// DataAssetReferenceListIterator provides access to a complete listing of DataAssetReference values.
type DataAssetReferenceListIterator struct {
	i    int
	page DataAssetReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataAssetReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataAssetReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataAssetReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataAssetReferenceListIterator) Response() DataAssetReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataAssetReferenceListIterator) Value() DataAssetReference {
	if !iter.page.NotDone() {
		return DataAssetReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataAssetReferenceListIterator type.
func NewDataAssetReferenceListIterator(page DataAssetReferenceListPage) DataAssetReferenceListIterator {
	return DataAssetReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (darl DataAssetReferenceList) IsEmpty() bool {
	return darl.Value == nil || len(*darl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (darl DataAssetReferenceList) hasNextLink() bool {
	return darl.NextLink != nil && len(*darl.NextLink) != 0
}

// dataAssetReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (darl DataAssetReferenceList) dataAssetReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !darl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(darl.NextLink)))
}

// DataAssetReferenceListPage contains a page of DataAssetReference values.
type DataAssetReferenceListPage struct {
	fn   func(context.Context, DataAssetReferenceList) (DataAssetReferenceList, error)
	darl DataAssetReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataAssetReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.darl)
		if err != nil {
			return err
		}
		page.darl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataAssetReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataAssetReferenceListPage) NotDone() bool {
	return !page.darl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataAssetReferenceListPage) Response() DataAssetReferenceList {
	return page.darl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataAssetReferenceListPage) Values() []DataAssetReference {
	if page.darl.IsEmpty() {
		return nil
	}
	return *page.darl.Value
}

// Creates a new instance of the DataAssetReferenceListPage type.
func NewDataAssetReferenceListPage(cur DataAssetReferenceList, getNextPage func(context.Context, DataAssetReferenceList) (DataAssetReferenceList, error)) DataAssetReferenceListPage {
	return DataAssetReferenceListPage{
		fn:   getNextPage,
		darl: cur,
	}
}

// DataAssetReferencePlaceholderInfo placeholder information for a data asset reference
type DataAssetReferencePlaceholderInfo struct {
	// AssignerID - Participant id who is allowed to assign the placeholder.
	AssignerID *string `json:"assignerId,omitempty"`
	// Description - Description of the placeholder.
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name of the placeholder.
	DisplayName *string `json:"displayName,omitempty"`
}

// DataAssetReferenceProperties properties of data set reference data transfer object.
type DataAssetReferenceProperties struct {
	// DataAccessType - The data asset reference type. Represents the data access allowed using this data in pipeline. Possible values include: 'ReadOnly', 'WriteOnly'
	DataAccessType DataAccessType `json:"dataAccessType,omitempty"`
	// DataAssetID - The unique identifier of the referenced data asset
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// DataAssetReferenceID - READ-ONLY; Unique id for identifying a dataset reference resource
	DataAssetReferenceID *string `json:"dataAssetReferenceId,omitempty"`
	// Description - General Description of the data asset reference
	Description *string `json:"description,omitempty"`
	// DisplayName - Reference display name
	DisplayName *string `json:"displayName,omitempty"`
	// OwnerID - READ-ONLY; The participant id of the data asset owner
	OwnerID *string `json:"ownerId,omitempty"`
	// PlaceholderInfo - The placeholder information
	PlaceholderInfo *DataAssetReferencePlaceholderInfo `json:"placeholderInfo,omitempty"`
	// PlaceholderState - READ-ONLY; The placeholder state. Possible values include: 'PlaceholderStateNone', 'PlaceholderStateUnassigned', 'PlaceholderStateAssigned'
	PlaceholderState PlaceholderState `json:"placeholderState,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReferenceProperties.
func (darp DataAssetReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if darp.DataAccessType != "" {
		objectMap["dataAccessType"] = darp.DataAccessType
	}
	if darp.DataAssetID != nil {
		objectMap["dataAssetId"] = darp.DataAssetID
	}
	if darp.Description != nil {
		objectMap["description"] = darp.Description
	}
	if darp.DisplayName != nil {
		objectMap["displayName"] = darp.DisplayName
	}
	if darp.PlaceholderInfo != nil {
		objectMap["placeholderInfo"] = darp.PlaceholderInfo
	}
	return json.Marshal(objectMap)
}

// DataAssetReferenceResourceReference resourceReference used to only allow access if the resource is used
// within the specified Azure dataAssetReference.
type DataAssetReferenceResourceReference struct {
	// DataAssetReferenceResourceReferenceProperties - Properties for dataAssetReference resource reference
	*DataAssetReferenceResourceReferenceProperties `json:"properties,omitempty"`
	// ParticipantDetails - READ-ONLY; Participant Details of the resource
	ParticipantDetails *ResourceReferenceParticipantDetails `json:"participantDetails,omitempty"`
	// ResourceID - READ-ONLY; Id of the azure resource
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceName - READ-ONLY; Name of the azure resource
	ResourceName *string `json:"resourceName,omitempty"`
	// ResourceType - READ-ONLY; Type of the azure resource
	ResourceType *string `json:"resourceType,omitempty"`
	// SystemData - READ-ONLY; SystemData Info of resource
	SystemData *ResourceReferenceSystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicResourceReferenceKindResourceReference', 'KindBasicResourceReferenceKindDataAssetReference', 'KindBasicResourceReferenceKindDataAsset', 'KindBasicResourceReferenceKindScriptReference', 'KindBasicResourceReferenceKindScript'
	Kind KindBasicResourceReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) MarshalJSON() ([]byte, error) {
	darrr.Kind = KindBasicResourceReferenceKindDataAssetReference
	objectMap := make(map[string]interface{})
	if darrr.DataAssetReferenceResourceReferenceProperties != nil {
		objectMap["properties"] = darrr.DataAssetReferenceResourceReferenceProperties
	}
	if darrr.Kind != "" {
		objectMap["kind"] = darrr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetReferenceResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool) {
	return &darrr, true
}

// AsDataAssetResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsDataAssetResourceReference() (*DataAssetResourceReference, bool) {
	return nil, false
}

// AsScriptReferenceResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool) {
	return nil, false
}

// AsScriptResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsScriptResourceReference() (*ScriptResourceReference, bool) {
	return nil, false
}

// AsResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsResourceReference() (*ResourceReference, bool) {
	return nil, false
}

// AsBasicResourceReference is the BasicResourceReference implementation for DataAssetReferenceResourceReference.
func (darrr DataAssetReferenceResourceReference) AsBasicResourceReference() (BasicResourceReference, bool) {
	return &darrr, true
}

// UnmarshalJSON is the custom unmarshaler for DataAssetReferenceResourceReference struct.
func (darrr *DataAssetReferenceResourceReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetReferenceResourceReferenceProperties DataAssetReferenceResourceReferenceProperties
				err = json.Unmarshal(*v, &dataAssetReferenceResourceReferenceProperties)
				if err != nil {
					return err
				}
				darrr.DataAssetReferenceResourceReferenceProperties = &dataAssetReferenceResourceReferenceProperties
			}
		case "participantDetails":
			if v != nil {
				var participantDetails ResourceReferenceParticipantDetails
				err = json.Unmarshal(*v, &participantDetails)
				if err != nil {
					return err
				}
				darrr.ParticipantDetails = &participantDetails
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				darrr.ResourceID = &resourceID
			}
		case "resourceName":
			if v != nil {
				var resourceName string
				err = json.Unmarshal(*v, &resourceName)
				if err != nil {
					return err
				}
				darrr.ResourceName = &resourceName
			}
		case "resourceType":
			if v != nil {
				var resourceType string
				err = json.Unmarshal(*v, &resourceType)
				if err != nil {
					return err
				}
				darrr.ResourceType = &resourceType
			}
		case "systemData":
			if v != nil {
				var systemData ResourceReferenceSystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				darrr.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicResourceReference
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				darrr.Kind = kind
			}
		}
	}

	return nil
}

// DataAssetReferenceResourceReferenceProperties properties for dataAssetReference resource reference used
// to only allow access if the resource is used within the specified Azure dataAssetReference.
type DataAssetReferenceResourceReferenceProperties struct {
	// DataAccessType - READ-ONLY; The data asset reference type. Represents the data access allowed using this data in pipeline. Possible values include: 'ReadOnly', 'WriteOnly'
	DataAccessType DataAccessType `json:"dataAccessType,omitempty"`
	// DataAssetID - READ-ONLY; The unique identifier of the referenced data asset
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// DataAssetReferenceID - READ-ONLY; The unique identifier of the data asset reference
	DataAssetReferenceID *string `json:"dataAssetReferenceId,omitempty"`
	// Description - READ-ONLY; General Description of the data asset reference
	Description *string `json:"description,omitempty"`
	// DisplayName - READ-ONLY; Reference display name
	DisplayName *string `json:"displayName,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReferenceResourceReferenceProperties.
func (darrrp DataAssetReferenceResourceReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DataAssetReferencesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DataAssetReferencesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DataAssetReferencesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DataAssetReferencesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DataAssetReferencesDeleteFuture.Result.
func (future *DataAssetReferencesDeleteFuture) result(client DataAssetReferencesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetReferencesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataAssetReferencesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetReferencesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataAssetResourceReference resourceReference used to only allow access if the resource is used within
// the specified Azure dataAsset.
type DataAssetResourceReference struct {
	// DataAssetResourceReferenceProperties - Properties for dataAsset resource reference
	*DataAssetResourceReferenceProperties `json:"properties,omitempty"`
	// ParticipantDetails - READ-ONLY; Participant Details of the resource
	ParticipantDetails *ResourceReferenceParticipantDetails `json:"participantDetails,omitempty"`
	// ResourceID - READ-ONLY; Id of the azure resource
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceName - READ-ONLY; Name of the azure resource
	ResourceName *string `json:"resourceName,omitempty"`
	// ResourceType - READ-ONLY; Type of the azure resource
	ResourceType *string `json:"resourceType,omitempty"`
	// SystemData - READ-ONLY; SystemData Info of resource
	SystemData *ResourceReferenceSystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicResourceReferenceKindResourceReference', 'KindBasicResourceReferenceKindDataAssetReference', 'KindBasicResourceReferenceKindDataAsset', 'KindBasicResourceReferenceKindScriptReference', 'KindBasicResourceReferenceKindScript'
	Kind KindBasicResourceReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetResourceReference.
func (darr DataAssetResourceReference) MarshalJSON() ([]byte, error) {
	darr.Kind = KindBasicResourceReferenceKindDataAsset
	objectMap := make(map[string]interface{})
	if darr.DataAssetResourceReferenceProperties != nil {
		objectMap["properties"] = darr.DataAssetResourceReferenceProperties
	}
	if darr.Kind != "" {
		objectMap["kind"] = darr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetReferenceResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool) {
	return nil, false
}

// AsDataAssetResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsDataAssetResourceReference() (*DataAssetResourceReference, bool) {
	return &darr, true
}

// AsScriptReferenceResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool) {
	return nil, false
}

// AsScriptResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsScriptResourceReference() (*ScriptResourceReference, bool) {
	return nil, false
}

// AsResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsResourceReference() (*ResourceReference, bool) {
	return nil, false
}

// AsBasicResourceReference is the BasicResourceReference implementation for DataAssetResourceReference.
func (darr DataAssetResourceReference) AsBasicResourceReference() (BasicResourceReference, bool) {
	return &darr, true
}

// UnmarshalJSON is the custom unmarshaler for DataAssetResourceReference struct.
func (darr *DataAssetResourceReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetResourceReferenceProperties DataAssetResourceReferenceProperties
				err = json.Unmarshal(*v, &dataAssetResourceReferenceProperties)
				if err != nil {
					return err
				}
				darr.DataAssetResourceReferenceProperties = &dataAssetResourceReferenceProperties
			}
		case "participantDetails":
			if v != nil {
				var participantDetails ResourceReferenceParticipantDetails
				err = json.Unmarshal(*v, &participantDetails)
				if err != nil {
					return err
				}
				darr.ParticipantDetails = &participantDetails
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				darr.ResourceID = &resourceID
			}
		case "resourceName":
			if v != nil {
				var resourceName string
				err = json.Unmarshal(*v, &resourceName)
				if err != nil {
					return err
				}
				darr.ResourceName = &resourceName
			}
		case "resourceType":
			if v != nil {
				var resourceType string
				err = json.Unmarshal(*v, &resourceType)
				if err != nil {
					return err
				}
				darr.ResourceType = &resourceType
			}
		case "systemData":
			if v != nil {
				var systemData ResourceReferenceSystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				darr.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicResourceReference
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				darr.Kind = kind
			}
		}
	}

	return nil
}

// DataAssetResourceReferenceProperties properties for dataAsset resource reference used to only allow
// access if the resource is used within the specified Azure dataAsset.
type DataAssetResourceReferenceProperties struct {
	// DataAssetID - READ-ONLY; The unique identifier of the referenced data asset
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Description - READ-ONLY; General Description of the data asset reference
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetResourceReferenceProperties.
func (darrp DataAssetResourceReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DataAssetsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DataAssetsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DataAssetsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DataAssetsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DataAssetsDeleteFuture.Result.
func (future *DataAssetsDeleteFuture) result(client DataAssetsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataAssetsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataMovementPipelineSubstep a substep representing copy data activity
type DataMovementPipelineSubstep struct {
	// DataMovementExecutionStage - READ-ONLY; The stage of data movement. Possible values include: 'Input', 'Output'
	DataMovementExecutionStage DataMovementExecutionStage `json:"dataMovementExecutionStage,omitempty"`
	// DataSetCategory - READ-ONLY; The category of the source dataset
	DataSetCategory *string `json:"dataSetCategory,omitempty"`
	// DataSetName - READ-ONLY; The name of the source dataset
	DataSetName *string `json:"dataSetName,omitempty"`
	// DataSetType - READ-ONLY; The type of the source dataset
	DataSetType *string `json:"dataSetType,omitempty"`
	// NumberOfFiles - READ-ONLY; Number of files written to sink
	NumberOfFiles *int64 `json:"numberOfFiles,omitempty"`
	// ResourceID - READ-ONLY; The resource id of the dataset
	ResourceID *string `json:"resourceId,omitempty"`
	// Source - The sub-step that is the source of data
	Source BasicSubstepReference `json:"source,omitempty"`
	// TotalBytes - READ-ONLY; Total size (in bytes) read from the source
	TotalBytes *int64 `json:"totalBytes,omitempty"`
	// DurationMs - READ-ONLY; Substep run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of substep
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// ExecutionStatus - READ-ONLY; Execution status e.g. Success, Failed, InProgress. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Preparing', 'Queued', 'Unknown', 'Cancelled', 'Canceling', 'Waiting', 'Incomplete'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// PipelineSubstepID - READ-ONLY; Id of pipeline substep.
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// StartTime - READ-ONLY; Start time of substep
	StartTime *date.Time `json:"startTime,omitempty"`
	// Kind - Possible values include: 'KindBasicPipelineSubstepKindPipelineSubstep', 'KindBasicPipelineSubstepKindDataMovement', 'KindBasicPipelineSubstepKindDiagnosticsLog', 'KindBasicPipelineSubstepKindScriptExecution'
	Kind KindBasicPipelineSubstep `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) MarshalJSON() ([]byte, error) {
	dmps.Kind = KindBasicPipelineSubstepKindDataMovement
	objectMap := make(map[string]interface{})
	objectMap["source"] = dmps.Source
	if dmps.Kind != "" {
		objectMap["kind"] = dmps.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementPipelineSubstep is the BasicPipelineSubstep implementation for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) AsDataMovementPipelineSubstep() (*DataMovementPipelineSubstep, bool) {
	return &dmps, true
}

// AsDiagnosticsLogPipelineSubstep is the BasicPipelineSubstep implementation for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) AsDiagnosticsLogPipelineSubstep() (*DiagnosticsLogPipelineSubstep, bool) {
	return nil, false
}

// AsScriptExecutionPipelineSubstep is the BasicPipelineSubstep implementation for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) AsScriptExecutionPipelineSubstep() (*ScriptExecutionPipelineSubstep, bool) {
	return nil, false
}

// AsPipelineSubstep is the BasicPipelineSubstep implementation for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) AsPipelineSubstep() (*PipelineSubstep, bool) {
	return nil, false
}

// AsBasicPipelineSubstep is the BasicPipelineSubstep implementation for DataMovementPipelineSubstep.
func (dmps DataMovementPipelineSubstep) AsBasicPipelineSubstep() (BasicPipelineSubstep, bool) {
	return &dmps, true
}

// UnmarshalJSON is the custom unmarshaler for DataMovementPipelineSubstep struct.
func (dmps *DataMovementPipelineSubstep) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "dataMovementExecutionStage":
			if v != nil {
				var dataMovementExecutionStage DataMovementExecutionStage
				err = json.Unmarshal(*v, &dataMovementExecutionStage)
				if err != nil {
					return err
				}
				dmps.DataMovementExecutionStage = dataMovementExecutionStage
			}
		case "dataSetCategory":
			if v != nil {
				var dataSetCategory string
				err = json.Unmarshal(*v, &dataSetCategory)
				if err != nil {
					return err
				}
				dmps.DataSetCategory = &dataSetCategory
			}
		case "dataSetName":
			if v != nil {
				var dataSetName string
				err = json.Unmarshal(*v, &dataSetName)
				if err != nil {
					return err
				}
				dmps.DataSetName = &dataSetName
			}
		case "dataSetType":
			if v != nil {
				var dataSetType string
				err = json.Unmarshal(*v, &dataSetType)
				if err != nil {
					return err
				}
				dmps.DataSetType = &dataSetType
			}
		case "numberOfFiles":
			if v != nil {
				var numberOfFiles int64
				err = json.Unmarshal(*v, &numberOfFiles)
				if err != nil {
					return err
				}
				dmps.NumberOfFiles = &numberOfFiles
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				dmps.ResourceID = &resourceID
			}
		case "source":
			if v != nil {
				source, err := unmarshalBasicSubstepReference(*v)
				if err != nil {
					return err
				}
				dmps.Source = source
			}
		case "totalBytes":
			if v != nil {
				var totalBytes int64
				err = json.Unmarshal(*v, &totalBytes)
				if err != nil {
					return err
				}
				dmps.TotalBytes = &totalBytes
			}
		case "durationMs":
			if v != nil {
				var durationMs int32
				err = json.Unmarshal(*v, &durationMs)
				if err != nil {
					return err
				}
				dmps.DurationMs = &durationMs
			}
		case "endTime":
			if v != nil {
				var endTime date.Time
				err = json.Unmarshal(*v, &endTime)
				if err != nil {
					return err
				}
				dmps.EndTime = &endTime
			}
		case "errorMessage":
			if v != nil {
				var errorMessage string
				err = json.Unmarshal(*v, &errorMessage)
				if err != nil {
					return err
				}
				dmps.ErrorMessage = &errorMessage
			}
		case "executionStatus":
			if v != nil {
				var executionStatus ExecutionStatus
				err = json.Unmarshal(*v, &executionStatus)
				if err != nil {
					return err
				}
				dmps.ExecutionStatus = executionStatus
			}
		case "pipelineSubstepId":
			if v != nil {
				var pipelineSubstepID string
				err = json.Unmarshal(*v, &pipelineSubstepID)
				if err != nil {
					return err
				}
				dmps.PipelineSubstepID = &pipelineSubstepID
			}
		case "startTime":
			if v != nil {
				var startTime date.Time
				err = json.Unmarshal(*v, &startTime)
				if err != nil {
					return err
				}
				dmps.StartTime = &startTime
			}
		case "kind":
			if v != nil {
				var kind KindBasicPipelineSubstep
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dmps.Kind = kind
			}
		}
	}

	return nil
}

// DataMovementSubstepReference a reference to a data movement sub-step
type DataMovementSubstepReference struct {
	// PipelineStepName - READ-ONLY; The name of the Pipeline Step Run which contains the referred sub-step
	PipelineStepName *string `json:"pipelineStepName,omitempty"`
	// PipelineSubstepID - READ-ONLY; The Id of the Sub-step
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// Kind - Possible values include: 'KindSubstepReference', 'KindDataMovement', 'KindScriptExecution'
	Kind KindBasicSubstepReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DataMovementSubstepReference.
func (dmsr DataMovementSubstepReference) MarshalJSON() ([]byte, error) {
	dmsr.Kind = KindDataMovement
	objectMap := make(map[string]interface{})
	if dmsr.Kind != "" {
		objectMap["kind"] = dmsr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementSubstepReference is the BasicSubstepReference implementation for DataMovementSubstepReference.
func (dmsr DataMovementSubstepReference) AsDataMovementSubstepReference() (*DataMovementSubstepReference, bool) {
	return &dmsr, true
}

// AsScriptExecutionSubstepReference is the BasicSubstepReference implementation for DataMovementSubstepReference.
func (dmsr DataMovementSubstepReference) AsScriptExecutionSubstepReference() (*ScriptExecutionSubstepReference, bool) {
	return nil, false
}

// AsSubstepReference is the BasicSubstepReference implementation for DataMovementSubstepReference.
func (dmsr DataMovementSubstepReference) AsSubstepReference() (*SubstepReference, bool) {
	return nil, false
}

// AsBasicSubstepReference is the BasicSubstepReference implementation for DataMovementSubstepReference.
func (dmsr DataMovementSubstepReference) AsBasicSubstepReference() (BasicSubstepReference, bool) {
	return &dmsr, true
}

// BasicDataSet a set of data from external storage
type BasicDataSet interface {
	AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool)
	AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool)
	AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool)
	AsBlobContainerDataSet() (*BlobContainerDataSet, bool)
	AsBlobDataSet() (*BlobDataSet, bool)
	AsBlobFolderDataSet() (*BlobFolderDataSet, bool)
	AsDataSet() (*DataSet, bool)
}

// DataSet a set of data from external storage
type DataSet struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicDataSet(body []byte) (BasicDataSet, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindAdlsGen2File):
		var ag2fds ADLSGen2FileDataSet
		err := json.Unmarshal(body, &ag2fds)
		return ag2fds, err
	case string(KindAdlsGen2FileSystem):
		var ag2fsds ADLSGen2FileSystemDataSet
		err := json.Unmarshal(body, &ag2fsds)
		return ag2fsds, err
	case string(KindAdlsGen2Folder):
		var ag2fds ADLSGen2FolderDataSet
		err := json.Unmarshal(body, &ag2fds)
		return ag2fds, err
	case string(KindContainer):
		var bcds BlobContainerDataSet
		err := json.Unmarshal(body, &bcds)
		return bcds, err
	case string(KindBlob):
		var bds BlobDataSet
		err := json.Unmarshal(body, &bds)
		return bds, err
	case string(KindBlobFolder):
		var bfds BlobFolderDataSet
		err := json.Unmarshal(body, &bfds)
		return bfds, err
	default:
		var ds DataSet
		err := json.Unmarshal(body, &ds)
		return ds, err
	}
}
func unmarshalBasicDataSetArray(body []byte) ([]BasicDataSet, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dsArray := make([]BasicDataSet, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ds, err := unmarshalBasicDataSet(*rawMessage)
		if err != nil {
			return nil, err
		}
		dsArray[index] = ds
	}
	return dsArray, nil
}

// MarshalJSON is the custom marshaler for DataSet.
func (ds DataSet) MarshalJSON() ([]byte, error) {
	ds.Kind = KindDataSet
	objectMap := make(map[string]interface{})
	if ds.Kind != "" {
		objectMap["kind"] = ds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsDataSet() (*DataSet, bool) {
	return &ds, true
}

// AsBasicDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ds, true
}

// DataSetList list response for get data assets
type DataSetList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicDataSet `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DataSetList struct.
func (dsl *DataSetList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				dsl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicDataSetArray(*v)
				if err != nil {
					return err
				}
				dsl.Value = &value
			}
		}
	}

	return nil
}

// DataSetListIterator provides access to a complete listing of DataSet values.
type DataSetListIterator struct {
	i    int
	page DataSetListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataSetListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataSetListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataSetListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataSetListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataSetListIterator) Response() DataSetList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataSetListIterator) Value() BasicDataSet {
	if !iter.page.NotDone() {
		return DataSet{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataSetListIterator type.
func NewDataSetListIterator(page DataSetListPage) DataSetListIterator {
	return DataSetListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dsl DataSetList) IsEmpty() bool {
	return dsl.Value == nil || len(*dsl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dsl DataSetList) hasNextLink() bool {
	return dsl.NextLink != nil && len(*dsl.NextLink) != 0
}

// dataSetListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dsl DataSetList) dataSetListPreparer(ctx context.Context) (*http.Request, error) {
	if !dsl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dsl.NextLink)))
}

// DataSetListPage contains a page of BasicDataSet values.
type DataSetListPage struct {
	fn  func(context.Context, DataSetList) (DataSetList, error)
	dsl DataSetList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataSetListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataSetListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dsl)
		if err != nil {
			return err
		}
		page.dsl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataSetListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataSetListPage) NotDone() bool {
	return !page.dsl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataSetListPage) Response() DataSetList {
	return page.dsl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataSetListPage) Values() []BasicDataSet {
	if page.dsl.IsEmpty() {
		return nil
	}
	return *page.dsl.Value
}

// Creates a new instance of the DataSetListPage type.
func NewDataSetListPage(cur DataSetList, getNextPage func(context.Context, DataSetList) (DataSetList, error)) DataSetListPage {
	return DataSetListPage{
		fn:  getNextPage,
		dsl: cur,
	}
}

// DataSetModel ...
type DataSetModel struct {
	autorest.Response `json:"-"`
	Value             BasicDataSet `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DataSetModel struct.
func (dsm *DataSetModel) UnmarshalJSON(body []byte) error {
	ds, err := unmarshalBasicDataSet(body)
	if err != nil {
		return err
	}
	dsm.Value = ds

	return nil
}

// DataSetsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DataSetsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DataSetsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DataSetsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DataSetsDeleteFuture.Result.
func (future *DataSetsDeleteFuture) result(client DataSetsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataSetsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataSetsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataSetsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DateTimeOptionsSetScriptParameterRule script Parameter DateTime Options Set validation rule definition
type DateTimeOptionsSetScriptParameterRule struct {
	// Options - Defines a set of value options for the parameter
	Options *[]date.Time `json:"options,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) MarshalJSON() ([]byte, error) {
	dtosspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeDateTimeOptionsSet
	objectMap := make(map[string]interface{})
	if dtosspr.Options != nil {
		objectMap["options"] = dtosspr.Options
	}
	if dtosspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = dtosspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return &dtosspr, true
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for DateTimeOptionsSetScriptParameterRule.
func (dtosspr DateTimeOptionsSetScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &dtosspr, true
}

// DateTimePipelineRunParameterAssignment pipeline run DateTime parameter assignment
type DateTimePipelineRunParameterAssignment struct {
	// Value - Parameter value
	Value *date.Time `json:"value,omitempty"`
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	dtprpa.ParameterType = ParameterTypeDateTime
	objectMap := make(map[string]interface{})
	if dtprpa.Value != nil {
		objectMap["value"] = dtprpa.Value
	}
	if dtprpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = dtprpa.PipelineParameterID
	}
	if dtprpa.ParameterType != "" {
		objectMap["parameterType"] = dtprpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return &dtprpa, true
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for DateTimePipelineRunParameterAssignment.
func (dtprpa DateTimePipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &dtprpa, true
}

// DateTimeRangeScriptParameterRule script Parameter DateTime range validation rule definition
type DateTimeRangeScriptParameterRule struct {
	// MaximumValue - Defines maximum value for the parameter
	MaximumValue *date.Time `json:"maximumValue,omitempty"`
	// MinimumValue - Defines minimum value for the parameter
	MinimumValue *date.Time `json:"minimumValue,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) MarshalJSON() ([]byte, error) {
	dtrspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeDateTimeRange
	objectMap := make(map[string]interface{})
	if dtrspr.MaximumValue != nil {
		objectMap["maximumValue"] = dtrspr.MaximumValue
	}
	if dtrspr.MinimumValue != nil {
		objectMap["minimumValue"] = dtrspr.MinimumValue
	}
	if dtrspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = dtrspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return &dtrspr, true
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for DateTimeRangeScriptParameterRule.
func (dtrspr DateTimeRangeScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &dtrspr, true
}

// DateTimeScriptParameter script parameter of type datetime
type DateTimeScriptParameter struct {
	// DefaultValue - Default parameter value
	DefaultValue *date.Time `json:"defaultValue,omitempty"`
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) MarshalJSON() ([]byte, error) {
	dtsp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeDateTime
	objectMap := make(map[string]interface{})
	if dtsp.DefaultValue != nil {
		objectMap["defaultValue"] = dtsp.DefaultValue
	}
	if dtsp.Description != nil {
		objectMap["description"] = dtsp.Description
	}
	if dtsp.Name != nil {
		objectMap["name"] = dtsp.Name
	}
	if dtsp.ParameterID != nil {
		objectMap["parameterId"] = dtsp.ParameterID
	}
	if dtsp.ParameterType != "" {
		objectMap["parameterType"] = dtsp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return nil, false
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return &dtsp, true
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return nil, false
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return nil, false
}

// AsStringScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return nil, false
}

// AsScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return nil, false
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for DateTimeScriptParameter.
func (dtsp DateTimeScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &dtsp, true
}

// DefaultDto base data transfer object implementation for default resources.
type DefaultDto struct {
	// Location - Location of the azure resource.
	Location *string `json:"location,omitempty"`
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultDto.
func (dd DefaultDto) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dd.Location != nil {
		objectMap["location"] = dd.Location
	}
	if dd.Tags != nil {
		objectMap["tags"] = dd.Tags
	}
	return json.Marshal(objectMap)
}

// DiagnosticPolicy a diagnostic policy.
type DiagnosticPolicy struct {
	// DiagnosticPolicyProperties - Properties for diagnostic policy
	*DiagnosticPolicyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
	// Kind - Possible values include: 'KindPolicy', 'KindDiagnosticLevel', 'KindOutput'
	Kind KindBasicPolicy `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticPolicy.
func (dp DiagnosticPolicy) MarshalJSON() ([]byte, error) {
	dp.Kind = KindDiagnosticLevel
	objectMap := make(map[string]interface{})
	if dp.DiagnosticPolicyProperties != nil {
		objectMap["properties"] = dp.DiagnosticPolicyProperties
	}
	if dp.Kind != "" {
		objectMap["kind"] = dp.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsDiagnosticPolicy() (*DiagnosticPolicy, bool) {
	return &dp, true
}

// AsOutputPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsOutputPolicy() (*OutputPolicy, bool) {
	return nil, false
}

// AsPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsPolicy() (*Policy, bool) {
	return nil, false
}

// AsBasicPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsBasicPolicy() (BasicPolicy, bool) {
	return &dp, true
}

// UnmarshalJSON is the custom unmarshaler for DiagnosticPolicy struct.
func (dp *DiagnosticPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var diagnosticPolicyProperties DiagnosticPolicyProperties
				err = json.Unmarshal(*v, &diagnosticPolicyProperties)
				if err != nil {
					return err
				}
				dp.DiagnosticPolicyProperties = &diagnosticPolicyProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicPolicy
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dp.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dp.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dp.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dp.Type = &typeVar
			}
		}
	}

	return nil
}

// DiagnosticPolicyProperties a diagnostic policy transfer object.
type DiagnosticPolicyProperties struct {
	// Description - Description of the policy
	Description *string `json:"description,omitempty"`
	// LogLevel - The policy log level. Possible values include: 'LogLevelVerbose', 'LogLevelInformation', 'LogLevelWarning', 'LogLevelError', 'LogLevelCritical'
	LogLevel LogLevel `json:"logLevel,omitempty"`
}

// DiagnosticsConsoleLog diagnostics console log.
type DiagnosticsConsoleLog struct {
	// DataAssetID - The data asset Id
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Kind - Possible values include: 'KindDiagnosticsLog', 'KindConsoleLog', 'KindEventLog'
	Kind KindBasicDiagnosticsLog `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticsConsoleLog.
func (dcl DiagnosticsConsoleLog) MarshalJSON() ([]byte, error) {
	dcl.Kind = KindConsoleLog
	objectMap := make(map[string]interface{})
	if dcl.DataAssetID != nil {
		objectMap["dataAssetId"] = dcl.DataAssetID
	}
	if dcl.Kind != "" {
		objectMap["kind"] = dcl.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticsConsoleLog is the BasicDiagnosticsLog implementation for DiagnosticsConsoleLog.
func (dcl DiagnosticsConsoleLog) AsDiagnosticsConsoleLog() (*DiagnosticsConsoleLog, bool) {
	return &dcl, true
}

// AsDiagnosticsEventLog is the BasicDiagnosticsLog implementation for DiagnosticsConsoleLog.
func (dcl DiagnosticsConsoleLog) AsDiagnosticsEventLog() (*DiagnosticsEventLog, bool) {
	return nil, false
}

// AsDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsConsoleLog.
func (dcl DiagnosticsConsoleLog) AsDiagnosticsLog() (*DiagnosticsLog, bool) {
	return nil, false
}

// AsBasicDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsConsoleLog.
func (dcl DiagnosticsConsoleLog) AsBasicDiagnosticsLog() (BasicDiagnosticsLog, bool) {
	return &dcl, true
}

// DiagnosticsEventLog diagnostics event log.
type DiagnosticsEventLog struct {
	// DataAssetID - The data asset Id
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Kind - Possible values include: 'KindDiagnosticsLog', 'KindConsoleLog', 'KindEventLog'
	Kind KindBasicDiagnosticsLog `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticsEventLog.
func (del DiagnosticsEventLog) MarshalJSON() ([]byte, error) {
	del.Kind = KindEventLog
	objectMap := make(map[string]interface{})
	if del.DataAssetID != nil {
		objectMap["dataAssetId"] = del.DataAssetID
	}
	if del.Kind != "" {
		objectMap["kind"] = del.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticsConsoleLog is the BasicDiagnosticsLog implementation for DiagnosticsEventLog.
func (del DiagnosticsEventLog) AsDiagnosticsConsoleLog() (*DiagnosticsConsoleLog, bool) {
	return nil, false
}

// AsDiagnosticsEventLog is the BasicDiagnosticsLog implementation for DiagnosticsEventLog.
func (del DiagnosticsEventLog) AsDiagnosticsEventLog() (*DiagnosticsEventLog, bool) {
	return &del, true
}

// AsDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsEventLog.
func (del DiagnosticsEventLog) AsDiagnosticsLog() (*DiagnosticsLog, bool) {
	return nil, false
}

// AsBasicDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsEventLog.
func (del DiagnosticsEventLog) AsBasicDiagnosticsLog() (BasicDiagnosticsLog, bool) {
	return &del, true
}

// BasicDiagnosticsLog base class for diagnostics log
type BasicDiagnosticsLog interface {
	AsDiagnosticsConsoleLog() (*DiagnosticsConsoleLog, bool)
	AsDiagnosticsEventLog() (*DiagnosticsEventLog, bool)
	AsDiagnosticsLog() (*DiagnosticsLog, bool)
}

// DiagnosticsLog base class for diagnostics log
type DiagnosticsLog struct {
	// DataAssetID - The data asset Id
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Kind - Possible values include: 'KindDiagnosticsLog', 'KindConsoleLog', 'KindEventLog'
	Kind KindBasicDiagnosticsLog `json:"kind,omitempty"`
}

func unmarshalBasicDiagnosticsLog(body []byte) (BasicDiagnosticsLog, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindConsoleLog):
		var dcl DiagnosticsConsoleLog
		err := json.Unmarshal(body, &dcl)
		return dcl, err
	case string(KindEventLog):
		var del DiagnosticsEventLog
		err := json.Unmarshal(body, &del)
		return del, err
	default:
		var dl DiagnosticsLog
		err := json.Unmarshal(body, &dl)
		return dl, err
	}
}
func unmarshalBasicDiagnosticsLogArray(body []byte) ([]BasicDiagnosticsLog, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dlArray := make([]BasicDiagnosticsLog, len(rawMessages))

	for index, rawMessage := range rawMessages {
		dl, err := unmarshalBasicDiagnosticsLog(*rawMessage)
		if err != nil {
			return nil, err
		}
		dlArray[index] = dl
	}
	return dlArray, nil
}

// MarshalJSON is the custom marshaler for DiagnosticsLog.
func (dl DiagnosticsLog) MarshalJSON() ([]byte, error) {
	dl.Kind = KindDiagnosticsLog
	objectMap := make(map[string]interface{})
	if dl.DataAssetID != nil {
		objectMap["dataAssetId"] = dl.DataAssetID
	}
	if dl.Kind != "" {
		objectMap["kind"] = dl.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticsConsoleLog is the BasicDiagnosticsLog implementation for DiagnosticsLog.
func (dl DiagnosticsLog) AsDiagnosticsConsoleLog() (*DiagnosticsConsoleLog, bool) {
	return nil, false
}

// AsDiagnosticsEventLog is the BasicDiagnosticsLog implementation for DiagnosticsLog.
func (dl DiagnosticsLog) AsDiagnosticsEventLog() (*DiagnosticsEventLog, bool) {
	return nil, false
}

// AsDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsLog.
func (dl DiagnosticsLog) AsDiagnosticsLog() (*DiagnosticsLog, bool) {
	return &dl, true
}

// AsBasicDiagnosticsLog is the BasicDiagnosticsLog implementation for DiagnosticsLog.
func (dl DiagnosticsLog) AsBasicDiagnosticsLog() (BasicDiagnosticsLog, bool) {
	return &dl, true
}

// DiagnosticsLogPipelineSubstep a substep representing copy data activity
type DiagnosticsLogPipelineSubstep struct {
	// DataSetCategory - READ-ONLY; The category of the dataset
	DataSetCategory *string `json:"dataSetCategory,omitempty"`
	// DataSetName - READ-ONLY; The name of the dataset
	DataSetName *string `json:"dataSetName,omitempty"`
	// DataSetType - READ-ONLY; The type of the dataset
	DataSetType *string `json:"dataSetType,omitempty"`
	// DiagnosticsLogType - READ-ONLY; The type of the diagnostics log
	DiagnosticsLogType *string `json:"diagnosticsLogType,omitempty"`
	// NumberOfFiles - READ-ONLY; Number of files written to dataset
	NumberOfFiles *int64 `json:"numberOfFiles,omitempty"`
	// ResourceID - READ-ONLY; The resource id of the dataset
	ResourceID *string `json:"resourceId,omitempty"`
	// TotalBytes - READ-ONLY; Total size (in bytes) read from the logs
	TotalBytes *int64 `json:"totalBytes,omitempty"`
	// DurationMs - READ-ONLY; Substep run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of substep
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// ExecutionStatus - READ-ONLY; Execution status e.g. Success, Failed, InProgress. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Preparing', 'Queued', 'Unknown', 'Cancelled', 'Canceling', 'Waiting', 'Incomplete'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// PipelineSubstepID - READ-ONLY; Id of pipeline substep.
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// StartTime - READ-ONLY; Start time of substep
	StartTime *date.Time `json:"startTime,omitempty"`
	// Kind - Possible values include: 'KindBasicPipelineSubstepKindPipelineSubstep', 'KindBasicPipelineSubstepKindDataMovement', 'KindBasicPipelineSubstepKindDiagnosticsLog', 'KindBasicPipelineSubstepKindScriptExecution'
	Kind KindBasicPipelineSubstep `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) MarshalJSON() ([]byte, error) {
	dlps.Kind = KindBasicPipelineSubstepKindDiagnosticsLog
	objectMap := make(map[string]interface{})
	if dlps.Kind != "" {
		objectMap["kind"] = dlps.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementPipelineSubstep is the BasicPipelineSubstep implementation for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) AsDataMovementPipelineSubstep() (*DataMovementPipelineSubstep, bool) {
	return nil, false
}

// AsDiagnosticsLogPipelineSubstep is the BasicPipelineSubstep implementation for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) AsDiagnosticsLogPipelineSubstep() (*DiagnosticsLogPipelineSubstep, bool) {
	return &dlps, true
}

// AsScriptExecutionPipelineSubstep is the BasicPipelineSubstep implementation for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) AsScriptExecutionPipelineSubstep() (*ScriptExecutionPipelineSubstep, bool) {
	return nil, false
}

// AsPipelineSubstep is the BasicPipelineSubstep implementation for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) AsPipelineSubstep() (*PipelineSubstep, bool) {
	return nil, false
}

// AsBasicPipelineSubstep is the BasicPipelineSubstep implementation for DiagnosticsLogPipelineSubstep.
func (dlps DiagnosticsLogPipelineSubstep) AsBasicPipelineSubstep() (BasicPipelineSubstep, bool) {
	return &dlps, true
}

// DimensionProperties properties for dimension
type DimensionProperties struct {
	// DisplayName - localized display name of the dimension to customer
	DisplayName *string `json:"displayName,omitempty"`
	// Name - dimension name
	Name *string `json:"name,omitempty"`
}

// Entitlement grants access to another shared resource in the same proposal, with optional constraints and
// policies
type Entitlement struct {
	autorest.Response `json:"-"`
	// EntitlementProperties - Properties on the entitlement
	*EntitlementProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Entitlement.
func (e Entitlement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.EntitlementProperties != nil {
		objectMap["properties"] = e.EntitlementProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Entitlement struct.
func (e *Entitlement) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var entitlementProperties EntitlementProperties
				err = json.Unmarshal(*v, &entitlementProperties)
				if err != nil {
					return err
				}
				e.EntitlementProperties = &entitlementProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				e.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				e.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				e.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				e.Type = &typeVar
			}
		}
	}

	return nil
}

// EntitlementList list response for get Entitlements
type EntitlementList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Entitlement `json:"value,omitempty"`
}

// EntitlementListIterator provides access to a complete listing of Entitlement values.
type EntitlementListIterator struct {
	i    int
	page EntitlementListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EntitlementListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EntitlementListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EntitlementListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EntitlementListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EntitlementListIterator) Response() EntitlementList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EntitlementListIterator) Value() Entitlement {
	if !iter.page.NotDone() {
		return Entitlement{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EntitlementListIterator type.
func NewEntitlementListIterator(page EntitlementListPage) EntitlementListIterator {
	return EntitlementListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (el EntitlementList) IsEmpty() bool {
	return el.Value == nil || len(*el.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (el EntitlementList) hasNextLink() bool {
	return el.NextLink != nil && len(*el.NextLink) != 0
}

// entitlementListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (el EntitlementList) entitlementListPreparer(ctx context.Context) (*http.Request, error) {
	if !el.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(el.NextLink)))
}

// EntitlementListPage contains a page of Entitlement values.
type EntitlementListPage struct {
	fn func(context.Context, EntitlementList) (EntitlementList, error)
	el EntitlementList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EntitlementListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EntitlementListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.el)
		if err != nil {
			return err
		}
		page.el = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EntitlementListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EntitlementListPage) NotDone() bool {
	return !page.el.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EntitlementListPage) Response() EntitlementList {
	return page.el
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EntitlementListPage) Values() []Entitlement {
	if page.el.IsEmpty() {
		return nil
	}
	return *page.el.Value
}

// Creates a new instance of the EntitlementListPage type.
func NewEntitlementListPage(cur EntitlementList, getNextPage func(context.Context, EntitlementList) (EntitlementList, error)) EntitlementListPage {
	return EntitlementListPage{
		fn: getNextPage,
		el: cur,
	}
}

// EntitlementProperties grants access to another shared resource in the same proposal, with optional some
// constraints and policies
type EntitlementProperties struct {
	// Description - Textual description of the entitlement
	Description *string `json:"description,omitempty"`
	// ResourceID - The unique identifier of the resource of the entitlement.
	// Must be a reference resource from the same proposal.
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceType - The type of resourced used by the entitlement. Possible values include: 'ResourceTypeDataAssetReference', 'ResourceTypeScriptReference', 'ResourceTypeVirtualOutputReference'
	ResourceType ResourceType `json:"resourceType,omitempty"`
	// SubjectID - The unique identifier of the subject of the entitlement.
	// The subject must be a participant in the same proposal.
	SubjectID *string `json:"subjectId,omitempty"`
}

// EntitlementsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type EntitlementsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(EntitlementsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *EntitlementsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for EntitlementsDeleteFuture.Result.
func (future *EntitlementsDeleteFuture) result(client EntitlementsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.EntitlementsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.EntitlementsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.EntitlementsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Error the data collaboration error model.
type Error struct {
	// Error - The data share error body
	Error *ErrorInfo `json:"error,omitempty"`
}

// ErrorInfo the data collaboration error body model.
type ErrorInfo struct {
	// Code - Code of the error
	Code *string `json:"code,omitempty"`
	// Details - Nested details of the error model
	Details *[]ErrorInfo `json:"details,omitempty"`
	// Message - Message of the error
	Message *string `json:"message,omitempty"`
	// Target - Target of the error
	Target *string `json:"target,omitempty"`
}

// FloatOptionsSetScriptParameterRule script Parameter Float Options Set validation rule definition
type FloatOptionsSetScriptParameterRule struct {
	// Options - Defines a set of value options for the parameter
	Options *[]float64 `json:"options,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) MarshalJSON() ([]byte, error) {
	fosspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeFloatOptionsSet
	objectMap := make(map[string]interface{})
	if fosspr.Options != nil {
		objectMap["options"] = fosspr.Options
	}
	if fosspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = fosspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return &fosspr, true
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for FloatOptionsSetScriptParameterRule.
func (fosspr FloatOptionsSetScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &fosspr, true
}

// FloatPipelineRunParameterAssignment pipeline run float parameter assignment
type FloatPipelineRunParameterAssignment struct {
	// Value - Parameter value
	Value *float64 `json:"value,omitempty"`
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	fprpa.ParameterType = ParameterTypeFloat
	objectMap := make(map[string]interface{})
	if fprpa.Value != nil {
		objectMap["value"] = fprpa.Value
	}
	if fprpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = fprpa.PipelineParameterID
	}
	if fprpa.ParameterType != "" {
		objectMap["parameterType"] = fprpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return &fprpa, true
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for FloatPipelineRunParameterAssignment.
func (fprpa FloatPipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &fprpa, true
}

// FloatRangeScriptParameterRule script Parameter float range validation rule definition
type FloatRangeScriptParameterRule struct {
	// MaximumValue - Defines maximum value for the parameter
	MaximumValue *float64 `json:"maximumValue,omitempty"`
	// MinimumValue - Defines minimum value for the parameter
	MinimumValue *float64 `json:"minimumValue,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) MarshalJSON() ([]byte, error) {
	frspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeFloatRange
	objectMap := make(map[string]interface{})
	if frspr.MaximumValue != nil {
		objectMap["maximumValue"] = frspr.MaximumValue
	}
	if frspr.MinimumValue != nil {
		objectMap["minimumValue"] = frspr.MinimumValue
	}
	if frspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = frspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return &frspr, true
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for FloatRangeScriptParameterRule.
func (frspr FloatRangeScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &frspr, true
}

// FloatScriptParameter script parameter of type float
type FloatScriptParameter struct {
	// DefaultValue - Default parameter value
	DefaultValue *float64 `json:"defaultValue,omitempty"`
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for FloatScriptParameter.
func (fsp FloatScriptParameter) MarshalJSON() ([]byte, error) {
	fsp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeFloat
	objectMap := make(map[string]interface{})
	if fsp.DefaultValue != nil {
		objectMap["defaultValue"] = fsp.DefaultValue
	}
	if fsp.Description != nil {
		objectMap["description"] = fsp.Description
	}
	if fsp.Name != nil {
		objectMap["name"] = fsp.Name
	}
	if fsp.ParameterID != nil {
		objectMap["parameterId"] = fsp.ParameterID
	}
	if fsp.ParameterType != "" {
		objectMap["parameterType"] = fsp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return nil, false
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return nil, false
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return &fsp, true
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return nil, false
}

// AsStringScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return nil, false
}

// AsScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return nil, false
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for FloatScriptParameter.
func (fsp FloatScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &fsp, true
}

// Identity identity of resource
type Identity struct {
	// PrincipalID - READ-ONLY; service principal Id
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; Tenant Id
	TenantID *string `json:"tenantId,omitempty"`
	// Type - Identity Type. Possible values include: 'SystemAssigned'
	Type Type `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// IntegerOptionsSetScriptParameterRule script Parameter Integer Options Set validation rule definition
type IntegerOptionsSetScriptParameterRule struct {
	// Options - Defines a set of value options for the parameter
	Options *[]int32 `json:"options,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) MarshalJSON() ([]byte, error) {
	iosspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeIntegerOptionsSet
	objectMap := make(map[string]interface{})
	if iosspr.Options != nil {
		objectMap["options"] = iosspr.Options
	}
	if iosspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = iosspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return &iosspr, true
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for IntegerOptionsSetScriptParameterRule.
func (iosspr IntegerOptionsSetScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &iosspr, true
}

// IntegerPipelineRunParameterAssignment pipeline run integer parameter assignment
type IntegerPipelineRunParameterAssignment struct {
	// Value - Parameter value
	Value *int32 `json:"value,omitempty"`
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	iprpa.ParameterType = ParameterTypeInteger
	objectMap := make(map[string]interface{})
	if iprpa.Value != nil {
		objectMap["value"] = iprpa.Value
	}
	if iprpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = iprpa.PipelineParameterID
	}
	if iprpa.ParameterType != "" {
		objectMap["parameterType"] = iprpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return &iprpa, true
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for IntegerPipelineRunParameterAssignment.
func (iprpa IntegerPipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &iprpa, true
}

// IntegerRangeScriptParameterRule script Parameter integer range validation rule definition
type IntegerRangeScriptParameterRule struct {
	// MaximumValue - Defines maximum value for the parameter
	MaximumValue *int32 `json:"maximumValue,omitempty"`
	// MinimumValue - Defines minimum value for the parameter
	MinimumValue *int32 `json:"minimumValue,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) MarshalJSON() ([]byte, error) {
	irspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeIntegerRange
	objectMap := make(map[string]interface{})
	if irspr.MaximumValue != nil {
		objectMap["maximumValue"] = irspr.MaximumValue
	}
	if irspr.MinimumValue != nil {
		objectMap["minimumValue"] = irspr.MinimumValue
	}
	if irspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = irspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return &irspr, true
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for IntegerRangeScriptParameterRule.
func (irspr IntegerRangeScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &irspr, true
}

// IntegerScriptParameter script parameter of type integer
type IntegerScriptParameter struct {
	// DefaultValue - Default parameter value
	DefaultValue *int32 `json:"defaultValue,omitempty"`
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for IntegerScriptParameter.
func (isp IntegerScriptParameter) MarshalJSON() ([]byte, error) {
	isp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeInteger
	objectMap := make(map[string]interface{})
	if isp.DefaultValue != nil {
		objectMap["defaultValue"] = isp.DefaultValue
	}
	if isp.Description != nil {
		objectMap["description"] = isp.Description
	}
	if isp.Name != nil {
		objectMap["name"] = isp.Name
	}
	if isp.ParameterID != nil {
		objectMap["parameterId"] = isp.ParameterID
	}
	if isp.ParameterType != "" {
		objectMap["parameterType"] = isp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return nil, false
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return nil, false
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return nil, false
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return &isp, true
}

// AsStringScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return nil, false
}

// AsScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return nil, false
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for IntegerScriptParameter.
func (isp IntegerScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &isp, true
}

// Invitation invitation to participate in a shared proposal
type Invitation struct {
	autorest.Response `json:"-"`
	// InvitationProperties - Properties on the Invitation
	*InvitationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Invitation.
func (i Invitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.InvitationProperties != nil {
		objectMap["properties"] = i.InvitationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Invitation struct.
func (i *Invitation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var invitationProperties InvitationProperties
				err = json.Unmarshal(*v, &invitationProperties)
				if err != nil {
					return err
				}
				i.InvitationProperties = &invitationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				i.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		}
	}

	return nil
}

// InvitationList list response for get InvitationList
type InvitationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Invitation `json:"value,omitempty"`
}

// InvitationListIterator provides access to a complete listing of Invitation values.
type InvitationListIterator struct {
	i    int
	page InvitationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InvitationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvitationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InvitationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InvitationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InvitationListIterator) Response() InvitationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InvitationListIterator) Value() Invitation {
	if !iter.page.NotDone() {
		return Invitation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InvitationListIterator type.
func NewInvitationListIterator(page InvitationListPage) InvitationListIterator {
	return InvitationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (il InvitationList) IsEmpty() bool {
	return il.Value == nil || len(*il.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (il InvitationList) hasNextLink() bool {
	return il.NextLink != nil && len(*il.NextLink) != 0
}

// invitationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (il InvitationList) invitationListPreparer(ctx context.Context) (*http.Request, error) {
	if !il.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(il.NextLink)))
}

// InvitationListPage contains a page of Invitation values.
type InvitationListPage struct {
	fn func(context.Context, InvitationList) (InvitationList, error)
	il InvitationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InvitationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvitationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.il)
		if err != nil {
			return err
		}
		page.il = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InvitationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InvitationListPage) NotDone() bool {
	return !page.il.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InvitationListPage) Response() InvitationList {
	return page.il
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InvitationListPage) Values() []Invitation {
	if page.il.IsEmpty() {
		return nil
	}
	return *page.il.Value
}

// Creates a new instance of the InvitationListPage type.
func NewInvitationListPage(cur InvitationList, getNextPage func(context.Context, InvitationList) (InvitationList, error)) InvitationListPage {
	return InvitationListPage{
		fn: getNextPage,
		il: cur,
	}
}

// InvitationProperties invitation property bag.
type InvitationProperties struct {
	// InvitationID - READ-ONLY; unique invitation id
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationStatus - READ-ONLY; The status of the invitation. Possible values include: 'Pending', 'Rejected', 'Accepted'
	InvitationStatus InvitationStatus `json:"invitationStatus,omitempty"`
	// ParticipantPlaceholderID - The participant placeholder Id which this invitation is meant to assign
	ParticipantPlaceholderID *string `json:"participantPlaceholderId,omitempty"`
	// RespondedAt - READ-ONLY; The time the recipient responded to the invitation.
	RespondedAt *date.Time `json:"respondedAt,omitempty"`
	// SentAt - READ-ONLY; Gets the time at which the invitation was sent.
	SentAt *date.Time `json:"sentAt,omitempty"`
	// TargetActiveDirectoryID - The target Azure AD Id. Can't be combined with email.
	TargetActiveDirectoryID *string `json:"targetActiveDirectoryId,omitempty"`
	// TargetEmail - The email the invitation is directed to.
	TargetEmail *string `json:"targetEmail,omitempty"`
	// TargetObjectID - The target user or application Id that invitation is being sent to.
	// Must be specified along TargetActiveDirectoryId. This enables sending
	// invitations to specific users or applications in an AD tenant.
	TargetObjectID *string `json:"targetObjectId,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON is the custom marshaler for InvitationProperties.
func (IP InvitationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if IP.ParticipantPlaceholderID != nil {
		objectMap["participantPlaceholderId"] = IP.ParticipantPlaceholderID
	}
	if IP.TargetActiveDirectoryID != nil {
		objectMap["targetActiveDirectoryId"] = IP.TargetActiveDirectoryID
	}
	if IP.TargetEmail != nil {
		objectMap["targetEmail"] = IP.TargetEmail
	}
	if IP.TargetObjectID != nil {
		objectMap["targetObjectId"] = IP.TargetObjectID
	}
	return json.Marshal(objectMap)
}

// LocationConstraint constraint used to only allow access if the resource is used within the specified
// Azure location.
type LocationConstraint struct {
	// LocationConstraintProperties - Properties for location constraint
	*LocationConstraintProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript', 'KindScriptParameter'
	Kind KindBasicConstraint `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LocationConstraint.
func (lc LocationConstraint) MarshalJSON() ([]byte, error) {
	lc.Kind = KindLocation
	objectMap := make(map[string]interface{})
	if lc.LocationConstraintProperties != nil {
		objectMap["properties"] = lc.LocationConstraintProperties
	}
	if lc.Kind != "" {
		objectMap["kind"] = lc.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return &lc, true
}

// AsScriptConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return nil, false
}

// AsScriptParameterConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsScriptParameterConstraint() (*ScriptParameterConstraint, bool) {
	return nil, false
}

// AsConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsConstraint() (*Constraint, bool) {
	return nil, false
}

// AsBasicConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &lc, true
}

// UnmarshalJSON is the custom unmarshaler for LocationConstraint struct.
func (lc *LocationConstraint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var locationConstraintProperties LocationConstraintProperties
				err = json.Unmarshal(*v, &locationConstraintProperties)
				if err != nil {
					return err
				}
				lc.LocationConstraintProperties = &locationConstraintProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicConstraint
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				lc.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lc.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				lc.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lc.Type = &typeVar
			}
		}
	}

	return nil
}

// LocationConstraintProperties properties for location constraint used to only allow access if the
// resource is used within the specified Azure location.
type LocationConstraintProperties struct {
	// Description - Description of the constraint.
	Description *string `json:"description,omitempty"`
	// Location - Location of the Azure resource (e.g. West US 2)
	Location *string `json:"location,omitempty"`
}

// ManagedPrivateEndpoint private endpoint on the service managed virtual network
type ManagedPrivateEndpoint struct {
	autorest.Response `json:"-"`
	// ManagedPrivateEndpointProperties - Properties on the ManagedPrivateEndpoint
	*ManagedPrivateEndpointProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedPrivateEndpoint.
func (mpe ManagedPrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mpe.ManagedPrivateEndpointProperties != nil {
		objectMap["properties"] = mpe.ManagedPrivateEndpointProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ManagedPrivateEndpoint struct.
func (mpe *ManagedPrivateEndpoint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var managedPrivateEndpointProperties ManagedPrivateEndpointProperties
				err = json.Unmarshal(*v, &managedPrivateEndpointProperties)
				if err != nil {
					return err
				}
				mpe.ManagedPrivateEndpointProperties = &managedPrivateEndpointProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mpe.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mpe.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				mpe.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mpe.Type = &typeVar
			}
		}
	}

	return nil
}

// ManagedPrivateEndpointList list response for get ManagedPrivateEndpointList
type ManagedPrivateEndpointList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]ManagedPrivateEndpoint `json:"value,omitempty"`
}

// ManagedPrivateEndpointListIterator provides access to a complete listing of ManagedPrivateEndpoint
// values.
type ManagedPrivateEndpointListIterator struct {
	i    int
	page ManagedPrivateEndpointListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ManagedPrivateEndpointListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagedPrivateEndpointListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ManagedPrivateEndpointListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ManagedPrivateEndpointListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ManagedPrivateEndpointListIterator) Response() ManagedPrivateEndpointList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ManagedPrivateEndpointListIterator) Value() ManagedPrivateEndpoint {
	if !iter.page.NotDone() {
		return ManagedPrivateEndpoint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ManagedPrivateEndpointListIterator type.
func NewManagedPrivateEndpointListIterator(page ManagedPrivateEndpointListPage) ManagedPrivateEndpointListIterator {
	return ManagedPrivateEndpointListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mpel ManagedPrivateEndpointList) IsEmpty() bool {
	return mpel.Value == nil || len(*mpel.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mpel ManagedPrivateEndpointList) hasNextLink() bool {
	return mpel.NextLink != nil && len(*mpel.NextLink) != 0
}

// managedPrivateEndpointListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mpel ManagedPrivateEndpointList) managedPrivateEndpointListPreparer(ctx context.Context) (*http.Request, error) {
	if !mpel.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mpel.NextLink)))
}

// ManagedPrivateEndpointListPage contains a page of ManagedPrivateEndpoint values.
type ManagedPrivateEndpointListPage struct {
	fn   func(context.Context, ManagedPrivateEndpointList) (ManagedPrivateEndpointList, error)
	mpel ManagedPrivateEndpointList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ManagedPrivateEndpointListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagedPrivateEndpointListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mpel)
		if err != nil {
			return err
		}
		page.mpel = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ManagedPrivateEndpointListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ManagedPrivateEndpointListPage) NotDone() bool {
	return !page.mpel.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ManagedPrivateEndpointListPage) Response() ManagedPrivateEndpointList {
	return page.mpel
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ManagedPrivateEndpointListPage) Values() []ManagedPrivateEndpoint {
	if page.mpel.IsEmpty() {
		return nil
	}
	return *page.mpel.Value
}

// Creates a new instance of the ManagedPrivateEndpointListPage type.
func NewManagedPrivateEndpointListPage(cur ManagedPrivateEndpointList, getNextPage func(context.Context, ManagedPrivateEndpointList) (ManagedPrivateEndpointList, error)) ManagedPrivateEndpointListPage {
	return ManagedPrivateEndpointListPage{
		fn:   getNextPage,
		mpel: cur,
	}
}

// ManagedPrivateEndpointProperties properties of Managed Private Endpoint data transfer object.
type ManagedPrivateEndpointProperties struct {
	// AdditionalProperties - READ-ONLY; Additional endpoint properties
	AdditionalProperties map[string]interface{} `json:"additionalProperties"`
	// ConnectionState - READ-ONLY; Connection state of the Managed Private Endpoint
	ConnectionState *ManagedPrivateEndpointPropertiesConnectionState `json:"connectionState,omitempty"`
	// GroupID - The type of endpoint on the linked resource. Possible values include: 'Blob', 'BlobSecondary', 'Dfs', 'DfsSecondary'
	GroupID GroupID `json:"groupId,omitempty"`
	// PrivateLinkResourceID - The Azure id of the linked resource
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the Managed Private Endpoint. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedPrivateEndpointProperties.
func (mpep ManagedPrivateEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mpep.GroupID != "" {
		objectMap["groupId"] = mpep.GroupID
	}
	if mpep.PrivateLinkResourceID != nil {
		objectMap["privateLinkResourceId"] = mpep.PrivateLinkResourceID
	}
	return json.Marshal(objectMap)
}

// ManagedPrivateEndpointPropertiesConnectionState connection state of the Managed Private Endpoint
type ManagedPrivateEndpointPropertiesConnectionState struct {
	// ActionsRequired - READ-ONLY; The actions required on the managed private endpoint
	ActionsRequired *string `json:"actionsRequired,omitempty"`
	// Description - READ-ONLY; The managed private endpoint description
	Description *string `json:"description,omitempty"`
	// PrivateEndpointStatus - READ-ONLY; The approval status. Possible values include: 'PrivateEndpointStatusPending', 'PrivateEndpointStatusApproved', 'PrivateEndpointStatusRejected', 'PrivateEndpointStatusDisconnected'
	PrivateEndpointStatus PrivateEndpointStatus `json:"privateEndpointStatus,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedPrivateEndpointPropertiesConnectionState.
func (mpepS ManagedPrivateEndpointPropertiesConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ManagedPrivateEndpointsCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ManagedPrivateEndpointsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ManagedPrivateEndpointsClient) (ManagedPrivateEndpoint, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ManagedPrivateEndpointsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ManagedPrivateEndpointsCreateFuture.Result.
func (future *ManagedPrivateEndpointsCreateFuture) result(client ManagedPrivateEndpointsClient) (mpe ManagedPrivateEndpoint, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ManagedPrivateEndpointsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mpe.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ManagedPrivateEndpointsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mpe.Response.Response, err = future.GetResult(sender); err == nil && mpe.Response.Response.StatusCode != http.StatusNoContent {
		mpe, err = client.CreateResponder(mpe.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ManagedPrivateEndpointsCreateFuture", "Result", mpe.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ManagedPrivateEndpointsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ManagedPrivateEndpointsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ManagedPrivateEndpointsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ManagedPrivateEndpointsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ManagedPrivateEndpointsDeleteFuture.Result.
func (future *ManagedPrivateEndpointsDeleteFuture) result(client ManagedPrivateEndpointsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ManagedPrivateEndpointsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ManagedPrivateEndpointsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ManagedPrivateEndpointsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OperationList list response for get operations.
type OperationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]OperationModel `json:"value,omitempty"`
}

// OperationListIterator provides access to a complete listing of OperationModel values.
type OperationListIterator struct {
	i    int
	page OperationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListIterator) Response() OperationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListIterator) Value() OperationModel {
	if !iter.page.NotDone() {
		return OperationModel{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListIterator type.
func NewOperationListIterator(page OperationListPage) OperationListIterator {
	return OperationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationList) operationListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationListPage contains a page of OperationModel values.
type OperationListPage struct {
	fn func(context.Context, OperationList) (OperationList, error)
	ol OperationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListPage) Response() OperationList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListPage) Values() []OperationModel {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationListPage type.
func NewOperationListPage(cur OperationList, getNextPage func(context.Context, OperationList) (OperationList, error)) OperationListPage {
	return OperationListPage{
		fn: getNextPage,
		ol: cur,
	}
}

// OperationMetaLogSpecification log specifications for operation api
type OperationMetaLogSpecification struct {
	// BlobDuration - blob duration of the log
	BlobDuration *string `json:"blobDuration,omitempty"`
	// DisplayName - localized name of the log category
	DisplayName *string `json:"displayName,omitempty"`
	// Name - name of the log category
	Name *string `json:"name,omitempty"`
}

// OperationMetaMetricSpecification metric specifications for the operation
type OperationMetaMetricSpecification struct {
	// AggregationType - aggregation type of metric
	AggregationType *string `json:"aggregationType,omitempty"`
	// Dimensions - properties for dimension
	Dimensions *[]DimensionProperties `json:"dimensions,omitempty"`
	// DisplayDescription - description of the metric
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// DisplayName - localized name of the metric
	DisplayName *string `json:"displayName,omitempty"`
	// EnableRegionalMdmAccount - enable regional mdm account
	EnableRegionalMdmAccount *string `json:"enableRegionalMdmAccount,omitempty"`
	// FillGapWithZero - fill gap with zero
	FillGapWithZero *string `json:"fillGapWithZero,omitempty"`
	// InternalMetricName - internal metric name
	InternalMetricName *string `json:"internalMetricName,omitempty"`
	// Name - name of the metric
	Name *string `json:"name,omitempty"`
	// ResourceIDDimensionNameOverride - dimension name use to replace resource id if specified
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`
	// SupportedAggregationTypes - supported aggregation types
	SupportedAggregationTypes *[]string `json:"supportedAggregationTypes,omitempty"`
	// SupportedTimeGrainTypes - supported time grain types
	SupportedTimeGrainTypes *[]string `json:"supportedTimeGrainTypes,omitempty"`
	// Unit - units for the metric
	Unit *string `json:"unit,omitempty"`
}

// OperationMetaPropertyInfo properties on meta info
type OperationMetaPropertyInfo struct {
	// ServiceSpecification - meta service specification
	ServiceSpecification *OperationMetaServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationMetaServiceSpecification the operation meta service specification
type OperationMetaServiceSpecification struct {
	// LogSpecifications - log specifications for the operation
	LogSpecifications *[]OperationMetaLogSpecification `json:"logSpecifications,omitempty"`
	// MetricSpecifications - metric specifications for the operation
	MetricSpecifications *[]OperationMetaMetricSpecification `json:"metricSpecifications,omitempty"`
}

// OperationModel the response model for get operations
type OperationModel struct {
	// Display - Properties on the operation
	Display *OperationModelProperties `json:"display,omitempty"`
	// IsDataAction - Determines whether an operation is done on the data-layer or not
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Name - Operation name for display purposes
	Name *string `json:"name,omitempty"`
	// Origin - origin of the operation
	Origin *string `json:"origin,omitempty"`
	// OperationMetaPropertyInfo - properties for the operation meta info
	*OperationMetaPropertyInfo `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationModel.
func (om OperationModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if om.Display != nil {
		objectMap["display"] = om.Display
	}
	if om.IsDataAction != nil {
		objectMap["isDataAction"] = om.IsDataAction
	}
	if om.Name != nil {
		objectMap["name"] = om.Name
	}
	if om.Origin != nil {
		objectMap["origin"] = om.Origin
	}
	if om.OperationMetaPropertyInfo != nil {
		objectMap["properties"] = om.OperationMetaPropertyInfo
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OperationModel struct.
func (om *OperationModel) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "display":
			if v != nil {
				var display OperationModelProperties
				err = json.Unmarshal(*v, &display)
				if err != nil {
					return err
				}
				om.Display = &display
			}
		case "isDataAction":
			if v != nil {
				var isDataAction bool
				err = json.Unmarshal(*v, &isDataAction)
				if err != nil {
					return err
				}
				om.IsDataAction = &isDataAction
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				om.Name = &name
			}
		case "origin":
			if v != nil {
				var origin string
				err = json.Unmarshal(*v, &origin)
				if err != nil {
					return err
				}
				om.Origin = &origin
			}
		case "properties":
			if v != nil {
				var operationMetaPropertyInfo OperationMetaPropertyInfo
				err = json.Unmarshal(*v, &operationMetaPropertyInfo)
				if err != nil {
					return err
				}
				om.OperationMetaPropertyInfo = &operationMetaPropertyInfo
			}
		}
	}

	return nil
}

// OperationModelProperties properties on operations
type OperationModelProperties struct {
	// Description - Description of the operation for display purposes
	Description *string `json:"description,omitempty"`
	// Operation - Name of the operation for display purposes
	Operation *string `json:"operation,omitempty"`
	// Provider - Name of the provider for display purposes
	Provider *string `json:"provider,omitempty"`
	// Resource - Name of the resource type for display purposes
	Resource *string `json:"resource,omitempty"`
}

// OperationResponse response for long running operation
type OperationResponse struct {
	autorest.Response `json:"-"`
	// EndTime - start time
	EndTime *date.Time `json:"endTime,omitempty"`
	// Error - The error property when status is failed.
	Error *ErrorInfo `json:"error,omitempty"`
	// StartTime - start time
	StartTime *date.Time `json:"startTime,omitempty"`
	// Status - Operation state of the long running operation. Possible values include: 'StatusAccepted', 'StatusInProgress', 'StatusTransientFailure', 'StatusSucceeded', 'StatusFailed', 'StatusCanceled'
	Status Status `json:"status,omitempty"`
}

// OutputPolicy a Output policy.
type OutputPolicy struct {
	// OutputPolicyProperties - Properties for Output policy
	*OutputPolicyProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindPolicy', 'KindDiagnosticLevel', 'KindOutput'
	Kind KindBasicPolicy `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for OutputPolicy.
func (op OutputPolicy) MarshalJSON() ([]byte, error) {
	op.Kind = KindOutput
	objectMap := make(map[string]interface{})
	if op.OutputPolicyProperties != nil {
		objectMap["properties"] = op.OutputPolicyProperties
	}
	if op.Kind != "" {
		objectMap["kind"] = op.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticPolicy is the BasicPolicy implementation for OutputPolicy.
func (op OutputPolicy) AsDiagnosticPolicy() (*DiagnosticPolicy, bool) {
	return nil, false
}

// AsOutputPolicy is the BasicPolicy implementation for OutputPolicy.
func (op OutputPolicy) AsOutputPolicy() (*OutputPolicy, bool) {
	return &op, true
}

// AsPolicy is the BasicPolicy implementation for OutputPolicy.
func (op OutputPolicy) AsPolicy() (*Policy, bool) {
	return nil, false
}

// AsBasicPolicy is the BasicPolicy implementation for OutputPolicy.
func (op OutputPolicy) AsBasicPolicy() (BasicPolicy, bool) {
	return &op, true
}

// UnmarshalJSON is the custom unmarshaler for OutputPolicy struct.
func (op *OutputPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var outputPolicyProperties OutputPolicyProperties
				err = json.Unmarshal(*v, &outputPolicyProperties)
				if err != nil {
					return err
				}
				op.OutputPolicyProperties = &outputPolicyProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicPolicy
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				op.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				op.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				op.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				op.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				op.Type = &typeVar
			}
		}
	}

	return nil
}

// OutputPolicyProperties an Output policy transfer object.
type OutputPolicyProperties struct {
	// AppliesTo - The name of the sink this policy applies to. If not present the policy applies to all sinks.
	AppliesTo *string `json:"appliesTo,omitempty"`
	// Description - Description of the policy
	Description *string `json:"description,omitempty"`
	// OutputName - The name of the virtual reference representing this policy.
	OutputName *string `json:"outputName,omitempty"`
}

// Participant participant information
type Participant struct {
	autorest.Response `json:"-"`
	// ParticipantProperties - Properties on the participant
	*ParticipantProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Participant.
func (p Participant) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ParticipantProperties != nil {
		objectMap["properties"] = p.ParticipantProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Participant struct.
func (p *Participant) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var participantProperties ParticipantProperties
				err = json.Unmarshal(*v, &participantProperties)
				if err != nil {
					return err
				}
				p.ParticipantProperties = &participantProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				p.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ParticipantDetails a participant details
type ParticipantDetails struct {
	// TenantName - READ-ONLY; Tenant name of the participant
	TenantName *string `json:"tenantName,omitempty"`
	// WorkspaceDisplayName - READ-ONLY; Display name of the workspace
	WorkspaceDisplayName *string `json:"workspaceDisplayName,omitempty"`
}

// MarshalJSON is the custom marshaler for ParticipantDetails.
func (pd ParticipantDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ParticipantList list response for get participants.
type ParticipantList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Participant `json:"value,omitempty"`
}

// ParticipantListIterator provides access to a complete listing of Participant values.
type ParticipantListIterator struct {
	i    int
	page ParticipantListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ParticipantListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ParticipantListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ParticipantListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ParticipantListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ParticipantListIterator) Response() ParticipantList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ParticipantListIterator) Value() Participant {
	if !iter.page.NotDone() {
		return Participant{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ParticipantListIterator type.
func NewParticipantListIterator(page ParticipantListPage) ParticipantListIterator {
	return ParticipantListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl ParticipantList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl ParticipantList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// participantListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl ParticipantList) participantListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// ParticipantListPage contains a page of Participant values.
type ParticipantListPage struct {
	fn func(context.Context, ParticipantList) (ParticipantList, error)
	pl ParticipantList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ParticipantListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ParticipantListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ParticipantListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ParticipantListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ParticipantListPage) Response() ParticipantList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ParticipantListPage) Values() []Participant {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the ParticipantListPage type.
func NewParticipantListPage(cur ParticipantList, getNextPage func(context.Context, ParticipantList) (ParticipantList, error)) ParticipantListPage {
	return ParticipantListPage{
		fn: getNextPage,
		pl: cur,
	}
}

// ParticipantPlaceholderInfo placeholder information for participant
type ParticipantPlaceholderInfo struct {
	// Description - Description of the placeholder.
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name of the placeholder.
	DisplayName *string `json:"displayName,omitempty"`
}

// ParticipantProperties participant property bag.
type ParticipantProperties struct {
	// CreatedAt - READ-ONLY; Time at which the account was created.
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// DisplayName - READ-ONLY; Participant display name
	DisplayName *string `json:"displayName,omitempty"`
	// ParticipantID - READ-ONLY; Unique id for identifying a participant
	ParticipantID *string `json:"participantId,omitempty"`
	// PlaceholderInfo - The placeholder information
	PlaceholderInfo *ParticipantPlaceholderInfo `json:"placeholderInfo,omitempty"`
	// PlaceholderState - READ-ONLY; The placeholder state. Possible values include: 'PlaceholderStateNone', 'PlaceholderStateUnassigned', 'PlaceholderStateAssigned'
	PlaceholderState PlaceholderState `json:"placeholderState,omitempty"`
	// ProposalApprovalStatus - READ-ONLY; Current approval status. Possible values include: 'ProposalApprovalStatusPending', 'ProposalApprovalStatusApproved', 'ProposalApprovalStatusExpired'
	ProposalApprovalStatus ProposalApprovalStatus `json:"proposalApprovalStatus,omitempty"`
	// TenantName - READ-ONLY; Tenant name of the participant
	TenantName *string `json:"tenantName,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
	// WorkspaceDisplayName - READ-ONLY; Display name of the workspace
	WorkspaceDisplayName *string `json:"workspaceDisplayName,omitempty"`
}

// MarshalJSON is the custom marshaler for ParticipantProperties.
func (pp ParticipantProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.PlaceholderInfo != nil {
		objectMap["placeholderInfo"] = pp.PlaceholderInfo
	}
	return json.Marshal(objectMap)
}

// ParticipantsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ParticipantsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ParticipantsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ParticipantsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ParticipantsDeleteFuture.Result.
func (future *ParticipantsDeleteFuture) result(client ParticipantsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ParticipantsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ParticipantsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ParticipantsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Pipeline a pipeline data transfer object.
type Pipeline struct {
	autorest.Response `json:"-"`
	// PipelineProperties - Properties on the pipeline
	*PipelineProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Pipeline.
func (p Pipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PipelineProperties != nil {
		objectMap["properties"] = p.PipelineProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Pipeline struct.
func (p *Pipeline) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineProperties PipelineProperties
				err = json.Unmarshal(*v, &pipelineProperties)
				if err != nil {
					return err
				}
				p.PipelineProperties = &pipelineProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				p.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineList list response for get Pipelines
type PipelineList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Pipeline `json:"value,omitempty"`
}

// PipelineListIterator provides access to a complete listing of Pipeline values.
type PipelineListIterator struct {
	i    int
	page PipelineListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineListIterator) Response() PipelineList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineListIterator) Value() Pipeline {
	if !iter.page.NotDone() {
		return Pipeline{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineListIterator type.
func NewPipelineListIterator(page PipelineListPage) PipelineListIterator {
	return PipelineListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl PipelineList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl PipelineList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// pipelineListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl PipelineList) pipelineListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// PipelineListPage contains a page of Pipeline values.
type PipelineListPage struct {
	fn func(context.Context, PipelineList) (PipelineList, error)
	pl PipelineList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineListPage) Response() PipelineList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineListPage) Values() []Pipeline {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the PipelineListPage type.
func NewPipelineListPage(cur PipelineList, getNextPage func(context.Context, PipelineList) (PipelineList, error)) PipelineListPage {
	return PipelineListPage{
		fn: getNextPage,
		pl: cur,
	}
}

// PipelineProperties pipeline property bag.
type PipelineProperties struct {
	// Description - General Description of the pipeline content
	Description *string `json:"description,omitempty"`
	// PipelineID - READ-ONLY; Unique id for identifying a pipeline resource
	PipelineID *string `json:"pipelineId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the pipeline. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ScriptParameters - List of pipeline level script parameters
	ScriptParameters *[]BasicScriptParameter `json:"scriptParameters,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineProperties.
func (pp PipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Description != nil {
		objectMap["description"] = pp.Description
	}
	if pp.ScriptParameters != nil {
		objectMap["scriptParameters"] = pp.ScriptParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineProperties struct.
func (pp *PipelineProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				pp.Description = &description
			}
		case "pipelineId":
			if v != nil {
				var pipelineID string
				err = json.Unmarshal(*v, &pipelineID)
				if err != nil {
					return err
				}
				pp.PipelineID = &pipelineID
			}
		case "provisioningState":
			if v != nil {
				var provisioningState ProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				pp.ProvisioningState = provisioningState
			}
		case "scriptParameters":
			if v != nil {
				scriptParameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				pp.ScriptParameters = &scriptParameters
			}
		}
	}

	return nil
}

// PipelineRun a pipeline run data transfer object.
type PipelineRun struct {
	autorest.Response `json:"-"`
	// PipelineRunProperties - Properties on the pipeline
	*PipelineRunProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineRun.
func (pr PipelineRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.PipelineRunProperties != nil {
		objectMap["properties"] = pr.PipelineRunProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineRun struct.
func (pr *PipelineRun) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineRunProperties PipelineRunProperties
				err = json.Unmarshal(*v, &pipelineRunProperties)
				if err != nil {
					return err
				}
				pr.PipelineRunProperties = &pipelineRunProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pr.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pr.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pr.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineRunList list response for get pipeline run.
type PipelineRunList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]PipelineRun `json:"value,omitempty"`
}

// PipelineRunListIterator provides access to a complete listing of PipelineRun values.
type PipelineRunListIterator struct {
	i    int
	page PipelineRunListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineRunListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineRunListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineRunListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineRunListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineRunListIterator) Response() PipelineRunList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineRunListIterator) Value() PipelineRun {
	if !iter.page.NotDone() {
		return PipelineRun{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineRunListIterator type.
func NewPipelineRunListIterator(page PipelineRunListPage) PipelineRunListIterator {
	return PipelineRunListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (prl PipelineRunList) IsEmpty() bool {
	return prl.Value == nil || len(*prl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (prl PipelineRunList) hasNextLink() bool {
	return prl.NextLink != nil && len(*prl.NextLink) != 0
}

// pipelineRunListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (prl PipelineRunList) pipelineRunListPreparer(ctx context.Context) (*http.Request, error) {
	if !prl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(prl.NextLink)))
}

// PipelineRunListPage contains a page of PipelineRun values.
type PipelineRunListPage struct {
	fn  func(context.Context, PipelineRunList) (PipelineRunList, error)
	prl PipelineRunList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineRunListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineRunListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.prl)
		if err != nil {
			return err
		}
		page.prl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineRunListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineRunListPage) NotDone() bool {
	return !page.prl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineRunListPage) Response() PipelineRunList {
	return page.prl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineRunListPage) Values() []PipelineRun {
	if page.prl.IsEmpty() {
		return nil
	}
	return *page.prl.Value
}

// Creates a new instance of the PipelineRunListPage type.
func NewPipelineRunListPage(cur PipelineRunList, getNextPage func(context.Context, PipelineRunList) (PipelineRunList, error)) PipelineRunListPage {
	return PipelineRunListPage{
		fn:  getNextPage,
		prl: cur,
	}
}

// BasicPipelineRunParameterAssignment pipeline run parameter assignment
type BasicPipelineRunParameterAssignment interface {
	AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool)
	AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool)
	AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool)
	AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool)
	AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool)
	AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool)
}

// PipelineRunParameterAssignment pipeline run parameter assignment
type PipelineRunParameterAssignment struct {
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

func unmarshalBasicPipelineRunParameterAssignment(body []byte) (BasicPipelineRunParameterAssignment, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["parameterType"] {
	case string(ParameterTypeBoolean):
		var bprpa BooleanPipelineRunParameterAssignment
		err := json.Unmarshal(body, &bprpa)
		return bprpa, err
	case string(ParameterTypeDateTime):
		var dtprpa DateTimePipelineRunParameterAssignment
		err := json.Unmarshal(body, &dtprpa)
		return dtprpa, err
	case string(ParameterTypeFloat):
		var fprpa FloatPipelineRunParameterAssignment
		err := json.Unmarshal(body, &fprpa)
		return fprpa, err
	case string(ParameterTypeInteger):
		var iprpa IntegerPipelineRunParameterAssignment
		err := json.Unmarshal(body, &iprpa)
		return iprpa, err
	case string(ParameterTypeString):
		var sprpa StringPipelineRunParameterAssignment
		err := json.Unmarshal(body, &sprpa)
		return sprpa, err
	default:
		var prpa PipelineRunParameterAssignment
		err := json.Unmarshal(body, &prpa)
		return prpa, err
	}
}
func unmarshalBasicPipelineRunParameterAssignmentArray(body []byte) ([]BasicPipelineRunParameterAssignment, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	prpaArray := make([]BasicPipelineRunParameterAssignment, len(rawMessages))

	for index, rawMessage := range rawMessages {
		prpa, err := unmarshalBasicPipelineRunParameterAssignment(*rawMessage)
		if err != nil {
			return nil, err
		}
		prpaArray[index] = prpa
	}
	return prpaArray, nil
}

// MarshalJSON is the custom marshaler for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	prpa.ParameterType = ParameterTypePipelineRunParameterAssignment
	objectMap := make(map[string]interface{})
	if prpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = prpa.PipelineParameterID
	}
	if prpa.ParameterType != "" {
		objectMap["parameterType"] = prpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return &prpa, true
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for PipelineRunParameterAssignment.
func (prpa PipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &prpa, true
}

// PipelineRunParameters the parameters for a pipeline run.
type PipelineRunParameters struct {
	// PipelineRunMode - Mode of pipeline run used. Possible values include: 'PipelineRunModeProduction', 'PipelineRunModeTest'
	PipelineRunMode PipelineRunMode `json:"pipelineRunMode,omitempty"`
	// PipelineRunParameterAssignments - Pipeline run parameters assignments
	PipelineRunParameterAssignments *[]BasicPipelineRunParameterAssignment `json:"pipelineRunParameterAssignments,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PipelineRunParameters struct.
func (prp *PipelineRunParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "pipelineRunMode":
			if v != nil {
				var pipelineRunMode PipelineRunMode
				err = json.Unmarshal(*v, &pipelineRunMode)
				if err != nil {
					return err
				}
				prp.PipelineRunMode = pipelineRunMode
			}
		case "pipelineRunParameterAssignments":
			if v != nil {
				pipelineRunParameterAssignments, err := unmarshalBasicPipelineRunParameterAssignmentArray(*v)
				if err != nil {
					return err
				}
				prp.PipelineRunParameterAssignments = &pipelineRunParameterAssignments
			}
		}
	}

	return nil
}

// PipelineRunProperties a pipeline run property bag.
type PipelineRunProperties struct {
	// DurationMs - READ-ONLY; Pipeline run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of pipeline run
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// PipelineID - READ-ONLY; Object id of the pipeline used to create this run
	PipelineID *string `json:"pipelineId,omitempty"`
	// PipelineName - READ-ONLY; Name of the pipeline used to create this run
	PipelineName *string `json:"pipelineName,omitempty"`
	// PipelineRunMode - READ-ONLY; Indicate the pipeline execution mode. Production or Test. Possible values include: 'PipelineRunModeProduction', 'PipelineRunModeTest'
	PipelineRunMode PipelineRunMode `json:"pipelineRunMode,omitempty"`
	// PipelineRunStatus - READ-ONLY; Pipeline run status. Possible values include: 'PipelineRunStatusSucceeded', 'PipelineRunStatusFailed', 'PipelineRunStatusInProgress', 'PipelineRunStatusPreparing', 'PipelineRunStatusQueued', 'PipelineRunStatusUnknown', 'PipelineRunStatusCancelled', 'PipelineRunStatusCanceling', 'PipelineRunStatusWaiting', 'PipelineRunStatusIncomplete'
	PipelineRunStatus PipelineRunStatus `json:"pipelineRunStatus,omitempty"`
	// StartTime - READ-ONLY; Start time of pipeline run
	StartTime *date.Time `json:"startTime,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineRunProperties.
func (prp PipelineRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PipelineRunsCancelFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelineRunsCancelFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelineRunsClient) (PipelineRun, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelineRunsCancelFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelineRunsCancelFuture.Result.
func (future *PipelineRunsCancelFuture) result(client PipelineRunsClient) (pr PipelineRun, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelineRunsCancelFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelineRunsCancelFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.CancelResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelineRunsCancelFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelinesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesDeleteFuture.Result.
func (future *PipelinesDeleteFuture) result(client PipelinesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelinesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesRunFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type PipelinesRunFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelinesClient) (PipelineRun, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelinesRunFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelinesRunFuture.Result.
func (future *PipelinesRunFuture) result(client PipelinesClient) (pr PipelineRun, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesRunFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelinesRunFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.RunResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesRunFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicPipelineStep a single step of a pipeline.
type BasicPipelineStep interface {
	AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool)
	AsPipelineStep() (*PipelineStep, bool)
}

// PipelineStep a single step of a pipeline.
type PipelineStep struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindPipelineStep', 'KindSynapseSpark'
	Kind KindBasicPipelineStep `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicPipelineStep(body []byte) (BasicPipelineStep, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindSynapseSpark):
		var ssps SynapseSparkPipelineStep
		err := json.Unmarshal(body, &ssps)
		return ssps, err
	default:
		var ps PipelineStep
		err := json.Unmarshal(body, &ps)
		return ps, err
	}
}
func unmarshalBasicPipelineStepArray(body []byte) ([]BasicPipelineStep, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	psArray := make([]BasicPipelineStep, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ps, err := unmarshalBasicPipelineStep(*rawMessage)
		if err != nil {
			return nil, err
		}
		psArray[index] = ps
	}
	return psArray, nil
}

// MarshalJSON is the custom marshaler for PipelineStep.
func (ps PipelineStep) MarshalJSON() ([]byte, error) {
	ps.Kind = KindPipelineStep
	objectMap := make(map[string]interface{})
	if ps.Kind != "" {
		objectMap["kind"] = ps.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool) {
	return nil, false
}

// AsPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsPipelineStep() (*PipelineStep, bool) {
	return &ps, true
}

// AsBasicPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsBasicPipelineStep() (BasicPipelineStep, bool) {
	return &ps, true
}

// PipelineStepList list response for get Pipeline steps
type PipelineStepList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicPipelineStep `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepList struct.
func (psl *PipelineStepList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				psl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicPipelineStepArray(*v)
				if err != nil {
					return err
				}
				psl.Value = &value
			}
		}
	}

	return nil
}

// PipelineStepListIterator provides access to a complete listing of PipelineStep values.
type PipelineStepListIterator struct {
	i    int
	page PipelineStepListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineStepListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineStepListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineStepListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineStepListIterator) Response() PipelineStepList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineStepListIterator) Value() BasicPipelineStep {
	if !iter.page.NotDone() {
		return PipelineStep{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineStepListIterator type.
func NewPipelineStepListIterator(page PipelineStepListPage) PipelineStepListIterator {
	return PipelineStepListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (psl PipelineStepList) IsEmpty() bool {
	return psl.Value == nil || len(*psl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (psl PipelineStepList) hasNextLink() bool {
	return psl.NextLink != nil && len(*psl.NextLink) != 0
}

// pipelineStepListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (psl PipelineStepList) pipelineStepListPreparer(ctx context.Context) (*http.Request, error) {
	if !psl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(psl.NextLink)))
}

// PipelineStepListPage contains a page of BasicPipelineStep values.
type PipelineStepListPage struct {
	fn  func(context.Context, PipelineStepList) (PipelineStepList, error)
	psl PipelineStepList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineStepListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.psl)
		if err != nil {
			return err
		}
		page.psl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineStepListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineStepListPage) NotDone() bool {
	return !page.psl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineStepListPage) Response() PipelineStepList {
	return page.psl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineStepListPage) Values() []BasicPipelineStep {
	if page.psl.IsEmpty() {
		return nil
	}
	return *page.psl.Value
}

// Creates a new instance of the PipelineStepListPage type.
func NewPipelineStepListPage(cur PipelineStepList, getNextPage func(context.Context, PipelineStepList) (PipelineStepList, error)) PipelineStepListPage {
	return PipelineStepListPage{
		fn:  getNextPage,
		psl: cur,
	}
}

// PipelineStepModel ...
type PipelineStepModel struct {
	autorest.Response `json:"-"`
	Value             BasicPipelineStep `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepModel struct.
func (psm *PipelineStepModel) UnmarshalJSON(body []byte) error {
	ps, err := unmarshalBasicPipelineStep(body)
	if err != nil {
		return err
	}
	psm.Value = ps

	return nil
}

// PipelineStepRun pipeline step run at data set level
type PipelineStepRun struct {
	autorest.Response `json:"-"`
	// PipelineStepRunProperties - Properties on the pipeline step run
	*PipelineStepRunProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineStepRun.
func (psr PipelineStepRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if psr.PipelineStepRunProperties != nil {
		objectMap["properties"] = psr.PipelineStepRunProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepRun struct.
func (psr *PipelineStepRun) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineStepRunProperties PipelineStepRunProperties
				err = json.Unmarshal(*v, &pipelineStepRunProperties)
				if err != nil {
					return err
				}
				psr.PipelineStepRunProperties = &pipelineStepRunProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				psr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				psr.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				psr.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				psr.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineStepRunList details of pipeline run
type PipelineStepRunList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]PipelineStepRun `json:"value,omitempty"`
}

// PipelineStepRunListIterator provides access to a complete listing of PipelineStepRun values.
type PipelineStepRunListIterator struct {
	i    int
	page PipelineStepRunListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineStepRunListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepRunListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineStepRunListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineStepRunListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineStepRunListIterator) Response() PipelineStepRunList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineStepRunListIterator) Value() PipelineStepRun {
	if !iter.page.NotDone() {
		return PipelineStepRun{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineStepRunListIterator type.
func NewPipelineStepRunListIterator(page PipelineStepRunListPage) PipelineStepRunListIterator {
	return PipelineStepRunListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (psrl PipelineStepRunList) IsEmpty() bool {
	return psrl.Value == nil || len(*psrl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (psrl PipelineStepRunList) hasNextLink() bool {
	return psrl.NextLink != nil && len(*psrl.NextLink) != 0
}

// pipelineStepRunListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (psrl PipelineStepRunList) pipelineStepRunListPreparer(ctx context.Context) (*http.Request, error) {
	if !psrl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(psrl.NextLink)))
}

// PipelineStepRunListPage contains a page of PipelineStepRun values.
type PipelineStepRunListPage struct {
	fn   func(context.Context, PipelineStepRunList) (PipelineStepRunList, error)
	psrl PipelineStepRunList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineStepRunListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepRunListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.psrl)
		if err != nil {
			return err
		}
		page.psrl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineStepRunListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineStepRunListPage) NotDone() bool {
	return !page.psrl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineStepRunListPage) Response() PipelineStepRunList {
	return page.psrl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineStepRunListPage) Values() []PipelineStepRun {
	if page.psrl.IsEmpty() {
		return nil
	}
	return *page.psrl.Value
}

// Creates a new instance of the PipelineStepRunListPage type.
func NewPipelineStepRunListPage(cur PipelineStepRunList, getNextPage func(context.Context, PipelineStepRunList) (PipelineStepRunList, error)) PipelineStepRunListPage {
	return PipelineStepRunListPage{
		fn:   getNextPage,
		psrl: cur,
	}
}

// PipelineStepRunProperties pipeline step run property bag.
type PipelineStepRunProperties struct {
	// DurationMs - READ-ONLY; Duration of pipeline step run
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of pipeline step run
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// PipelineStepName - READ-ONLY; The name of the step used for this step run
	PipelineStepName *string `json:"pipelineStepName,omitempty"`
	// PipelineStepRunStatus - READ-ONLY; Pipeline step run status. Possible values include: 'PipelineStepRunStatusSucceeded', 'PipelineStepRunStatusFailed', 'PipelineStepRunStatusInProgress', 'PipelineStepRunStatusPreparing', 'PipelineStepRunStatusQueued', 'PipelineStepRunStatusUnknown', 'PipelineStepRunStatusCancelled', 'PipelineStepRunStatusCanceling', 'PipelineStepRunStatusWaiting', 'PipelineStepRunStatusIncomplete'
	PipelineStepRunStatus PipelineStepRunStatus `json:"pipelineStepRunStatus,omitempty"`
	// PipelineSubsteps - READ-ONLY; List of substeps
	PipelineSubsteps *[]BasicPipelineSubstep `json:"pipelineSubsteps,omitempty"`
	// StartTime - READ-ONLY; Start time of pipeline step run
	StartTime *date.Time `json:"startTime,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineStepRunProperties.
func (psrp PipelineStepRunProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepRunProperties struct.
func (psrp *PipelineStepRunProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "durationMs":
			if v != nil {
				var durationMs int32
				err = json.Unmarshal(*v, &durationMs)
				if err != nil {
					return err
				}
				psrp.DurationMs = &durationMs
			}
		case "endTime":
			if v != nil {
				var endTime date.Time
				err = json.Unmarshal(*v, &endTime)
				if err != nil {
					return err
				}
				psrp.EndTime = &endTime
			}
		case "errorMessage":
			if v != nil {
				var errorMessage string
				err = json.Unmarshal(*v, &errorMessage)
				if err != nil {
					return err
				}
				psrp.ErrorMessage = &errorMessage
			}
		case "pipelineStepName":
			if v != nil {
				var pipelineStepName string
				err = json.Unmarshal(*v, &pipelineStepName)
				if err != nil {
					return err
				}
				psrp.PipelineStepName = &pipelineStepName
			}
		case "pipelineStepRunStatus":
			if v != nil {
				var pipelineStepRunStatus PipelineStepRunStatus
				err = json.Unmarshal(*v, &pipelineStepRunStatus)
				if err != nil {
					return err
				}
				psrp.PipelineStepRunStatus = pipelineStepRunStatus
			}
		case "pipelineSubsteps":
			if v != nil {
				pipelineSubsteps, err := unmarshalBasicPipelineSubstepArray(*v)
				if err != nil {
					return err
				}
				psrp.PipelineSubsteps = &pipelineSubsteps
			}
		case "startTime":
			if v != nil {
				var startTime date.Time
				err = json.Unmarshal(*v, &startTime)
				if err != nil {
					return err
				}
				psrp.StartTime = &startTime
			}
		}
	}

	return nil
}

// PipelineStepsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelineStepsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PipelineStepsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PipelineStepsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PipelineStepsDeleteFuture.Result.
func (future *PipelineStepsDeleteFuture) result(client PipelineStepsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelineStepsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelineStepsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelineStepsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicPipelineSubstep substep of a pipeline step run
type BasicPipelineSubstep interface {
	AsDataMovementPipelineSubstep() (*DataMovementPipelineSubstep, bool)
	AsDiagnosticsLogPipelineSubstep() (*DiagnosticsLogPipelineSubstep, bool)
	AsScriptExecutionPipelineSubstep() (*ScriptExecutionPipelineSubstep, bool)
	AsPipelineSubstep() (*PipelineSubstep, bool)
}

// PipelineSubstep substep of a pipeline step run
type PipelineSubstep struct {
	// DurationMs - READ-ONLY; Substep run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of substep
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// ExecutionStatus - READ-ONLY; Execution status e.g. Success, Failed, InProgress. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Preparing', 'Queued', 'Unknown', 'Cancelled', 'Canceling', 'Waiting', 'Incomplete'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// PipelineSubstepID - READ-ONLY; Id of pipeline substep.
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// StartTime - READ-ONLY; Start time of substep
	StartTime *date.Time `json:"startTime,omitempty"`
	// Kind - Possible values include: 'KindBasicPipelineSubstepKindPipelineSubstep', 'KindBasicPipelineSubstepKindDataMovement', 'KindBasicPipelineSubstepKindDiagnosticsLog', 'KindBasicPipelineSubstepKindScriptExecution'
	Kind KindBasicPipelineSubstep `json:"kind,omitempty"`
}

func unmarshalBasicPipelineSubstep(body []byte) (BasicPipelineSubstep, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicPipelineSubstepKindDataMovement):
		var dmps DataMovementPipelineSubstep
		err := json.Unmarshal(body, &dmps)
		return dmps, err
	case string(KindBasicPipelineSubstepKindDiagnosticsLog):
		var dlps DiagnosticsLogPipelineSubstep
		err := json.Unmarshal(body, &dlps)
		return dlps, err
	case string(KindBasicPipelineSubstepKindScriptExecution):
		var seps ScriptExecutionPipelineSubstep
		err := json.Unmarshal(body, &seps)
		return seps, err
	default:
		var ps PipelineSubstep
		err := json.Unmarshal(body, &ps)
		return ps, err
	}
}
func unmarshalBasicPipelineSubstepArray(body []byte) ([]BasicPipelineSubstep, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	psArray := make([]BasicPipelineSubstep, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ps, err := unmarshalBasicPipelineSubstep(*rawMessage)
		if err != nil {
			return nil, err
		}
		psArray[index] = ps
	}
	return psArray, nil
}

// MarshalJSON is the custom marshaler for PipelineSubstep.
func (ps PipelineSubstep) MarshalJSON() ([]byte, error) {
	ps.Kind = KindBasicPipelineSubstepKindPipelineSubstep
	objectMap := make(map[string]interface{})
	if ps.Kind != "" {
		objectMap["kind"] = ps.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementPipelineSubstep is the BasicPipelineSubstep implementation for PipelineSubstep.
func (ps PipelineSubstep) AsDataMovementPipelineSubstep() (*DataMovementPipelineSubstep, bool) {
	return nil, false
}

// AsDiagnosticsLogPipelineSubstep is the BasicPipelineSubstep implementation for PipelineSubstep.
func (ps PipelineSubstep) AsDiagnosticsLogPipelineSubstep() (*DiagnosticsLogPipelineSubstep, bool) {
	return nil, false
}

// AsScriptExecutionPipelineSubstep is the BasicPipelineSubstep implementation for PipelineSubstep.
func (ps PipelineSubstep) AsScriptExecutionPipelineSubstep() (*ScriptExecutionPipelineSubstep, bool) {
	return nil, false
}

// AsPipelineSubstep is the BasicPipelineSubstep implementation for PipelineSubstep.
func (ps PipelineSubstep) AsPipelineSubstep() (*PipelineSubstep, bool) {
	return &ps, true
}

// AsBasicPipelineSubstep is the BasicPipelineSubstep implementation for PipelineSubstep.
func (ps PipelineSubstep) AsBasicPipelineSubstep() (BasicPipelineSubstep, bool) {
	return &ps, true
}

// PoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PoliciesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PoliciesDeleteFuture.Result.
func (future *PoliciesDeleteFuture) result(client PoliciesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PoliciesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PoliciesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicPolicy policy for entitlement
type BasicPolicy interface {
	AsDiagnosticPolicy() (*DiagnosticPolicy, bool)
	AsOutputPolicy() (*OutputPolicy, bool)
	AsPolicy() (*Policy, bool)
}

// Policy policy for entitlement
type Policy struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindPolicy', 'KindDiagnosticLevel', 'KindOutput'
	Kind KindBasicPolicy `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicPolicy(body []byte) (BasicPolicy, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindDiagnosticLevel):
		var dp DiagnosticPolicy
		err := json.Unmarshal(body, &dp)
		return dp, err
	case string(KindOutput):
		var op OutputPolicy
		err := json.Unmarshal(body, &op)
		return op, err
	default:
		var p Policy
		err := json.Unmarshal(body, &p)
		return p, err
	}
}
func unmarshalBasicPolicyArray(body []byte) ([]BasicPolicy, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	pArray := make([]BasicPolicy, len(rawMessages))

	for index, rawMessage := range rawMessages {
		p, err := unmarshalBasicPolicy(*rawMessage)
		if err != nil {
			return nil, err
		}
		pArray[index] = p
	}
	return pArray, nil
}

// MarshalJSON is the custom marshaler for Policy.
func (p Policy) MarshalJSON() ([]byte, error) {
	p.Kind = KindPolicy
	objectMap := make(map[string]interface{})
	if p.Kind != "" {
		objectMap["kind"] = p.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsDiagnosticPolicy() (*DiagnosticPolicy, bool) {
	return nil, false
}

// AsOutputPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsOutputPolicy() (*OutputPolicy, bool) {
	return nil, false
}

// AsPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsPolicy() (*Policy, bool) {
	return &p, true
}

// AsBasicPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsBasicPolicy() (BasicPolicy, bool) {
	return &p, true
}

// PolicyList list response for get Policies
type PolicyList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicPolicy `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PolicyList struct.
func (pl *PolicyList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				pl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicPolicyArray(*v)
				if err != nil {
					return err
				}
				pl.Value = &value
			}
		}
	}

	return nil
}

// PolicyListIterator provides access to a complete listing of Policy values.
type PolicyListIterator struct {
	i    int
	page PolicyListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PolicyListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PolicyListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PolicyListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PolicyListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PolicyListIterator) Response() PolicyList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PolicyListIterator) Value() BasicPolicy {
	if !iter.page.NotDone() {
		return Policy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PolicyListIterator type.
func NewPolicyListIterator(page PolicyListPage) PolicyListIterator {
	return PolicyListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl PolicyList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl PolicyList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// policyListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl PolicyList) policyListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// PolicyListPage contains a page of BasicPolicy values.
type PolicyListPage struct {
	fn func(context.Context, PolicyList) (PolicyList, error)
	pl PolicyList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PolicyListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PolicyListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PolicyListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PolicyListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PolicyListPage) Response() PolicyList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PolicyListPage) Values() []BasicPolicy {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the PolicyListPage type.
func NewPolicyListPage(cur PolicyList, getNextPage func(context.Context, PolicyList) (PolicyList, error)) PolicyListPage {
	return PolicyListPage{
		fn: getNextPage,
		pl: cur,
	}
}

// PolicyModel ...
type PolicyModel struct {
	autorest.Response `json:"-"`
	Value             BasicPolicy `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PolicyModel struct.
func (pm *PolicyModel) UnmarshalJSON(body []byte) error {
	p, err := unmarshalBasicPolicy(body)
	if err != nil {
		return err
	}
	pm.Value = p

	return nil
}

// PrivateEndpointConnectionState the connection state of a managed private endpoint
type PrivateEndpointConnectionState struct {
	// ActionsRequired - READ-ONLY; The actions required on the managed private endpoint
	ActionsRequired *string `json:"actionsRequired,omitempty"`
	// Description - READ-ONLY; The managed private endpoint description
	Description *string `json:"description,omitempty"`
	// PrivateEndpointStatus - READ-ONLY; The approval status. Possible values include: 'PrivateEndpointStatusPending', 'PrivateEndpointStatusApproved', 'PrivateEndpointStatusRejected', 'PrivateEndpointStatusDisconnected'
	PrivateEndpointStatus PrivateEndpointStatus `json:"privateEndpointStatus,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnectionState.
func (pecs PrivateEndpointConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Proposal a proposal for data collaboration contract, can be shared and edited by multiple participants
// before signing.
type Proposal struct {
	autorest.Response `json:"-"`
	// ProposalProperties - Properties on the proposal
	*ProposalProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Proposal.
func (p Proposal) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProposalProperties != nil {
		objectMap["properties"] = p.ProposalProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Proposal struct.
func (p *Proposal) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var proposalProperties ProposalProperties
				err = json.Unmarshal(*v, &proposalProperties)
				if err != nil {
					return err
				}
				p.ProposalProperties = &proposalProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				p.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ProposalList list response for get proposals
type ProposalList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Proposal `json:"value,omitempty"`
}

// ProposalListIterator provides access to a complete listing of Proposal values.
type ProposalListIterator struct {
	i    int
	page ProposalListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProposalListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProposalListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProposalListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProposalListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProposalListIterator) Response() ProposalList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProposalListIterator) Value() Proposal {
	if !iter.page.NotDone() {
		return Proposal{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProposalListIterator type.
func NewProposalListIterator(page ProposalListPage) ProposalListIterator {
	return ProposalListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl ProposalList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl ProposalList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// proposalListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl ProposalList) proposalListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// ProposalListPage contains a page of Proposal values.
type ProposalListPage struct {
	fn func(context.Context, ProposalList) (ProposalList, error)
	pl ProposalList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProposalListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProposalListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProposalListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProposalListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProposalListPage) Response() ProposalList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProposalListPage) Values() []Proposal {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the ProposalListPage type.
func NewProposalListPage(cur ProposalList, getNextPage func(context.Context, ProposalList) (ProposalList, error)) ProposalListPage {
	return ProposalListPage{
		fn: getNextPage,
		pl: cur,
	}
}

// ProposalProperties properties of proposal data transfer object.
type ProposalProperties struct {
	// ContractStatus - READ-ONLY; Indicate if the contract is an editable Draft or a readonly Active contract. Possible values include: 'Draft', 'Active'
	ContractStatus ContractStatus `json:"contractStatus,omitempty"`
	// CurrentVersion - READ-ONLY; The proposal version, any change to the proposal or any of its underlying resources will result in a different value.
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// CurrentVersionTimestamp - READ-ONLY; Timestamp of the last time the proposal or any of its underlying resources were updated.
	CurrentVersionTimestamp *date.Time `json:"currentVersionTimestamp,omitempty"`
	// Description - Textual description of the proposal
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name of the proposal
	DisplayName *string `json:"displayName,omitempty"`
	// InvitationID - The invitation id for joining a proposal
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationLocation - The invitation id for joining a proposal
	InvitationLocation *string `json:"invitationLocation,omitempty"`
	// ParticipantID - READ-ONLY; Id of the participant that authorized access to this proposal.
	ParticipantID *string `json:"participantId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the proposal. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Terms - Terms of the proposal
	Terms *string `json:"terms,omitempty"`
}

// MarshalJSON is the custom marshaler for ProposalProperties.
func (pp ProposalProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Description != nil {
		objectMap["description"] = pp.Description
	}
	if pp.DisplayName != nil {
		objectMap["displayName"] = pp.DisplayName
	}
	if pp.InvitationID != nil {
		objectMap["invitationId"] = pp.InvitationID
	}
	if pp.InvitationLocation != nil {
		objectMap["invitationLocation"] = pp.InvitationLocation
	}
	if pp.Terms != nil {
		objectMap["terms"] = pp.Terms
	}
	return json.Marshal(objectMap)
}

// ProposalsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProposalsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProposalsClient) (Proposal, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProposalsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProposalsCreateOrUpdateFuture.Result.
func (future *ProposalsCreateOrUpdateFuture) result(client ProposalsClient) (p Proposal, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.CreateOrUpdateResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsCreateOrUpdateFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProposalsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProposalsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProposalsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProposalsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProposalsDeleteFuture.Result.
func (future *ProposalsDeleteFuture) result(client ProposalsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProposalSignature dto for Proposal Signing request
type ProposalSignature struct {
	// ProposalVersion - Proposal version to be signed
	ProposalVersion *string `json:"proposalVersion,omitempty"`
}

// ProposalsSignFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProposalsSignFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProposalsClient) (Proposal, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProposalsSignFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProposalsSignFuture.Result.
func (future *ProposalsSignFuture) result(client ProposalsClient) (p Proposal, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsSignFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsSignFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.SignResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsSignFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProxyDto base data transfer object implementation for proxy resources.
type ProxyDto struct {
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyDto.
func (pd ProxyDto) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RegularExpressionScriptParameterRule script Parameter float range validation rule definition
type RegularExpressionScriptParameterRule struct {
	// RegularExpression - Defines a regular expression parameter value must supply
	RegularExpression *string `json:"regularExpression,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) MarshalJSON() ([]byte, error) {
	respr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeRegularExpression
	objectMap := make(map[string]interface{})
	if respr.RegularExpression != nil {
		objectMap["regularExpression"] = respr.RegularExpression
	}
	if respr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = respr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return &respr, true
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for RegularExpressionScriptParameterRule.
func (respr RegularExpressionScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &respr, true
}

// BasicResourceReference a set of data from external storage
type BasicResourceReference interface {
	AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool)
	AsDataAssetResourceReference() (*DataAssetResourceReference, bool)
	AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool)
	AsScriptResourceReference() (*ScriptResourceReference, bool)
	AsResourceReference() (*ResourceReference, bool)
}

// ResourceReference a set of data from external storage
type ResourceReference struct {
	// ParticipantDetails - READ-ONLY; Participant Details of the resource
	ParticipantDetails *ResourceReferenceParticipantDetails `json:"participantDetails,omitempty"`
	// ResourceID - READ-ONLY; Id of the azure resource
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceName - READ-ONLY; Name of the azure resource
	ResourceName *string `json:"resourceName,omitempty"`
	// ResourceType - READ-ONLY; Type of the azure resource
	ResourceType *string `json:"resourceType,omitempty"`
	// SystemData - READ-ONLY; SystemData Info of resource
	SystemData *ResourceReferenceSystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicResourceReferenceKindResourceReference', 'KindBasicResourceReferenceKindDataAssetReference', 'KindBasicResourceReferenceKindDataAsset', 'KindBasicResourceReferenceKindScriptReference', 'KindBasicResourceReferenceKindScript'
	Kind KindBasicResourceReference `json:"kind,omitempty"`
}

func unmarshalBasicResourceReference(body []byte) (BasicResourceReference, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicResourceReferenceKindDataAssetReference):
		var darrr DataAssetReferenceResourceReference
		err := json.Unmarshal(body, &darrr)
		return darrr, err
	case string(KindBasicResourceReferenceKindDataAsset):
		var darr DataAssetResourceReference
		err := json.Unmarshal(body, &darr)
		return darr, err
	case string(KindBasicResourceReferenceKindScriptReference):
		var srrr ScriptReferenceResourceReference
		err := json.Unmarshal(body, &srrr)
		return srrr, err
	case string(KindBasicResourceReferenceKindScript):
		var srr ScriptResourceReference
		err := json.Unmarshal(body, &srr)
		return srr, err
	default:
		var rr ResourceReference
		err := json.Unmarshal(body, &rr)
		return rr, err
	}
}
func unmarshalBasicResourceReferenceArray(body []byte) ([]BasicResourceReference, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	rrArray := make([]BasicResourceReference, len(rawMessages))

	for index, rawMessage := range rawMessages {
		rr, err := unmarshalBasicResourceReference(*rawMessage)
		if err != nil {
			return nil, err
		}
		rrArray[index] = rr
	}
	return rrArray, nil
}

// MarshalJSON is the custom marshaler for ResourceReference.
func (rr ResourceReference) MarshalJSON() ([]byte, error) {
	rr.Kind = KindBasicResourceReferenceKindResourceReference
	objectMap := make(map[string]interface{})
	if rr.Kind != "" {
		objectMap["kind"] = rr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetReferenceResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool) {
	return nil, false
}

// AsDataAssetResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsDataAssetResourceReference() (*DataAssetResourceReference, bool) {
	return nil, false
}

// AsScriptReferenceResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool) {
	return nil, false
}

// AsScriptResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsScriptResourceReference() (*ScriptResourceReference, bool) {
	return nil, false
}

// AsResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsResourceReference() (*ResourceReference, bool) {
	return &rr, true
}

// AsBasicResourceReference is the BasicResourceReference implementation for ResourceReference.
func (rr ResourceReference) AsBasicResourceReference() (BasicResourceReference, bool) {
	return &rr, true
}

// ResourceReferenceList list response for get resource references
type ResourceReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicResourceReference `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ResourceReferenceList struct.
func (rrl *ResourceReferenceList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				rrl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicResourceReferenceArray(*v)
				if err != nil {
					return err
				}
				rrl.Value = &value
			}
		}
	}

	return nil
}

// ResourceReferenceListIterator provides access to a complete listing of ResourceReference values.
type ResourceReferenceListIterator struct {
	i    int
	page ResourceReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceReferenceListIterator) Response() ResourceReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceReferenceListIterator) Value() BasicResourceReference {
	if !iter.page.NotDone() {
		return ResourceReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceReferenceListIterator type.
func NewResourceReferenceListIterator(page ResourceReferenceListPage) ResourceReferenceListIterator {
	return ResourceReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rrl ResourceReferenceList) IsEmpty() bool {
	return rrl.Value == nil || len(*rrl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rrl ResourceReferenceList) hasNextLink() bool {
	return rrl.NextLink != nil && len(*rrl.NextLink) != 0
}

// resourceReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rrl ResourceReferenceList) resourceReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !rrl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rrl.NextLink)))
}

// ResourceReferenceListPage contains a page of BasicResourceReference values.
type ResourceReferenceListPage struct {
	fn  func(context.Context, ResourceReferenceList) (ResourceReferenceList, error)
	rrl ResourceReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rrl)
		if err != nil {
			return err
		}
		page.rrl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceReferenceListPage) NotDone() bool {
	return !page.rrl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceReferenceListPage) Response() ResourceReferenceList {
	return page.rrl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceReferenceListPage) Values() []BasicResourceReference {
	if page.rrl.IsEmpty() {
		return nil
	}
	return *page.rrl.Value
}

// Creates a new instance of the ResourceReferenceListPage type.
func NewResourceReferenceListPage(cur ResourceReferenceList, getNextPage func(context.Context, ResourceReferenceList) (ResourceReferenceList, error)) ResourceReferenceListPage {
	return ResourceReferenceListPage{
		fn:  getNextPage,
		rrl: cur,
	}
}

// ResourceReferenceParticipantDetails participant Details of the resource
type ResourceReferenceParticipantDetails struct {
	// TenantName - READ-ONLY; Tenant name of the participant
	TenantName *string `json:"tenantName,omitempty"`
	// WorkspaceDisplayName - READ-ONLY; Display name of the workspace
	WorkspaceDisplayName *string `json:"workspaceDisplayName,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceReferenceParticipantDetails.
func (rrD ResourceReferenceParticipantDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceReferenceSystemData systemData Info of resource
type ResourceReferenceSystemData struct {
	// CreatedAt - READ-ONLY; The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// CreatedBy - READ-ONLY; The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - READ-ONLY; The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// LastModifiedAt - READ-ONLY; The type of identity that last modified the resource.
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
	// LastModifiedBy - READ-ONLY; The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - READ-ONLY; The type of identity that last modified the resource. Possible values include: 'LastModifiedByTypeUser', 'LastModifiedByTypeApplication', 'LastModifiedByTypeManagedIdentity', 'LastModifiedByTypeKey'
	LastModifiedByType LastModifiedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceReferenceSystemData.
func (rrD ResourceReferenceSystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BasicScript a script data transfer object
type BasicScript interface {
	AsSynapseSparkScript() (*SynapseSparkScript, bool)
	AsScript() (*Script, bool)
}

// Script a script data transfer object
type Script struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindBasicScriptKindScript', 'KindBasicScriptKindSynapseSpark'
	Kind KindBasicScript `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicScript(body []byte) (BasicScript, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicScriptKindSynapseSpark):
		var sss SynapseSparkScript
		err := json.Unmarshal(body, &sss)
		return sss, err
	default:
		var s Script
		err := json.Unmarshal(body, &s)
		return s, err
	}
}
func unmarshalBasicScriptArray(body []byte) ([]BasicScript, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sArray := make([]BasicScript, len(rawMessages))

	for index, rawMessage := range rawMessages {
		s, err := unmarshalBasicScript(*rawMessage)
		if err != nil {
			return nil, err
		}
		sArray[index] = s
	}
	return sArray, nil
}

// MarshalJSON is the custom marshaler for Script.
func (s Script) MarshalJSON() ([]byte, error) {
	s.Kind = KindBasicScriptKindScript
	objectMap := make(map[string]interface{})
	if s.Kind != "" {
		objectMap["kind"] = s.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkScript is the BasicScript implementation for Script.
func (s Script) AsSynapseSparkScript() (*SynapseSparkScript, bool) {
	return nil, false
}

// AsScript is the BasicScript implementation for Script.
func (s Script) AsScript() (*Script, bool) {
	return &s, true
}

// AsBasicScript is the BasicScript implementation for Script.
func (s Script) AsBasicScript() (BasicScript, bool) {
	return &s, true
}

// ScriptConstraint constraint used to only allow access if the resource is used with a specific script.
type ScriptConstraint struct {
	// ScriptConstraintProperties - Properties for script constraint
	*ScriptConstraintProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript', 'KindScriptParameter'
	Kind KindBasicConstraint `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptConstraint.
func (sc ScriptConstraint) MarshalJSON() ([]byte, error) {
	sc.Kind = KindScript
	objectMap := make(map[string]interface{})
	if sc.ScriptConstraintProperties != nil {
		objectMap["properties"] = sc.ScriptConstraintProperties
	}
	if sc.Kind != "" {
		objectMap["kind"] = sc.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return nil, false
}

// AsScriptConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return &sc, true
}

// AsScriptParameterConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsScriptParameterConstraint() (*ScriptParameterConstraint, bool) {
	return nil, false
}

// AsConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsConstraint() (*Constraint, bool) {
	return nil, false
}

// AsBasicConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &sc, true
}

// UnmarshalJSON is the custom unmarshaler for ScriptConstraint struct.
func (sc *ScriptConstraint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptConstraintProperties ScriptConstraintProperties
				err = json.Unmarshal(*v, &scriptConstraintProperties)
				if err != nil {
					return err
				}
				sc.ScriptConstraintProperties = &scriptConstraintProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicConstraint
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sc.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sc.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sc.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sc.Type = &typeVar
			}
		}
	}

	return nil
}

// ScriptConstraintProperties properties for script constraint used to only allow access if the resource is
// used with a specific script.
type ScriptConstraintProperties struct {
	// AdapterBindingConstraints - The identifier of the adapter binding constraints.
	AdapterBindingConstraints *[]AdapterBindingConstraint `json:"adapterBindingConstraints,omitempty"`
	// Description - Description of the constraint.
	Description *string `json:"description,omitempty"`
	// ScriptReferenceID - The unique identifier of the script reference.
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
}

// ScriptDataAssetBinding binds a data asset reference to a script source or sink by key.
type ScriptDataAssetBinding struct {
	// Adapter - Adapter used to access the data asset
	Adapter *BoundAdapter `json:"adapter,omitempty"`
	// BoundDataDescriptor - The bounded data descriptor
	BoundDataDescriptor BasicBoundDataDescriptor `json:"boundDataDescriptor,omitempty"`
	// Key - The key of script's source or sink
	Key *string `json:"key,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptDataAssetBinding struct.
func (sdab *ScriptDataAssetBinding) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "adapter":
			if v != nil {
				var adapter BoundAdapter
				err = json.Unmarshal(*v, &adapter)
				if err != nil {
					return err
				}
				sdab.Adapter = &adapter
			}
		case "boundDataDescriptor":
			if v != nil {
				boundDataDescriptor, err := unmarshalBasicBoundDataDescriptor(*v)
				if err != nil {
					return err
				}
				sdab.BoundDataDescriptor = boundDataDescriptor
			}
		case "key":
			if v != nil {
				var key string
				err = json.Unmarshal(*v, &key)
				if err != nil {
					return err
				}
				sdab.Key = &key
			}
		}
	}

	return nil
}

// ScriptExecutionInformation the information about an executed script
type ScriptExecutionInformation struct {
	// ExecutionParameters - READ-ONLY; The parameter values used during execution
	ExecutionParameters *[]ScriptExecutionParameter `json:"executionParameters,omitempty"`
	// Name - READ-ONLY; The name of the script
	Name *string `json:"name,omitempty"`
	// Purpose - READ-ONLY; The kind of the script
	Purpose *string `json:"purpose,omitempty"`
	// ResourceID - READ-ONLY; The resource id of the script
	ResourceID *string `json:"resourceId,omitempty"`
	// Revision - READ-ONLY; The revision of the script
	Revision *int32 `json:"revision,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptExecutionInformation.
func (sei ScriptExecutionInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ScriptExecutionParameter script parameter execution values
type ScriptExecutionParameter struct {
	// Name - Parameter name
	Name *string `json:"name,omitempty"`
	// ParameterType - Parameter type. Possible values include: 'Boolean', 'Integer', 'Float', 'String', 'DateTime'
	ParameterType ParameterType `json:"parameterType,omitempty"`
	// ResolvedBy - Parameter resolution by. Possible values include: 'ResolvedByDefault', 'ResolvedByConstant', 'ResolvedByPipelineRun'
	ResolvedBy ResolvedBy `json:"resolvedBy,omitempty"`
	// Value - Parameter value
	Value *string `json:"value,omitempty"`
}

// ScriptExecutionPipelineSubstep a substep representing scrip execution
type ScriptExecutionPipelineSubstep struct {
	// ExecutionTimeout - READ-ONLY; The upper boundary of script execution time
	ExecutionTimeout *string `json:"executionTimeout,omitempty"`
	// ScriptExecutionInformation - Script information
	ScriptExecutionInformation *ScriptExecutionInformation `json:"scriptExecutionInformation,omitempty"`
	// SinkBindings - Sink Binding
	SinkBindings *[]SinkBindingExecutionInformation `json:"sinkBindings,omitempty"`
	// SourceBindings - Source Binding
	SourceBindings *[]SourceBindingExecutionInformation `json:"sourceBindings,omitempty"`
	// SynapseSparkInformation - Information about the Synapse Spark
	SynapseSparkInformation *SynapseSparkInformation `json:"synapseSparkInformation,omitempty"`
	// DurationMs - READ-ONLY; Substep run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of substep
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// ExecutionStatus - READ-ONLY; Execution status e.g. Success, Failed, InProgress. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Preparing', 'Queued', 'Unknown', 'Cancelled', 'Canceling', 'Waiting', 'Incomplete'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// PipelineSubstepID - READ-ONLY; Id of pipeline substep.
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// StartTime - READ-ONLY; Start time of substep
	StartTime *date.Time `json:"startTime,omitempty"`
	// Kind - Possible values include: 'KindBasicPipelineSubstepKindPipelineSubstep', 'KindBasicPipelineSubstepKindDataMovement', 'KindBasicPipelineSubstepKindDiagnosticsLog', 'KindBasicPipelineSubstepKindScriptExecution'
	Kind KindBasicPipelineSubstep `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) MarshalJSON() ([]byte, error) {
	seps.Kind = KindBasicPipelineSubstepKindScriptExecution
	objectMap := make(map[string]interface{})
	if seps.ScriptExecutionInformation != nil {
		objectMap["scriptExecutionInformation"] = seps.ScriptExecutionInformation
	}
	if seps.SinkBindings != nil {
		objectMap["sinkBindings"] = seps.SinkBindings
	}
	if seps.SourceBindings != nil {
		objectMap["sourceBindings"] = seps.SourceBindings
	}
	if seps.SynapseSparkInformation != nil {
		objectMap["synapseSparkInformation"] = seps.SynapseSparkInformation
	}
	if seps.Kind != "" {
		objectMap["kind"] = seps.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementPipelineSubstep is the BasicPipelineSubstep implementation for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) AsDataMovementPipelineSubstep() (*DataMovementPipelineSubstep, bool) {
	return nil, false
}

// AsDiagnosticsLogPipelineSubstep is the BasicPipelineSubstep implementation for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) AsDiagnosticsLogPipelineSubstep() (*DiagnosticsLogPipelineSubstep, bool) {
	return nil, false
}

// AsScriptExecutionPipelineSubstep is the BasicPipelineSubstep implementation for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) AsScriptExecutionPipelineSubstep() (*ScriptExecutionPipelineSubstep, bool) {
	return &seps, true
}

// AsPipelineSubstep is the BasicPipelineSubstep implementation for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) AsPipelineSubstep() (*PipelineSubstep, bool) {
	return nil, false
}

// AsBasicPipelineSubstep is the BasicPipelineSubstep implementation for ScriptExecutionPipelineSubstep.
func (seps ScriptExecutionPipelineSubstep) AsBasicPipelineSubstep() (BasicPipelineSubstep, bool) {
	return &seps, true
}

// ScriptExecutionSubstepReference a reference to a script execution sub-step
type ScriptExecutionSubstepReference struct {
	// OutputBindingKey - READ-ONLY; The output binding key
	OutputBindingKey *string `json:"outputBindingKey,omitempty"`
	// PipelineStepName - READ-ONLY; The name of the Pipeline Step Run which contains the referred sub-step
	PipelineStepName *string `json:"pipelineStepName,omitempty"`
	// PipelineSubstepID - READ-ONLY; The Id of the Sub-step
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// Kind - Possible values include: 'KindSubstepReference', 'KindDataMovement', 'KindScriptExecution'
	Kind KindBasicSubstepReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptExecutionSubstepReference.
func (sesr ScriptExecutionSubstepReference) MarshalJSON() ([]byte, error) {
	sesr.Kind = KindScriptExecution
	objectMap := make(map[string]interface{})
	if sesr.Kind != "" {
		objectMap["kind"] = sesr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementSubstepReference is the BasicSubstepReference implementation for ScriptExecutionSubstepReference.
func (sesr ScriptExecutionSubstepReference) AsDataMovementSubstepReference() (*DataMovementSubstepReference, bool) {
	return nil, false
}

// AsScriptExecutionSubstepReference is the BasicSubstepReference implementation for ScriptExecutionSubstepReference.
func (sesr ScriptExecutionSubstepReference) AsScriptExecutionSubstepReference() (*ScriptExecutionSubstepReference, bool) {
	return &sesr, true
}

// AsSubstepReference is the BasicSubstepReference implementation for ScriptExecutionSubstepReference.
func (sesr ScriptExecutionSubstepReference) AsSubstepReference() (*SubstepReference, bool) {
	return nil, false
}

// AsBasicSubstepReference is the BasicSubstepReference implementation for ScriptExecutionSubstepReference.
func (sesr ScriptExecutionSubstepReference) AsBasicSubstepReference() (BasicSubstepReference, bool) {
	return &sesr, true
}

// ScriptList list response for get Scripts
type ScriptList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicScript `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptList struct.
func (sl *ScriptList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				sl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicScriptArray(*v)
				if err != nil {
					return err
				}
				sl.Value = &value
			}
		}
	}

	return nil
}

// ScriptListIterator provides access to a complete listing of Script values.
type ScriptListIterator struct {
	i    int
	page ScriptListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScriptListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScriptListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScriptListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScriptListIterator) Response() ScriptList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScriptListIterator) Value() BasicScript {
	if !iter.page.NotDone() {
		return Script{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScriptListIterator type.
func NewScriptListIterator(page ScriptListPage) ScriptListIterator {
	return ScriptListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sl ScriptList) IsEmpty() bool {
	return sl.Value == nil || len(*sl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sl ScriptList) hasNextLink() bool {
	return sl.NextLink != nil && len(*sl.NextLink) != 0
}

// scriptListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sl ScriptList) scriptListPreparer(ctx context.Context) (*http.Request, error) {
	if !sl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sl.NextLink)))
}

// ScriptListPage contains a page of BasicScript values.
type ScriptListPage struct {
	fn func(context.Context, ScriptList) (ScriptList, error)
	sl ScriptList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScriptListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sl)
		if err != nil {
			return err
		}
		page.sl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScriptListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScriptListPage) NotDone() bool {
	return !page.sl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScriptListPage) Response() ScriptList {
	return page.sl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScriptListPage) Values() []BasicScript {
	if page.sl.IsEmpty() {
		return nil
	}
	return *page.sl.Value
}

// Creates a new instance of the ScriptListPage type.
func NewScriptListPage(cur ScriptList, getNextPage func(context.Context, ScriptList) (ScriptList, error)) ScriptListPage {
	return ScriptListPage{
		fn: getNextPage,
		sl: cur,
	}
}

// ScriptModel ...
type ScriptModel struct {
	autorest.Response `json:"-"`
	Value             BasicScript `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptModel struct.
func (sm *ScriptModel) UnmarshalJSON(body []byte) error {
	s, err := unmarshalBasicScript(body)
	if err != nil {
		return err
	}
	sm.Value = s

	return nil
}

// ScriptOutputBoundDataDescriptor script output bound data descriptor
type ScriptOutputBoundDataDescriptor struct {
	// OutputName - The key of the output binding in the source step
	OutputName *string `json:"outputName,omitempty"`
	// StepName - The name of the source step
	StepName *string `json:"stepName,omitempty"`
	// Kind - Possible values include: 'KindBoundDataDescriptor', 'KindDataAsset', 'KindScriptOutput'
	Kind Kind `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptOutputBoundDataDescriptor.
func (sobdd ScriptOutputBoundDataDescriptor) MarshalJSON() ([]byte, error) {
	sobdd.Kind = KindScriptOutput
	objectMap := make(map[string]interface{})
	if sobdd.OutputName != nil {
		objectMap["outputName"] = sobdd.OutputName
	}
	if sobdd.StepName != nil {
		objectMap["stepName"] = sobdd.StepName
	}
	if sobdd.Kind != "" {
		objectMap["kind"] = sobdd.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetBoundDataDescriptor is the BasicBoundDataDescriptor implementation for ScriptOutputBoundDataDescriptor.
func (sobdd ScriptOutputBoundDataDescriptor) AsDataAssetBoundDataDescriptor() (*DataAssetBoundDataDescriptor, bool) {
	return nil, false
}

// AsScriptOutputBoundDataDescriptor is the BasicBoundDataDescriptor implementation for ScriptOutputBoundDataDescriptor.
func (sobdd ScriptOutputBoundDataDescriptor) AsScriptOutputBoundDataDescriptor() (*ScriptOutputBoundDataDescriptor, bool) {
	return &sobdd, true
}

// AsBoundDataDescriptor is the BasicBoundDataDescriptor implementation for ScriptOutputBoundDataDescriptor.
func (sobdd ScriptOutputBoundDataDescriptor) AsBoundDataDescriptor() (*BoundDataDescriptor, bool) {
	return nil, false
}

// AsBasicBoundDataDescriptor is the BasicBoundDataDescriptor implementation for ScriptOutputBoundDataDescriptor.
func (sobdd ScriptOutputBoundDataDescriptor) AsBasicBoundDataDescriptor() (BasicBoundDataDescriptor, bool) {
	return &sobdd, true
}

// BasicScriptParameter script parameter definition
type BasicScriptParameter interface {
	AsBooleanScriptParameter() (*BooleanScriptParameter, bool)
	AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool)
	AsFloatScriptParameter() (*FloatScriptParameter, bool)
	AsIntegerScriptParameter() (*IntegerScriptParameter, bool)
	AsStringScriptParameter() (*StringScriptParameter, bool)
	AsScriptParameter() (*ScriptParameter, bool)
}

// ScriptParameter script parameter definition
type ScriptParameter struct {
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

func unmarshalBasicScriptParameter(body []byte) (BasicScriptParameter, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["parameterType"] {
	case string(ParameterTypeBasicScriptParameterParameterTypeBoolean):
		var bsp BooleanScriptParameter
		err := json.Unmarshal(body, &bsp)
		return bsp, err
	case string(ParameterTypeBasicScriptParameterParameterTypeDateTime):
		var dtsp DateTimeScriptParameter
		err := json.Unmarshal(body, &dtsp)
		return dtsp, err
	case string(ParameterTypeBasicScriptParameterParameterTypeFloat):
		var fsp FloatScriptParameter
		err := json.Unmarshal(body, &fsp)
		return fsp, err
	case string(ParameterTypeBasicScriptParameterParameterTypeInteger):
		var isp IntegerScriptParameter
		err := json.Unmarshal(body, &isp)
		return isp, err
	case string(ParameterTypeBasicScriptParameterParameterTypeString):
		var ssp StringScriptParameter
		err := json.Unmarshal(body, &ssp)
		return ssp, err
	default:
		var sp ScriptParameter
		err := json.Unmarshal(body, &sp)
		return sp, err
	}
}
func unmarshalBasicScriptParameterArray(body []byte) ([]BasicScriptParameter, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	spArray := make([]BasicScriptParameter, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sp, err := unmarshalBasicScriptParameter(*rawMessage)
		if err != nil {
			return nil, err
		}
		spArray[index] = sp
	}
	return spArray, nil
}

// MarshalJSON is the custom marshaler for ScriptParameter.
func (sp ScriptParameter) MarshalJSON() ([]byte, error) {
	sp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeScriptParameter
	objectMap := make(map[string]interface{})
	if sp.Description != nil {
		objectMap["description"] = sp.Description
	}
	if sp.Name != nil {
		objectMap["name"] = sp.Name
	}
	if sp.ParameterID != nil {
		objectMap["parameterId"] = sp.ParameterID
	}
	if sp.ParameterType != "" {
		objectMap["parameterType"] = sp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return nil, false
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return nil, false
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return nil, false
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return nil, false
}

// AsStringScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return nil, false
}

// AsScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return &sp, true
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for ScriptParameter.
func (sp ScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &sp, true
}

// ScriptParameterBinding pipeline script parameter binding
type ScriptParameterBinding struct {
	// PipelineParameterID - Pipeline Parameter identifier
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ScriptParameterID - Script parameter identifier
	ScriptParameterID *string `json:"scriptParameterId,omitempty"`
}

// ScriptParameterConstraint constraint used to only allow access if the resource is using a specific
// script parameter.
type ScriptParameterConstraint struct {
	// ScriptParameterConstraintProperties - Properties for script parameter constraint
	*ScriptParameterConstraintProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript', 'KindScriptParameter'
	Kind KindBasicConstraint `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) MarshalJSON() ([]byte, error) {
	spc.Kind = KindScriptParameter
	objectMap := make(map[string]interface{})
	if spc.ScriptParameterConstraintProperties != nil {
		objectMap["properties"] = spc.ScriptParameterConstraintProperties
	}
	if spc.Kind != "" {
		objectMap["kind"] = spc.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return nil, false
}

// AsScriptConstraint is the BasicConstraint implementation for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return nil, false
}

// AsScriptParameterConstraint is the BasicConstraint implementation for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) AsScriptParameterConstraint() (*ScriptParameterConstraint, bool) {
	return &spc, true
}

// AsConstraint is the BasicConstraint implementation for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) AsConstraint() (*Constraint, bool) {
	return nil, false
}

// AsBasicConstraint is the BasicConstraint implementation for ScriptParameterConstraint.
func (spc ScriptParameterConstraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &spc, true
}

// UnmarshalJSON is the custom unmarshaler for ScriptParameterConstraint struct.
func (spc *ScriptParameterConstraint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptParameterConstraintProperties ScriptParameterConstraintProperties
				err = json.Unmarshal(*v, &scriptParameterConstraintProperties)
				if err != nil {
					return err
				}
				spc.ScriptParameterConstraintProperties = &scriptParameterConstraintProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicConstraint
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				spc.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spc.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				spc.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spc.Type = &typeVar
			}
		}
	}

	return nil
}

// ScriptParameterConstraintProperties properties for script parameter constraint used to only allow access
// if the resource is using a specific script parameter.
type ScriptParameterConstraintProperties struct {
	// Description - Description of the constraint.
	Description *string `json:"description,omitempty"`
	// IsParameterRequired - Parameter must exist
	IsParameterRequired *bool `json:"isParameterRequired,omitempty"`
	// ParameterName - The parameter name which this constraint will apply to
	ParameterName *string `json:"parameterName,omitempty"`
	// ParameterType - Parameter should be of type. Possible values include: 'Boolean', 'Integer', 'Float', 'String', 'DateTime'
	ParameterType ParameterType `json:"parameterType,omitempty"`
	// ValidationRule - Rule in which parameter have to follow
	ValidationRule BasicScriptParameterValidationRule `json:"validationRule,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptParameterConstraintProperties struct.
func (spcp *ScriptParameterConstraintProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				spcp.Description = &description
			}
		case "isParameterRequired":
			if v != nil {
				var isParameterRequired bool
				err = json.Unmarshal(*v, &isParameterRequired)
				if err != nil {
					return err
				}
				spcp.IsParameterRequired = &isParameterRequired
			}
		case "parameterName":
			if v != nil {
				var parameterName string
				err = json.Unmarshal(*v, &parameterName)
				if err != nil {
					return err
				}
				spcp.ParameterName = &parameterName
			}
		case "parameterType":
			if v != nil {
				var parameterType ParameterType
				err = json.Unmarshal(*v, &parameterType)
				if err != nil {
					return err
				}
				spcp.ParameterType = parameterType
			}
		case "validationRule":
			if v != nil {
				validationRule, err := unmarshalBasicScriptParameterValidationRule(*v)
				if err != nil {
					return err
				}
				spcp.ValidationRule = validationRule
			}
		}
	}

	return nil
}

// BasicScriptParameterValidationRule script Parameter validation rule definition
type BasicScriptParameterValidationRule interface {
	AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool)
	AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool)
	AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool)
	AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool)
	AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool)
	AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool)
	AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool)
	AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool)
	AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool)
	AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool)
}

// ScriptParameterValidationRule script Parameter validation rule definition
type ScriptParameterValidationRule struct {
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

func unmarshalBasicScriptParameterValidationRule(body []byte) (BasicScriptParameterValidationRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["scriptParameterValidationRuleType"] {
	case string(ScriptParameterValidationRuleTypeDateTimeOptionsSet):
		var dtosspr DateTimeOptionsSetScriptParameterRule
		err := json.Unmarshal(body, &dtosspr)
		return dtosspr, err
	case string(ScriptParameterValidationRuleTypeDateTimeRange):
		var dtrspr DateTimeRangeScriptParameterRule
		err := json.Unmarshal(body, &dtrspr)
		return dtrspr, err
	case string(ScriptParameterValidationRuleTypeFloatOptionsSet):
		var fosspr FloatOptionsSetScriptParameterRule
		err := json.Unmarshal(body, &fosspr)
		return fosspr, err
	case string(ScriptParameterValidationRuleTypeFloatRange):
		var frspr FloatRangeScriptParameterRule
		err := json.Unmarshal(body, &frspr)
		return frspr, err
	case string(ScriptParameterValidationRuleTypeIntegerOptionsSet):
		var iosspr IntegerOptionsSetScriptParameterRule
		err := json.Unmarshal(body, &iosspr)
		return iosspr, err
	case string(ScriptParameterValidationRuleTypeIntegerRange):
		var irspr IntegerRangeScriptParameterRule
		err := json.Unmarshal(body, &irspr)
		return irspr, err
	case string(ScriptParameterValidationRuleTypeRegularExpression):
		var respr RegularExpressionScriptParameterRule
		err := json.Unmarshal(body, &respr)
		return respr, err
	case string(ScriptParameterValidationRuleTypeStringLengthRange):
		var slrspr StringLengthRangeScriptParameterRule
		err := json.Unmarshal(body, &slrspr)
		return slrspr, err
	case string(ScriptParameterValidationRuleTypeStringOptionsSet):
		var sosspr StringOptionsSetScriptParameterRule
		err := json.Unmarshal(body, &sosspr)
		return sosspr, err
	default:
		var spvr ScriptParameterValidationRule
		err := json.Unmarshal(body, &spvr)
		return spvr, err
	}
}
func unmarshalBasicScriptParameterValidationRuleArray(body []byte) ([]BasicScriptParameterValidationRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	spvrArray := make([]BasicScriptParameterValidationRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		spvr, err := unmarshalBasicScriptParameterValidationRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		spvrArray[index] = spvr
	}
	return spvrArray, nil
}

// MarshalJSON is the custom marshaler for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) MarshalJSON() ([]byte, error) {
	spvr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeScriptParameterValidationRule
	objectMap := make(map[string]interface{})
	if spvr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = spvr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return &spvr, true
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for ScriptParameterValidationRule.
func (spvr ScriptParameterValidationRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &spvr, true
}

// ScriptReference script reference dto.
type ScriptReference struct {
	autorest.Response `json:"-"`
	// ScriptReferenceProperties - Properties on the script reference
	*ScriptReferenceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReference.
func (sr ScriptReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.ScriptReferenceProperties != nil {
		objectMap["properties"] = sr.ScriptReferenceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScriptReference struct.
func (sr *ScriptReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptReferenceProperties ScriptReferenceProperties
				err = json.Unmarshal(*v, &scriptReferenceProperties)
				if err != nil {
					return err
				}
				sr.ScriptReferenceProperties = &scriptReferenceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sr.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sr.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sr.Type = &typeVar
			}
		}
	}

	return nil
}

// ScriptReferenceList list response for get script references
type ScriptReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]ScriptReference `json:"value,omitempty"`
}

// ScriptReferenceListIterator provides access to a complete listing of ScriptReference values.
type ScriptReferenceListIterator struct {
	i    int
	page ScriptReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScriptReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScriptReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScriptReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScriptReferenceListIterator) Response() ScriptReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScriptReferenceListIterator) Value() ScriptReference {
	if !iter.page.NotDone() {
		return ScriptReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScriptReferenceListIterator type.
func NewScriptReferenceListIterator(page ScriptReferenceListPage) ScriptReferenceListIterator {
	return ScriptReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (srl ScriptReferenceList) IsEmpty() bool {
	return srl.Value == nil || len(*srl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (srl ScriptReferenceList) hasNextLink() bool {
	return srl.NextLink != nil && len(*srl.NextLink) != 0
}

// scriptReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (srl ScriptReferenceList) scriptReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !srl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(srl.NextLink)))
}

// ScriptReferenceListPage contains a page of ScriptReference values.
type ScriptReferenceListPage struct {
	fn  func(context.Context, ScriptReferenceList) (ScriptReferenceList, error)
	srl ScriptReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScriptReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.srl)
		if err != nil {
			return err
		}
		page.srl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScriptReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScriptReferenceListPage) NotDone() bool {
	return !page.srl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScriptReferenceListPage) Response() ScriptReferenceList {
	return page.srl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScriptReferenceListPage) Values() []ScriptReference {
	if page.srl.IsEmpty() {
		return nil
	}
	return *page.srl.Value
}

// Creates a new instance of the ScriptReferenceListPage type.
func NewScriptReferenceListPage(cur ScriptReferenceList, getNextPage func(context.Context, ScriptReferenceList) (ScriptReferenceList, error)) ScriptReferenceListPage {
	return ScriptReferenceListPage{
		fn:  getNextPage,
		srl: cur,
	}
}

// ScriptReferencePlaceholderInfo placeholder information for a script reference
type ScriptReferencePlaceholderInfo struct {
	// AssignerID - Participant id who is allowed to assign the placeholder.
	AssignerID *string `json:"assignerId,omitempty"`
	// Description - Description of the placeholder.
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name of the placeholder.
	DisplayName *string `json:"displayName,omitempty"`
	// Purpose - Script purpose. Possible values include: 'Body', 'InputAdapter', 'OutputAdapter'
	Purpose Purpose `json:"purpose,omitempty"`
}

// ScriptReferenceProperties properties of data set reference data transfer object.
type ScriptReferenceProperties struct {
	// DisplayName - Reference display name
	DisplayName *string `json:"displayName,omitempty"`
	// OwnerID - READ-ONLY; The participant id of the script owner
	OwnerID *string `json:"ownerId,omitempty"`
	// Parameters - READ-ONLY; The list of script parameters
	Parameters *[]BasicScriptParameter `json:"parameters,omitempty"`
	// PlaceholderInfo - The placeholder information
	PlaceholderInfo *ScriptReferencePlaceholderInfo `json:"placeholderInfo,omitempty"`
	// PlaceholderState - READ-ONLY; The placeholder state. Possible values include: 'PlaceholderStateNone', 'PlaceholderStateUnassigned', 'PlaceholderStateAssigned'
	PlaceholderState PlaceholderState `json:"placeholderState,omitempty"`
	// Purpose - READ-ONLY; Script purpose. Possible values include: 'Body', 'InputAdapter', 'OutputAdapter'
	Purpose Purpose `json:"purpose,omitempty"`
	// Revision - The revision number of the script being referenced.
	// If omitted, the script latest version will be referenced.
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - The unique identifier of the referenced script
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptKind - READ-ONLY; Kind of the referenced script. Possible values include: 'SynapseSpark'
	ScriptKind ScriptKind `json:"scriptKind,omitempty"`
	// ScriptReferenceID - READ-ONLY; Unique id for identifying a script reference resource
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
	// ScriptVisibility - READ-ONLY; The referenced script visibility modifier. Possible values include: 'ShowAll', 'HiddenContent'
	ScriptVisibility ScriptVisibility `json:"scriptVisibility,omitempty"`
	// Sinks - READ-ONLY; The list of parameters the script can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - READ-ONLY; The list of parameters the script can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReferenceProperties.
func (srp ScriptReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srp.DisplayName != nil {
		objectMap["displayName"] = srp.DisplayName
	}
	if srp.PlaceholderInfo != nil {
		objectMap["placeholderInfo"] = srp.PlaceholderInfo
	}
	if srp.Revision != nil {
		objectMap["revision"] = srp.Revision
	}
	if srp.ScriptID != nil {
		objectMap["scriptId"] = srp.ScriptID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScriptReferenceProperties struct.
func (srp *ScriptReferenceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				srp.DisplayName = &displayName
			}
		case "ownerId":
			if v != nil {
				var ownerID string
				err = json.Unmarshal(*v, &ownerID)
				if err != nil {
					return err
				}
				srp.OwnerID = &ownerID
			}
		case "parameters":
			if v != nil {
				parameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				srp.Parameters = &parameters
			}
		case "placeholderInfo":
			if v != nil {
				var placeholderInfo ScriptReferencePlaceholderInfo
				err = json.Unmarshal(*v, &placeholderInfo)
				if err != nil {
					return err
				}
				srp.PlaceholderInfo = &placeholderInfo
			}
		case "placeholderState":
			if v != nil {
				var placeholderState PlaceholderState
				err = json.Unmarshal(*v, &placeholderState)
				if err != nil {
					return err
				}
				srp.PlaceholderState = placeholderState
			}
		case "purpose":
			if v != nil {
				var purpose Purpose
				err = json.Unmarshal(*v, &purpose)
				if err != nil {
					return err
				}
				srp.Purpose = purpose
			}
		case "revision":
			if v != nil {
				var revision int32
				err = json.Unmarshal(*v, &revision)
				if err != nil {
					return err
				}
				srp.Revision = &revision
			}
		case "scriptId":
			if v != nil {
				var scriptID string
				err = json.Unmarshal(*v, &scriptID)
				if err != nil {
					return err
				}
				srp.ScriptID = &scriptID
			}
		case "scriptKind":
			if v != nil {
				var scriptKind ScriptKind
				err = json.Unmarshal(*v, &scriptKind)
				if err != nil {
					return err
				}
				srp.ScriptKind = scriptKind
			}
		case "scriptReferenceId":
			if v != nil {
				var scriptReferenceID string
				err = json.Unmarshal(*v, &scriptReferenceID)
				if err != nil {
					return err
				}
				srp.ScriptReferenceID = &scriptReferenceID
			}
		case "scriptVisibility":
			if v != nil {
				var scriptVisibility ScriptVisibility
				err = json.Unmarshal(*v, &scriptVisibility)
				if err != nil {
					return err
				}
				srp.ScriptVisibility = scriptVisibility
			}
		case "sinks":
			if v != nil {
				var sinks []string
				err = json.Unmarshal(*v, &sinks)
				if err != nil {
					return err
				}
				srp.Sinks = &sinks
			}
		case "sources":
			if v != nil {
				var sources []string
				err = json.Unmarshal(*v, &sources)
				if err != nil {
					return err
				}
				srp.Sources = &sources
			}
		}
	}

	return nil
}

// ScriptReferenceResourceReference resourceReference used to only allow access if the resource is used
// within the specified Azure scriptReference.
type ScriptReferenceResourceReference struct {
	// ScriptReferenceResourceReferenceProperties - Properties for scriptReference resource reference
	*ScriptReferenceResourceReferenceProperties `json:"properties,omitempty"`
	// ParticipantDetails - READ-ONLY; Participant Details of the resource
	ParticipantDetails *ResourceReferenceParticipantDetails `json:"participantDetails,omitempty"`
	// ResourceID - READ-ONLY; Id of the azure resource
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceName - READ-ONLY; Name of the azure resource
	ResourceName *string `json:"resourceName,omitempty"`
	// ResourceType - READ-ONLY; Type of the azure resource
	ResourceType *string `json:"resourceType,omitempty"`
	// SystemData - READ-ONLY; SystemData Info of resource
	SystemData *ResourceReferenceSystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicResourceReferenceKindResourceReference', 'KindBasicResourceReferenceKindDataAssetReference', 'KindBasicResourceReferenceKindDataAsset', 'KindBasicResourceReferenceKindScriptReference', 'KindBasicResourceReferenceKindScript'
	Kind KindBasicResourceReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) MarshalJSON() ([]byte, error) {
	srrr.Kind = KindBasicResourceReferenceKindScriptReference
	objectMap := make(map[string]interface{})
	if srrr.ScriptReferenceResourceReferenceProperties != nil {
		objectMap["properties"] = srrr.ScriptReferenceResourceReferenceProperties
	}
	if srrr.Kind != "" {
		objectMap["kind"] = srrr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetReferenceResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool) {
	return nil, false
}

// AsDataAssetResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsDataAssetResourceReference() (*DataAssetResourceReference, bool) {
	return nil, false
}

// AsScriptReferenceResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool) {
	return &srrr, true
}

// AsScriptResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsScriptResourceReference() (*ScriptResourceReference, bool) {
	return nil, false
}

// AsResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsResourceReference() (*ResourceReference, bool) {
	return nil, false
}

// AsBasicResourceReference is the BasicResourceReference implementation for ScriptReferenceResourceReference.
func (srrr ScriptReferenceResourceReference) AsBasicResourceReference() (BasicResourceReference, bool) {
	return &srrr, true
}

// UnmarshalJSON is the custom unmarshaler for ScriptReferenceResourceReference struct.
func (srrr *ScriptReferenceResourceReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptReferenceResourceReferenceProperties ScriptReferenceResourceReferenceProperties
				err = json.Unmarshal(*v, &scriptReferenceResourceReferenceProperties)
				if err != nil {
					return err
				}
				srrr.ScriptReferenceResourceReferenceProperties = &scriptReferenceResourceReferenceProperties
			}
		case "participantDetails":
			if v != nil {
				var participantDetails ResourceReferenceParticipantDetails
				err = json.Unmarshal(*v, &participantDetails)
				if err != nil {
					return err
				}
				srrr.ParticipantDetails = &participantDetails
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				srrr.ResourceID = &resourceID
			}
		case "resourceName":
			if v != nil {
				var resourceName string
				err = json.Unmarshal(*v, &resourceName)
				if err != nil {
					return err
				}
				srrr.ResourceName = &resourceName
			}
		case "resourceType":
			if v != nil {
				var resourceType string
				err = json.Unmarshal(*v, &resourceType)
				if err != nil {
					return err
				}
				srrr.ResourceType = &resourceType
			}
		case "systemData":
			if v != nil {
				var systemData ResourceReferenceSystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				srrr.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicResourceReference
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				srrr.Kind = kind
			}
		}
	}

	return nil
}

// ScriptReferenceResourceReferenceProperties properties for scriptReference resource reference used to
// only allow access if the resource is used within the specified Azure scriptReference.
type ScriptReferenceResourceReferenceProperties struct {
	// DisplayName - READ-ONLY; Reference display name
	DisplayName *string `json:"displayName,omitempty"`
	// Parameters - READ-ONLY; The list of script parameters
	Parameters *[]BasicScriptParameter `json:"parameters,omitempty"`
	// Purpose - READ-ONLY; Script purpose. Possible values include: 'Body', 'InputAdapter', 'OutputAdapter'
	Purpose Purpose `json:"purpose,omitempty"`
	// Revision - READ-ONLY; The revision number of the scriptReference being referenced.
	// If omitted, the scriptReference latest version will be referenced.
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - READ-ONLY; The unique identifier of the referenced script
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptKind - READ-ONLY; Kind of the referenced script. Possible values include: 'SynapseSpark'
	ScriptKind ScriptKind `json:"scriptKind,omitempty"`
	// ScriptReferenceID - READ-ONLY; The unique identifier of the scriptReference
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
	// Sinks - READ-ONLY; The list of parameters the scriptReference can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - READ-ONLY; The list of parameters the scriptReference can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReferenceResourceReferenceProperties.
func (srrrp ScriptReferenceResourceReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScriptReferenceResourceReferenceProperties struct.
func (srrrp *ScriptReferenceResourceReferenceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				srrrp.DisplayName = &displayName
			}
		case "parameters":
			if v != nil {
				parameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				srrrp.Parameters = &parameters
			}
		case "purpose":
			if v != nil {
				var purpose Purpose
				err = json.Unmarshal(*v, &purpose)
				if err != nil {
					return err
				}
				srrrp.Purpose = purpose
			}
		case "revision":
			if v != nil {
				var revision int32
				err = json.Unmarshal(*v, &revision)
				if err != nil {
					return err
				}
				srrrp.Revision = &revision
			}
		case "scriptId":
			if v != nil {
				var scriptID string
				err = json.Unmarshal(*v, &scriptID)
				if err != nil {
					return err
				}
				srrrp.ScriptID = &scriptID
			}
		case "scriptKind":
			if v != nil {
				var scriptKind ScriptKind
				err = json.Unmarshal(*v, &scriptKind)
				if err != nil {
					return err
				}
				srrrp.ScriptKind = scriptKind
			}
		case "scriptReferenceId":
			if v != nil {
				var scriptReferenceID string
				err = json.Unmarshal(*v, &scriptReferenceID)
				if err != nil {
					return err
				}
				srrrp.ScriptReferenceID = &scriptReferenceID
			}
		case "sinks":
			if v != nil {
				var sinks []string
				err = json.Unmarshal(*v, &sinks)
				if err != nil {
					return err
				}
				srrrp.Sinks = &sinks
			}
		case "sources":
			if v != nil {
				var sources []string
				err = json.Unmarshal(*v, &sources)
				if err != nil {
					return err
				}
				srrrp.Sources = &sources
			}
		}
	}

	return nil
}

// ScriptReferencesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ScriptReferencesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ScriptReferencesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ScriptReferencesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ScriptReferencesDeleteFuture.Result.
func (future *ScriptReferencesDeleteFuture) result(client ScriptReferencesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ScriptReferencesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ScriptReferencesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ScriptReferencesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ScriptResourceReference resourceReference used to only allow access if the resource is used within the
// specified Azure script.
type ScriptResourceReference struct {
	// ScriptResourceReferenceProperties - Properties for script resource reference
	*ScriptResourceReferenceProperties `json:"properties,omitempty"`
	// ParticipantDetails - READ-ONLY; Participant Details of the resource
	ParticipantDetails *ResourceReferenceParticipantDetails `json:"participantDetails,omitempty"`
	// ResourceID - READ-ONLY; Id of the azure resource
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceName - READ-ONLY; Name of the azure resource
	ResourceName *string `json:"resourceName,omitempty"`
	// ResourceType - READ-ONLY; Type of the azure resource
	ResourceType *string `json:"resourceType,omitempty"`
	// SystemData - READ-ONLY; SystemData Info of resource
	SystemData *ResourceReferenceSystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicResourceReferenceKindResourceReference', 'KindBasicResourceReferenceKindDataAssetReference', 'KindBasicResourceReferenceKindDataAsset', 'KindBasicResourceReferenceKindScriptReference', 'KindBasicResourceReferenceKindScript'
	Kind KindBasicResourceReference `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptResourceReference.
func (srr ScriptResourceReference) MarshalJSON() ([]byte, error) {
	srr.Kind = KindBasicResourceReferenceKindScript
	objectMap := make(map[string]interface{})
	if srr.ScriptResourceReferenceProperties != nil {
		objectMap["properties"] = srr.ScriptResourceReferenceProperties
	}
	if srr.Kind != "" {
		objectMap["kind"] = srr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataAssetReferenceResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsDataAssetReferenceResourceReference() (*DataAssetReferenceResourceReference, bool) {
	return nil, false
}

// AsDataAssetResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsDataAssetResourceReference() (*DataAssetResourceReference, bool) {
	return nil, false
}

// AsScriptReferenceResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsScriptReferenceResourceReference() (*ScriptReferenceResourceReference, bool) {
	return nil, false
}

// AsScriptResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsScriptResourceReference() (*ScriptResourceReference, bool) {
	return &srr, true
}

// AsResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsResourceReference() (*ResourceReference, bool) {
	return nil, false
}

// AsBasicResourceReference is the BasicResourceReference implementation for ScriptResourceReference.
func (srr ScriptResourceReference) AsBasicResourceReference() (BasicResourceReference, bool) {
	return &srr, true
}

// UnmarshalJSON is the custom unmarshaler for ScriptResourceReference struct.
func (srr *ScriptResourceReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptResourceReferenceProperties ScriptResourceReferenceProperties
				err = json.Unmarshal(*v, &scriptResourceReferenceProperties)
				if err != nil {
					return err
				}
				srr.ScriptResourceReferenceProperties = &scriptResourceReferenceProperties
			}
		case "participantDetails":
			if v != nil {
				var participantDetails ResourceReferenceParticipantDetails
				err = json.Unmarshal(*v, &participantDetails)
				if err != nil {
					return err
				}
				srr.ParticipantDetails = &participantDetails
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				srr.ResourceID = &resourceID
			}
		case "resourceName":
			if v != nil {
				var resourceName string
				err = json.Unmarshal(*v, &resourceName)
				if err != nil {
					return err
				}
				srr.ResourceName = &resourceName
			}
		case "resourceType":
			if v != nil {
				var resourceType string
				err = json.Unmarshal(*v, &resourceType)
				if err != nil {
					return err
				}
				srr.ResourceType = &resourceType
			}
		case "systemData":
			if v != nil {
				var systemData ResourceReferenceSystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				srr.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicResourceReference
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				srr.Kind = kind
			}
		}
	}

	return nil
}

// ScriptResourceReferenceProperties properties for script resource reference used to only allow access if
// the resource is used within the specified Azure script.
type ScriptResourceReferenceProperties struct {
	// Parameters - READ-ONLY; The list of script parameters
	Parameters *[]BasicScriptParameter `json:"parameters,omitempty"`
	// Purpose - READ-ONLY; Script purpose. Possible values include: 'Body', 'InputAdapter', 'OutputAdapter'
	Purpose Purpose `json:"purpose,omitempty"`
	// Revision - READ-ONLY; The revision number of the script being referenced.
	// If omitted, the script latest version will be referenced.
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - READ-ONLY; The unique identifier of the referenced script
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptKind - READ-ONLY; Kind of the referenced script. Possible values include: 'SynapseSpark'
	ScriptKind ScriptKind `json:"scriptKind,omitempty"`
	// Sinks - READ-ONLY; The list of parameters the script can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - READ-ONLY; The list of parameters the script can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptResourceReferenceProperties.
func (srrp ScriptResourceReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScriptResourceReferenceProperties struct.
func (srrp *ScriptResourceReferenceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "parameters":
			if v != nil {
				parameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				srrp.Parameters = &parameters
			}
		case "purpose":
			if v != nil {
				var purpose Purpose
				err = json.Unmarshal(*v, &purpose)
				if err != nil {
					return err
				}
				srrp.Purpose = purpose
			}
		case "revision":
			if v != nil {
				var revision int32
				err = json.Unmarshal(*v, &revision)
				if err != nil {
					return err
				}
				srrp.Revision = &revision
			}
		case "scriptId":
			if v != nil {
				var scriptID string
				err = json.Unmarshal(*v, &scriptID)
				if err != nil {
					return err
				}
				srrp.ScriptID = &scriptID
			}
		case "scriptKind":
			if v != nil {
				var scriptKind ScriptKind
				err = json.Unmarshal(*v, &scriptKind)
				if err != nil {
					return err
				}
				srrp.ScriptKind = scriptKind
			}
		case "sinks":
			if v != nil {
				var sinks []string
				err = json.Unmarshal(*v, &sinks)
				if err != nil {
					return err
				}
				srrp.Sinks = &sinks
			}
		case "sources":
			if v != nil {
				var sources []string
				err = json.Unmarshal(*v, &sources)
				if err != nil {
					return err
				}
				srrp.Sources = &sources
			}
		}
	}

	return nil
}

// ScriptsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ScriptsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ScriptsClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ScriptsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ScriptsDeleteFuture.Result.
func (future *ScriptsDeleteFuture) result(client ScriptsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ScriptsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ScriptsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ScriptsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SinkBindingExecutionInformation information about the bounded sink
type SinkBindingExecutionInformation struct {
	// Adapter - The bounded adapter
	Adapter *ScriptExecutionInformation `json:"adapter,omitempty"`
	// BindingKey - READ-ONLY; The binding key
	BindingKey *string `json:"bindingKey,omitempty"`
}

// MarshalJSON is the custom marshaler for SinkBindingExecutionInformation.
func (sbei SinkBindingExecutionInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sbei.Adapter != nil {
		objectMap["adapter"] = sbei.Adapter
	}
	return json.Marshal(objectMap)
}

// SourceBindingExecutionInformation information about the bounded source
type SourceBindingExecutionInformation struct {
	// Adapter - The bounded adapter
	Adapter *ScriptExecutionInformation `json:"adapter,omitempty"`
	// BindingKey - READ-ONLY; The binding key
	BindingKey *string `json:"bindingKey,omitempty"`
	// SourceSubstepReference - The bounded sub-step
	SourceSubstepReference BasicSubstepReference `json:"sourceSubstepReference,omitempty"`
}

// MarshalJSON is the custom marshaler for SourceBindingExecutionInformation.
func (sbei SourceBindingExecutionInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sbei.Adapter != nil {
		objectMap["adapter"] = sbei.Adapter
	}
	objectMap["sourceSubstepReference"] = sbei.SourceSubstepReference
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SourceBindingExecutionInformation struct.
func (sbei *SourceBindingExecutionInformation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "adapter":
			if v != nil {
				var adapter ScriptExecutionInformation
				err = json.Unmarshal(*v, &adapter)
				if err != nil {
					return err
				}
				sbei.Adapter = &adapter
			}
		case "bindingKey":
			if v != nil {
				var bindingKey string
				err = json.Unmarshal(*v, &bindingKey)
				if err != nil {
					return err
				}
				sbei.BindingKey = &bindingKey
			}
		case "sourceSubstepReference":
			if v != nil {
				sourceSubstepReference, err := unmarshalBasicSubstepReference(*v)
				if err != nil {
					return err
				}
				sbei.SourceSubstepReference = sourceSubstepReference
			}
		}
	}

	return nil
}

// SparkPoolExecutionInformation information about the Spark pool execution
type SparkPoolExecutionInformation struct {
	// ExecutorNodeSize - READ-ONLY; The executers node size
	ExecutorNodeSize *string `json:"executorNodeSize,omitempty"`
	// ExecutorsCount - READ-ONLY; The executers count
	ExecutorsCount *int32 `json:"executorsCount,omitempty"`
}

// MarshalJSON is the custom marshaler for SparkPoolExecutionInformation.
func (spei SparkPoolExecutionInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SparkPoolInformation information about the Spark pool
type SparkPoolInformation struct {
	// MaxNodeCount - READ-ONLY; The Spark pool max node count (If auto-scale is enabled)
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`
	// MinNodeCount - READ-ONLY; The Spark pool min node count (If auto-scale is enabled)
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
	// NodeCount - READ-ONLY; The Spark pool node count
	NodeCount *int32 `json:"nodeCount,omitempty"`
	// NodeSize - READ-ONLY; The Spark pool node size
	NodeSize *string `json:"nodeSize,omitempty"`
	// ResourceID - READ-ONLY; The resource Id of the Spark pool
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for SparkPoolInformation.
func (spi SparkPoolInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StringLengthRangeScriptParameterRule script Parameter float range validation rule definition
type StringLengthRangeScriptParameterRule struct {
	// MaximumLength - Defines maximum length for the string parameter
	MaximumLength *int32 `json:"maximumLength,omitempty"`
	// MinimumLength - Defines minimum length for the string parameter
	MinimumLength *int32 `json:"minimumLength,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) MarshalJSON() ([]byte, error) {
	slrspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeStringLengthRange
	objectMap := make(map[string]interface{})
	if slrspr.MaximumLength != nil {
		objectMap["maximumLength"] = slrspr.MaximumLength
	}
	if slrspr.MinimumLength != nil {
		objectMap["minimumLength"] = slrspr.MinimumLength
	}
	if slrspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = slrspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return &slrspr, true
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for StringLengthRangeScriptParameterRule.
func (slrspr StringLengthRangeScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &slrspr, true
}

// StringOptionsSetScriptParameterRule script Parameter String Options Set validation rule definition
type StringOptionsSetScriptParameterRule struct {
	// Options - Defines a set of value options for the parameter
	Options *[]string `json:"options,omitempty"`
	// ScriptParameterValidationRuleType - Possible values include: 'ScriptParameterValidationRuleTypeScriptParameterValidationRule', 'ScriptParameterValidationRuleTypeDateTimeOptionsSet', 'ScriptParameterValidationRuleTypeDateTimeRange', 'ScriptParameterValidationRuleTypeFloatOptionsSet', 'ScriptParameterValidationRuleTypeFloatRange', 'ScriptParameterValidationRuleTypeIntegerOptionsSet', 'ScriptParameterValidationRuleTypeIntegerRange', 'ScriptParameterValidationRuleTypeRegularExpression', 'ScriptParameterValidationRuleTypeStringLengthRange', 'ScriptParameterValidationRuleTypeStringOptionsSet'
	ScriptParameterValidationRuleType ScriptParameterValidationRuleType `json:"scriptParameterValidationRuleType,omitempty"`
}

// MarshalJSON is the custom marshaler for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) MarshalJSON() ([]byte, error) {
	sosspr.ScriptParameterValidationRuleType = ScriptParameterValidationRuleTypeStringOptionsSet
	objectMap := make(map[string]interface{})
	if sosspr.Options != nil {
		objectMap["options"] = sosspr.Options
	}
	if sosspr.ScriptParameterValidationRuleType != "" {
		objectMap["scriptParameterValidationRuleType"] = sosspr.ScriptParameterValidationRuleType
	}
	return json.Marshal(objectMap)
}

// AsDateTimeOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsDateTimeOptionsSetScriptParameterRule() (*DateTimeOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsDateTimeRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsDateTimeRangeScriptParameterRule() (*DateTimeRangeScriptParameterRule, bool) {
	return nil, false
}

// AsFloatOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsFloatOptionsSetScriptParameterRule() (*FloatOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsFloatRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsFloatRangeScriptParameterRule() (*FloatRangeScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsIntegerOptionsSetScriptParameterRule() (*IntegerOptionsSetScriptParameterRule, bool) {
	return nil, false
}

// AsIntegerRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsIntegerRangeScriptParameterRule() (*IntegerRangeScriptParameterRule, bool) {
	return nil, false
}

// AsRegularExpressionScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsRegularExpressionScriptParameterRule() (*RegularExpressionScriptParameterRule, bool) {
	return nil, false
}

// AsStringLengthRangeScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsStringLengthRangeScriptParameterRule() (*StringLengthRangeScriptParameterRule, bool) {
	return nil, false
}

// AsStringOptionsSetScriptParameterRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsStringOptionsSetScriptParameterRule() (*StringOptionsSetScriptParameterRule, bool) {
	return &sosspr, true
}

// AsScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsScriptParameterValidationRule() (*ScriptParameterValidationRule, bool) {
	return nil, false
}

// AsBasicScriptParameterValidationRule is the BasicScriptParameterValidationRule implementation for StringOptionsSetScriptParameterRule.
func (sosspr StringOptionsSetScriptParameterRule) AsBasicScriptParameterValidationRule() (BasicScriptParameterValidationRule, bool) {
	return &sosspr, true
}

// StringPipelineRunParameterAssignment pipeline run string parameter assignment
type StringPipelineRunParameterAssignment struct {
	// Value - Parameter value
	Value *string `json:"value,omitempty"`
	// PipelineParameterID - Pipeline parameter id
	PipelineParameterID *string `json:"pipelineParameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypePipelineRunParameterAssignment', 'ParameterTypeBoolean', 'ParameterTypeDateTime', 'ParameterTypeFloat', 'ParameterTypeInteger', 'ParameterTypeString'
	ParameterType ParameterTypeBasicPipelineRunParameterAssignment `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) MarshalJSON() ([]byte, error) {
	sprpa.ParameterType = ParameterTypeString
	objectMap := make(map[string]interface{})
	if sprpa.Value != nil {
		objectMap["value"] = sprpa.Value
	}
	if sprpa.PipelineParameterID != nil {
		objectMap["pipelineParameterId"] = sprpa.PipelineParameterID
	}
	if sprpa.ParameterType != "" {
		objectMap["parameterType"] = sprpa.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsBooleanPipelineRunParameterAssignment() (*BooleanPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsDateTimePipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsDateTimePipelineRunParameterAssignment() (*DateTimePipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsFloatPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsFloatPipelineRunParameterAssignment() (*FloatPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsIntegerPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsIntegerPipelineRunParameterAssignment() (*IntegerPipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsStringPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsStringPipelineRunParameterAssignment() (*StringPipelineRunParameterAssignment, bool) {
	return &sprpa, true
}

// AsPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsPipelineRunParameterAssignment() (*PipelineRunParameterAssignment, bool) {
	return nil, false
}

// AsBasicPipelineRunParameterAssignment is the BasicPipelineRunParameterAssignment implementation for StringPipelineRunParameterAssignment.
func (sprpa StringPipelineRunParameterAssignment) AsBasicPipelineRunParameterAssignment() (BasicPipelineRunParameterAssignment, bool) {
	return &sprpa, true
}

// StringScriptParameter script parameter of type string
type StringScriptParameter struct {
	// DefaultValue - Default parameter value
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Description - Parameter usage description
	Description *string `json:"description,omitempty"`
	// Name - Parameter name as it appears in the script
	Name *string `json:"name,omitempty"`
	// ParameterID - Parameter identifier
	ParameterID *string `json:"parameterId,omitempty"`
	// ParameterType - Possible values include: 'ParameterTypeBasicScriptParameterParameterTypeScriptParameter', 'ParameterTypeBasicScriptParameterParameterTypeBoolean', 'ParameterTypeBasicScriptParameterParameterTypeDateTime', 'ParameterTypeBasicScriptParameterParameterTypeFloat', 'ParameterTypeBasicScriptParameterParameterTypeInteger', 'ParameterTypeBasicScriptParameterParameterTypeString'
	ParameterType ParameterTypeBasicScriptParameter `json:"parameterType,omitempty"`
}

// MarshalJSON is the custom marshaler for StringScriptParameter.
func (ssp StringScriptParameter) MarshalJSON() ([]byte, error) {
	ssp.ParameterType = ParameterTypeBasicScriptParameterParameterTypeString
	objectMap := make(map[string]interface{})
	if ssp.DefaultValue != nil {
		objectMap["defaultValue"] = ssp.DefaultValue
	}
	if ssp.Description != nil {
		objectMap["description"] = ssp.Description
	}
	if ssp.Name != nil {
		objectMap["name"] = ssp.Name
	}
	if ssp.ParameterID != nil {
		objectMap["parameterId"] = ssp.ParameterID
	}
	if ssp.ParameterType != "" {
		objectMap["parameterType"] = ssp.ParameterType
	}
	return json.Marshal(objectMap)
}

// AsBooleanScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsBooleanScriptParameter() (*BooleanScriptParameter, bool) {
	return nil, false
}

// AsDateTimeScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsDateTimeScriptParameter() (*DateTimeScriptParameter, bool) {
	return nil, false
}

// AsFloatScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsFloatScriptParameter() (*FloatScriptParameter, bool) {
	return nil, false
}

// AsIntegerScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsIntegerScriptParameter() (*IntegerScriptParameter, bool) {
	return nil, false
}

// AsStringScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsStringScriptParameter() (*StringScriptParameter, bool) {
	return &ssp, true
}

// AsScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsScriptParameter() (*ScriptParameter, bool) {
	return nil, false
}

// AsBasicScriptParameter is the BasicScriptParameter implementation for StringScriptParameter.
func (ssp StringScriptParameter) AsBasicScriptParameter() (BasicScriptParameter, bool) {
	return &ssp, true
}

// BasicSubstepReference a reference to a sub-step
type BasicSubstepReference interface {
	AsDataMovementSubstepReference() (*DataMovementSubstepReference, bool)
	AsScriptExecutionSubstepReference() (*ScriptExecutionSubstepReference, bool)
	AsSubstepReference() (*SubstepReference, bool)
}

// SubstepReference a reference to a sub-step
type SubstepReference struct {
	// PipelineStepName - READ-ONLY; The name of the Pipeline Step Run which contains the referred sub-step
	PipelineStepName *string `json:"pipelineStepName,omitempty"`
	// PipelineSubstepID - READ-ONLY; The Id of the Sub-step
	PipelineSubstepID *string `json:"pipelineSubstepId,omitempty"`
	// Kind - Possible values include: 'KindSubstepReference', 'KindDataMovement', 'KindScriptExecution'
	Kind KindBasicSubstepReference `json:"kind,omitempty"`
}

func unmarshalBasicSubstepReference(body []byte) (BasicSubstepReference, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindDataMovement):
		var dmsr DataMovementSubstepReference
		err := json.Unmarshal(body, &dmsr)
		return dmsr, err
	case string(KindScriptExecution):
		var sesr ScriptExecutionSubstepReference
		err := json.Unmarshal(body, &sesr)
		return sesr, err
	default:
		var sr SubstepReference
		err := json.Unmarshal(body, &sr)
		return sr, err
	}
}
func unmarshalBasicSubstepReferenceArray(body []byte) ([]BasicSubstepReference, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	srArray := make([]BasicSubstepReference, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sr, err := unmarshalBasicSubstepReference(*rawMessage)
		if err != nil {
			return nil, err
		}
		srArray[index] = sr
	}
	return srArray, nil
}

// MarshalJSON is the custom marshaler for SubstepReference.
func (sr SubstepReference) MarshalJSON() ([]byte, error) {
	sr.Kind = KindSubstepReference
	objectMap := make(map[string]interface{})
	if sr.Kind != "" {
		objectMap["kind"] = sr.Kind
	}
	return json.Marshal(objectMap)
}

// AsDataMovementSubstepReference is the BasicSubstepReference implementation for SubstepReference.
func (sr SubstepReference) AsDataMovementSubstepReference() (*DataMovementSubstepReference, bool) {
	return nil, false
}

// AsScriptExecutionSubstepReference is the BasicSubstepReference implementation for SubstepReference.
func (sr SubstepReference) AsScriptExecutionSubstepReference() (*ScriptExecutionSubstepReference, bool) {
	return nil, false
}

// AsSubstepReference is the BasicSubstepReference implementation for SubstepReference.
func (sr SubstepReference) AsSubstepReference() (*SubstepReference, bool) {
	return &sr, true
}

// AsBasicSubstepReference is the BasicSubstepReference implementation for SubstepReference.
func (sr SubstepReference) AsBasicSubstepReference() (BasicSubstepReference, bool) {
	return &sr, true
}

// SynapseSparkInformation information about the Synapse Spark
type SynapseSparkInformation struct {
	// SparkPoolExecutionInformation - The Spark pool execution information
	SparkPoolExecutionInformation *SparkPoolExecutionInformation `json:"sparkPoolExecutionInformation,omitempty"`
	// SparkPoolInformation - The Spark pool information
	SparkPoolInformation *SparkPoolInformation `json:"sparkPoolInformation,omitempty"`
}

// SynapseSparkPipelineStep a Synapse Spark based pipeline step.
type SynapseSparkPipelineStep struct {
	// SynapseSparkPipelineStepProperties - Properties of Synapse Spark pipelineStep
	*SynapseSparkPipelineStepProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindPipelineStep', 'KindSynapseSpark'
	Kind KindBasicPipelineStep `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) MarshalJSON() ([]byte, error) {
	ssps.Kind = KindSynapseSpark
	objectMap := make(map[string]interface{})
	if ssps.SynapseSparkPipelineStepProperties != nil {
		objectMap["properties"] = ssps.SynapseSparkPipelineStepProperties
	}
	if ssps.Kind != "" {
		objectMap["kind"] = ssps.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool) {
	return &ssps, true
}

// AsPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsPipelineStep() (*PipelineStep, bool) {
	return nil, false
}

// AsBasicPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsBasicPipelineStep() (BasicPipelineStep, bool) {
	return &ssps, true
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkPipelineStep struct.
func (ssps *SynapseSparkPipelineStep) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var synapseSparkPipelineStepProperties SynapseSparkPipelineStepProperties
				err = json.Unmarshal(*v, &synapseSparkPipelineStepProperties)
				if err != nil {
					return err
				}
				ssps.SynapseSparkPipelineStepProperties = &synapseSparkPipelineStepProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicPipelineStep
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssps.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssps.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssps.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ssps.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssps.Type = &typeVar
			}
		}
	}

	return nil
}

// SynapseSparkPipelineStepProperties a Synapse Spark PipelineStep data transfer object.
type SynapseSparkPipelineStepProperties struct {
	// Dependencies - List of other steps names, in the same pipeline, which this step is depended on
	// and should run only when they finish.
	Dependencies *[]string `json:"dependencies,omitempty"`
	// DiagnosticsLogBindings - Bindings between the diagnostics logs and data assets
	DiagnosticsLogBindings *[]BasicDiagnosticsLog `json:"diagnosticsLogBindings,omitempty"`
	// ExecutorNodeSize - The node size to use per executor. Possible values include: 'None', 'Small', 'Medium', 'Large', 'XLarge', 'XXLarge', 'XXXLarge'
	ExecutorNodeSize ExecutorNodeSize `json:"executorNodeSize,omitempty"`
	// ExecutorsCount - Number of executors to execute this step.
	ExecutorsCount *int32 `json:"executorsCount,omitempty"`
	// ScriptExecutionTimeout - The upper boundary of script execution time. Pattern: ((\\d+)\\.)?(\\d\\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	ScriptExecutionTimeout *string `json:"scriptExecutionTimeout,omitempty"`
	// ScriptID - The script Id that the pipeline step should execute
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptParameterBindings - Binding between the script parameter and pipeline parameters
	ScriptParameterBindings *[]ScriptParameterBinding `json:"scriptParameterBindings,omitempty"`
	// ScriptParameters - List of pipeline step level script parameters
	ScriptParameters *[]BasicScriptParameter `json:"scriptParameters,omitempty"`
	// ScriptRevision - The script's revision that the pipeline step should execute
	ScriptRevision *int32 `json:"scriptRevision,omitempty"`
	// ScriptSinkBindings - Bindings between the script's sink keys and data assets
	ScriptSinkBindings *[]ScriptDataAssetBinding `json:"scriptSinkBindings,omitempty"`
	// ScriptSourceBindings - Bindings between the script's source keys and data assets
	ScriptSourceBindings *[]ScriptDataAssetBinding `json:"scriptSourceBindings,omitempty"`
	// SynapseSparkPoolID - The Synapse Spark pool that will execute this step
	SynapseSparkPoolID *string `json:"synapseSparkPoolId,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkPipelineStepProperties struct.
func (sspsp *SynapseSparkPipelineStepProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "dependencies":
			if v != nil {
				var dependencies []string
				err = json.Unmarshal(*v, &dependencies)
				if err != nil {
					return err
				}
				sspsp.Dependencies = &dependencies
			}
		case "diagnosticsLogBindings":
			if v != nil {
				diagnosticsLogBindings, err := unmarshalBasicDiagnosticsLogArray(*v)
				if err != nil {
					return err
				}
				sspsp.DiagnosticsLogBindings = &diagnosticsLogBindings
			}
		case "executorNodeSize":
			if v != nil {
				var executorNodeSize ExecutorNodeSize
				err = json.Unmarshal(*v, &executorNodeSize)
				if err != nil {
					return err
				}
				sspsp.ExecutorNodeSize = executorNodeSize
			}
		case "executorsCount":
			if v != nil {
				var executorsCount int32
				err = json.Unmarshal(*v, &executorsCount)
				if err != nil {
					return err
				}
				sspsp.ExecutorsCount = &executorsCount
			}
		case "scriptExecutionTimeout":
			if v != nil {
				var scriptExecutionTimeout string
				err = json.Unmarshal(*v, &scriptExecutionTimeout)
				if err != nil {
					return err
				}
				sspsp.ScriptExecutionTimeout = &scriptExecutionTimeout
			}
		case "scriptId":
			if v != nil {
				var scriptID string
				err = json.Unmarshal(*v, &scriptID)
				if err != nil {
					return err
				}
				sspsp.ScriptID = &scriptID
			}
		case "scriptParameterBindings":
			if v != nil {
				var scriptParameterBindings []ScriptParameterBinding
				err = json.Unmarshal(*v, &scriptParameterBindings)
				if err != nil {
					return err
				}
				sspsp.ScriptParameterBindings = &scriptParameterBindings
			}
		case "scriptParameters":
			if v != nil {
				scriptParameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				sspsp.ScriptParameters = &scriptParameters
			}
		case "scriptRevision":
			if v != nil {
				var scriptRevision int32
				err = json.Unmarshal(*v, &scriptRevision)
				if err != nil {
					return err
				}
				sspsp.ScriptRevision = &scriptRevision
			}
		case "scriptSinkBindings":
			if v != nil {
				var scriptSinkBindings []ScriptDataAssetBinding
				err = json.Unmarshal(*v, &scriptSinkBindings)
				if err != nil {
					return err
				}
				sspsp.ScriptSinkBindings = &scriptSinkBindings
			}
		case "scriptSourceBindings":
			if v != nil {
				var scriptSourceBindings []ScriptDataAssetBinding
				err = json.Unmarshal(*v, &scriptSourceBindings)
				if err != nil {
					return err
				}
				sspsp.ScriptSourceBindings = &scriptSourceBindings
			}
		case "synapseSparkPoolId":
			if v != nil {
				var synapseSparkPoolID string
				err = json.Unmarshal(*v, &synapseSparkPoolID)
				if err != nil {
					return err
				}
				sspsp.SynapseSparkPoolID = &synapseSparkPoolID
			}
		}
	}

	return nil
}

// SynapseSparkPool synapse Spark Pool constrained resource
type SynapseSparkPool struct {
	// SynapseSparkPoolProperties - Properties of Synapse Spark pool
	*SynapseSparkPoolProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindConstrainedResource', 'KindSynapseSparkPool'
	Kind KindBasicConstrainedResource `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkPool.
func (ssp SynapseSparkPool) MarshalJSON() ([]byte, error) {
	ssp.Kind = KindSynapseSparkPool
	objectMap := make(map[string]interface{})
	if ssp.SynapseSparkPoolProperties != nil {
		objectMap["properties"] = ssp.SynapseSparkPoolProperties
	}
	if ssp.Kind != "" {
		objectMap["kind"] = ssp.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPool is the BasicConstrainedResource implementation for SynapseSparkPool.
func (ssp SynapseSparkPool) AsSynapseSparkPool() (*SynapseSparkPool, bool) {
	return &ssp, true
}

// AsConstrainedResource is the BasicConstrainedResource implementation for SynapseSparkPool.
func (ssp SynapseSparkPool) AsConstrainedResource() (*ConstrainedResource, bool) {
	return nil, false
}

// AsBasicConstrainedResource is the BasicConstrainedResource implementation for SynapseSparkPool.
func (ssp SynapseSparkPool) AsBasicConstrainedResource() (BasicConstrainedResource, bool) {
	return &ssp, true
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkPool struct.
func (ssp *SynapseSparkPool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var synapseSparkPoolProperties SynapseSparkPoolProperties
				err = json.Unmarshal(*v, &synapseSparkPoolProperties)
				if err != nil {
					return err
				}
				ssp.SynapseSparkPoolProperties = &synapseSparkPoolProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicConstrainedResource
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssp.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssp.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ssp.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssp.Type = &typeVar
			}
		}
	}

	return nil
}

// SynapseSparkPoolAutoPauseProperties spark pool auto-pausing properties
type SynapseSparkPoolAutoPauseProperties struct {
	// DelayInMinutes - Gets or sets number of minutes of idle time before the Big Data
	// pool is automatically paused.
	DelayInMinutes *int32 `json:"delayInMinutes,omitempty"`
	// Enabled - Gets or sets whether auto-pausing is enabled for the Big Data pool.
	Enabled *bool `json:"enabled,omitempty"`
}

// SynapseSparkPoolAutoScaleProperties spark pool auto-scaling properties
type SynapseSparkPoolAutoScaleProperties struct {
	// Enabled - Gets or sets whether automatic scaling is enabled for the Big Data
	// pool.
	Enabled *bool `json:"enabled,omitempty"`
	// MaxNodeCount - Gets or sets the maximum number of nodes the Big Data pool can
	// support.
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`
	// MinNodeCount - Gets or sets the minimum number of nodes the Big Data pool can
	// support.
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
}

// SynapseSparkPoolLibraryRequirementsProperties spark pool library requirements properties
type SynapseSparkPoolLibraryRequirementsProperties struct {
	// Content - Gets or sets the library requirements.
	Content *string `json:"content,omitempty"`
}

// SynapseSparkPoolProperties a Synapse Spark Pool data transfer object.
type SynapseSparkPoolProperties struct {
	// AutoPause - Gets or sets auto-pausing properties
	AutoPause *SynapseSparkPoolAutoPauseProperties `json:"autoPause,omitempty"`
	// AutoScale - Gets or sets auto-scaling properties
	AutoScale *SynapseSparkPoolAutoScaleProperties `json:"autoScale,omitempty"`
	// ConstrainedResourceID - READ-ONLY; Unique id for identifying a constrained resource
	ConstrainedResourceID *string `json:"constrainedResourceId,omitempty"`
	// Family - READ-ONLY; Family of constrained resource. Possible values include: 'Compute', 'Storage'
	Family Family `json:"family,omitempty"`
	// LibraryRequirements - Gets or sets library requirements properties
	LibraryRequirements *SynapseSparkPoolLibraryRequirementsProperties `json:"libraryRequirements,omitempty"`
	// NodeCount - Gets or sets the number of nodes in the Big Data pool.
	NodeCount *int32 `json:"nodeCount,omitempty"`
	// NodeSize - Gets or sets the level of compute power that each node in the Synapse Spark pool has. Possible values include: 'NodeSizeNone', 'NodeSizeSmall', 'NodeSizeMedium', 'NodeSizeLarge', 'NodeSizeXLarge', 'NodeSizeXXLarge', 'NodeSizeXXXLarge'
	NodeSize NodeSize `json:"nodeSize,omitempty"`
	// NodeSizeFamily - Gets or sets the kind of nodes that the Big Data pool provides. Possible values include: 'NodeSizeFamilyNone', 'NodeSizeFamilyMemoryOptimized'
	NodeSizeFamily NodeSizeFamily `json:"nodeSizeFamily,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the constrained resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// SparkVersion - Gets or sets the Apache Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkPoolProperties.
func (sspp SynapseSparkPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sspp.AutoPause != nil {
		objectMap["autoPause"] = sspp.AutoPause
	}
	if sspp.AutoScale != nil {
		objectMap["autoScale"] = sspp.AutoScale
	}
	if sspp.LibraryRequirements != nil {
		objectMap["libraryRequirements"] = sspp.LibraryRequirements
	}
	if sspp.NodeCount != nil {
		objectMap["nodeCount"] = sspp.NodeCount
	}
	if sspp.NodeSize != "" {
		objectMap["nodeSize"] = sspp.NodeSize
	}
	if sspp.NodeSizeFamily != "" {
		objectMap["nodeSizeFamily"] = sspp.NodeSizeFamily
	}
	if sspp.SparkVersion != nil {
		objectMap["sparkVersion"] = sspp.SparkVersion
	}
	return json.Marshal(objectMap)
}

// SynapseSparkScript a type of script based on the compute engine
type SynapseSparkScript struct {
	// SynapseSparkScriptProperties - Properties of Synapse Spark script
	*SynapseSparkScriptProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindBasicScriptKindScript', 'KindBasicScriptKindSynapseSpark'
	Kind KindBasicScript `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkScript.
func (sss SynapseSparkScript) MarshalJSON() ([]byte, error) {
	sss.Kind = KindBasicScriptKindSynapseSpark
	objectMap := make(map[string]interface{})
	if sss.SynapseSparkScriptProperties != nil {
		objectMap["properties"] = sss.SynapseSparkScriptProperties
	}
	if sss.Kind != "" {
		objectMap["kind"] = sss.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsSynapseSparkScript() (*SynapseSparkScript, bool) {
	return &sss, true
}

// AsScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsScript() (*Script, bool) {
	return nil, false
}

// AsBasicScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsBasicScript() (BasicScript, bool) {
	return &sss, true
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkScript struct.
func (sss *SynapseSparkScript) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var synapseSparkScriptProperties SynapseSparkScriptProperties
				err = json.Unmarshal(*v, &synapseSparkScriptProperties)
				if err != nil {
					return err
				}
				sss.SynapseSparkScriptProperties = &synapseSparkScriptProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicScript
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sss.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sss.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sss.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sss.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sss.Type = &typeVar
			}
		}
	}

	return nil
}

// SynapseSparkScriptProperties a Synapse Spark Script data transfer object.
type SynapseSparkScriptProperties struct {
	// Content - The script content
	Content *string `json:"content,omitempty"`
	// Language - The script language
	Language *string `json:"language,omitempty"`
	// Parameters - The list of overridable script parameters
	Parameters *[]BasicScriptParameter `json:"parameters,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the script. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Purpose - Script purpose. Possible values include: 'Body', 'InputAdapter', 'OutputAdapter'
	Purpose Purpose `json:"purpose,omitempty"`
	// Revision - READ-ONLY; Latest script revision
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - READ-ONLY; Unique id for identifying a script resource
	ScriptID *string `json:"scriptId,omitempty"`
	// Sinks - The list of parameters the script can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - The list of parameters the script can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
	// Visibility - Script visibility mode. Possible values include: 'VisibilityShowAll', 'VisibilityHiddenContent'
	Visibility Visibility `json:"visibility,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkScriptProperties.
func (sssp SynapseSparkScriptProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sssp.Content != nil {
		objectMap["content"] = sssp.Content
	}
	if sssp.Language != nil {
		objectMap["language"] = sssp.Language
	}
	if sssp.Parameters != nil {
		objectMap["parameters"] = sssp.Parameters
	}
	if sssp.Purpose != "" {
		objectMap["purpose"] = sssp.Purpose
	}
	if sssp.Sinks != nil {
		objectMap["sinks"] = sssp.Sinks
	}
	if sssp.Sources != nil {
		objectMap["sources"] = sssp.Sources
	}
	if sssp.Visibility != "" {
		objectMap["visibility"] = sssp.Visibility
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkScriptProperties struct.
func (sssp *SynapseSparkScriptProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "content":
			if v != nil {
				var content string
				err = json.Unmarshal(*v, &content)
				if err != nil {
					return err
				}
				sssp.Content = &content
			}
		case "language":
			if v != nil {
				var language string
				err = json.Unmarshal(*v, &language)
				if err != nil {
					return err
				}
				sssp.Language = &language
			}
		case "parameters":
			if v != nil {
				parameters, err := unmarshalBasicScriptParameterArray(*v)
				if err != nil {
					return err
				}
				sssp.Parameters = &parameters
			}
		case "provisioningState":
			if v != nil {
				var provisioningState ProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				sssp.ProvisioningState = provisioningState
			}
		case "purpose":
			if v != nil {
				var purpose Purpose
				err = json.Unmarshal(*v, &purpose)
				if err != nil {
					return err
				}
				sssp.Purpose = purpose
			}
		case "revision":
			if v != nil {
				var revision int32
				err = json.Unmarshal(*v, &revision)
				if err != nil {
					return err
				}
				sssp.Revision = &revision
			}
		case "scriptId":
			if v != nil {
				var scriptID string
				err = json.Unmarshal(*v, &scriptID)
				if err != nil {
					return err
				}
				sssp.ScriptID = &scriptID
			}
		case "sinks":
			if v != nil {
				var sinks []string
				err = json.Unmarshal(*v, &sinks)
				if err != nil {
					return err
				}
				sssp.Sinks = &sinks
			}
		case "sources":
			if v != nil {
				var sources []string
				err = json.Unmarshal(*v, &sources)
				if err != nil {
					return err
				}
				sssp.Sources = &sources
			}
		case "visibility":
			if v != nil {
				var visibility Visibility
				err = json.Unmarshal(*v, &visibility)
				if err != nil {
					return err
				}
				sssp.Visibility = visibility
			}
		}
	}

	return nil
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedAt - READ-ONLY; The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// CreatedBy - READ-ONLY; The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - READ-ONLY; The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// LastModifiedAt - READ-ONLY; The type of identity that last modified the resource.
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
	// LastModifiedBy - READ-ONLY; The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - READ-ONLY; The type of identity that last modified the resource. Possible values include: 'LastModifiedByTypeUser', 'LastModifiedByTypeApplication', 'LastModifiedByTypeManagedIdentity', 'LastModifiedByTypeKey'
	LastModifiedByType LastModifiedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON is the custom marshaler for SystemData.
func (sd SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VirtualOutputReference reference to a virtual output.
type VirtualOutputReference struct {
	autorest.Response `json:"-"`
	// VirtualOutputReferenceProperties - Properties on the output reference
	*VirtualOutputReferenceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualOutputReference.
func (vor VirtualOutputReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vor.VirtualOutputReferenceProperties != nil {
		objectMap["properties"] = vor.VirtualOutputReferenceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualOutputReference struct.
func (vor *VirtualOutputReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualOutputReferenceProperties VirtualOutputReferenceProperties
				err = json.Unmarshal(*v, &virtualOutputReferenceProperties)
				if err != nil {
					return err
				}
				vor.VirtualOutputReferenceProperties = &virtualOutputReferenceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vor.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vor.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vor.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vor.Type = &typeVar
			}
		}
	}

	return nil
}

// VirtualOutputReferenceList list response for get output references
type VirtualOutputReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]VirtualOutputReference `json:"value,omitempty"`
}

// VirtualOutputReferenceListIterator provides access to a complete listing of VirtualOutputReference
// values.
type VirtualOutputReferenceListIterator struct {
	i    int
	page VirtualOutputReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualOutputReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualOutputReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualOutputReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualOutputReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualOutputReferenceListIterator) Response() VirtualOutputReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualOutputReferenceListIterator) Value() VirtualOutputReference {
	if !iter.page.NotDone() {
		return VirtualOutputReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualOutputReferenceListIterator type.
func NewVirtualOutputReferenceListIterator(page VirtualOutputReferenceListPage) VirtualOutputReferenceListIterator {
	return VirtualOutputReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vorl VirtualOutputReferenceList) IsEmpty() bool {
	return vorl.Value == nil || len(*vorl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vorl VirtualOutputReferenceList) hasNextLink() bool {
	return vorl.NextLink != nil && len(*vorl.NextLink) != 0
}

// virtualOutputReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vorl VirtualOutputReferenceList) virtualOutputReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !vorl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vorl.NextLink)))
}

// VirtualOutputReferenceListPage contains a page of VirtualOutputReference values.
type VirtualOutputReferenceListPage struct {
	fn   func(context.Context, VirtualOutputReferenceList) (VirtualOutputReferenceList, error)
	vorl VirtualOutputReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualOutputReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualOutputReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vorl)
		if err != nil {
			return err
		}
		page.vorl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualOutputReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualOutputReferenceListPage) NotDone() bool {
	return !page.vorl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualOutputReferenceListPage) Response() VirtualOutputReferenceList {
	return page.vorl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualOutputReferenceListPage) Values() []VirtualOutputReference {
	if page.vorl.IsEmpty() {
		return nil
	}
	return *page.vorl.Value
}

// Creates a new instance of the VirtualOutputReferenceListPage type.
func NewVirtualOutputReferenceListPage(cur VirtualOutputReferenceList, getNextPage func(context.Context, VirtualOutputReferenceList) (VirtualOutputReferenceList, error)) VirtualOutputReferenceListPage {
	return VirtualOutputReferenceListPage{
		fn:   getNextPage,
		vorl: cur,
	}
}

// VirtualOutputReferenceProperties properties of virtual output reference data transfer object.
type VirtualOutputReferenceProperties struct {
	// OutputPolicyResourceID - READ-ONLY; Azure resource id of the referenced output policy
	OutputPolicyResourceID *string `json:"outputPolicyResourceId,omitempty"`
	// VirtualOutputReferenceID - READ-ONLY; Unique id for identifying a virtual output reference resource
	VirtualOutputReferenceID *string `json:"virtualOutputReferenceId,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualOutputReferenceProperties.
func (vorp VirtualOutputReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Workspace workspace to hold data collaboration workloads.
type Workspace struct {
	autorest.Response `json:"-"`
	// Identity - Identity Info on the Workspace
	Identity *Identity `json:"identity,omitempty"`
	// WorkspaceProperties - Properties on the workspace
	*WorkspaceProperties `json:"properties,omitempty"`
	// Location - Location of the azure resource.
	Location *string `json:"location,omitempty"`
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// SystemData - READ-ONLY; System Data of the Azure resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.Identity != nil {
		objectMap["identity"] = w.Identity
	}
	if w.WorkspaceProperties != nil {
		objectMap["properties"] = w.WorkspaceProperties
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workspace struct.
func (w *Workspace) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity Identity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				w.Identity = &identity
			}
		case "properties":
			if v != nil {
				var workspaceProperties WorkspaceProperties
				err = json.Unmarshal(*v, &workspaceProperties)
				if err != nil {
					return err
				}
				w.WorkspaceProperties = &workspaceProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				w.SystemData = &systemData
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		}
	}

	return nil
}

// WorkspaceList list response for get Workspaces.
type WorkspaceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Workspace `json:"value,omitempty"`
}

// WorkspaceListIterator provides access to a complete listing of Workspace values.
type WorkspaceListIterator struct {
	i    int
	page WorkspaceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkspaceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkspaceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkspaceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkspaceListIterator) Response() WorkspaceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkspaceListIterator) Value() Workspace {
	if !iter.page.NotDone() {
		return Workspace{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkspaceListIterator type.
func NewWorkspaceListIterator(page WorkspaceListPage) WorkspaceListIterator {
	return WorkspaceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wl WorkspaceList) IsEmpty() bool {
	return wl.Value == nil || len(*wl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wl WorkspaceList) hasNextLink() bool {
	return wl.NextLink != nil && len(*wl.NextLink) != 0
}

// workspaceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wl WorkspaceList) workspaceListPreparer(ctx context.Context) (*http.Request, error) {
	if !wl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wl.NextLink)))
}

// WorkspaceListPage contains a page of Workspace values.
type WorkspaceListPage struct {
	fn func(context.Context, WorkspaceList) (WorkspaceList, error)
	wl WorkspaceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkspaceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wl)
		if err != nil {
			return err
		}
		page.wl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkspaceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkspaceListPage) NotDone() bool {
	return !page.wl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkspaceListPage) Response() WorkspaceList {
	return page.wl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkspaceListPage) Values() []Workspace {
	if page.wl.IsEmpty() {
		return nil
	}
	return *page.wl.Value
}

// Creates a new instance of the WorkspaceListPage type.
func NewWorkspaceListPage(cur WorkspaceList, getNextPage func(context.Context, WorkspaceList) (WorkspaceList, error)) WorkspaceListPage {
	return WorkspaceListPage{
		fn: getNextPage,
		wl: cur,
	}
}

// WorkspaceProperties workspace property bag.
type WorkspaceProperties struct {
	// DisplayName - Display name of the workspace
	DisplayName *string `json:"displayName,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the Workspace. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkspaceProperties.
func (wp WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wp.DisplayName != nil {
		objectMap["displayName"] = wp.DisplayName
	}
	return json.Marshal(objectMap)
}

// WorkspacesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WorkspacesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (Workspace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesCreateOrUpdateFuture.Result.
func (future *WorkspacesCreateOrUpdateFuture) result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		w.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.WorkspacesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.CreateOrUpdateResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesCreateOrUpdateFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (OperationResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesDeleteFuture.Result.
func (future *WorkspacesDeleteFuture) result(client WorkspacesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("datacollaboration.WorkspacesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspaceUpdateParameters update parameters for workspaces
type WorkspaceUpdateParameters struct {
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WorkspaceUpdateParameters.
func (wup WorkspaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wup.Tags != nil {
		objectMap["tags"] = wup.Tags
	}
	return json.Marshal(objectMap)
}
