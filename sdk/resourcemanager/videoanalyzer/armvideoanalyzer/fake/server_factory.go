//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
	"sync"
)

// ServerFactory is a fake server for instances of the armvideoanalyzer.ClientFactory type.
type ServerFactory struct {
	AccessPoliciesServer                              AccessPoliciesServer
	EdgeModulesServer                                 EdgeModulesServer
	LivePipelineOperationStatusesServer               LivePipelineOperationStatusesServer
	LivePipelinesServer                               LivePipelinesServer
	LocationsServer                                   LocationsServer
	OperationResultsServer                            OperationResultsServer
	OperationStatusesServer                           OperationStatusesServer
	OperationsServer                                  OperationsServer
	PipelineJobOperationStatusesServer                PipelineJobOperationStatusesServer
	PipelineJobsServer                                PipelineJobsServer
	PipelineTopologiesServer                          PipelineTopologiesServer
	PrivateEndpointConnectionsServer                  PrivateEndpointConnectionsServer
	PrivateEndpointConnectionsOperationResultsServer  PrivateEndpointConnectionsOperationResultsServer
	PrivateEndpointConnectionsOperationStatusesServer PrivateEndpointConnectionsOperationStatusesServer
	PrivateLinkResourcesServer                        PrivateLinkResourcesServer
	VideoAnalyzersServer                              VideoAnalyzersServer
	VideosServer                                      VideosServer
}

// NewServerFactoryTransport creates a new instance of ServerFactoryTransport with the provided implementation.
// The returned ServerFactoryTransport instance is connected to an instance of armvideoanalyzer.ClientFactory via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewServerFactoryTransport(srv *ServerFactory) *ServerFactoryTransport {
	return &ServerFactoryTransport{
		srv: srv,
	}
}

// ServerFactoryTransport connects instances of armvideoanalyzer.ClientFactory to instances of ServerFactory.
// Don't use this type directly, use NewServerFactoryTransport instead.
type ServerFactoryTransport struct {
	srv                                                 *ServerFactory
	trMu                                                sync.Mutex
	trAccessPoliciesServer                              *AccessPoliciesServerTransport
	trEdgeModulesServer                                 *EdgeModulesServerTransport
	trLivePipelineOperationStatusesServer               *LivePipelineOperationStatusesServerTransport
	trLivePipelinesServer                               *LivePipelinesServerTransport
	trLocationsServer                                   *LocationsServerTransport
	trOperationResultsServer                            *OperationResultsServerTransport
	trOperationStatusesServer                           *OperationStatusesServerTransport
	trOperationsServer                                  *OperationsServerTransport
	trPipelineJobOperationStatusesServer                *PipelineJobOperationStatusesServerTransport
	trPipelineJobsServer                                *PipelineJobsServerTransport
	trPipelineTopologiesServer                          *PipelineTopologiesServerTransport
	trPrivateEndpointConnectionsServer                  *PrivateEndpointConnectionsServerTransport
	trPrivateEndpointConnectionsOperationResultsServer  *PrivateEndpointConnectionsOperationResultsServerTransport
	trPrivateEndpointConnectionsOperationStatusesServer *PrivateEndpointConnectionsOperationStatusesServerTransport
	trPrivateLinkResourcesServer                        *PrivateLinkResourcesServerTransport
	trVideoAnalyzersServer                              *VideoAnalyzersServerTransport
	trVideosServer                                      *VideosServerTransport
}

// Do implements the policy.Transporter interface for ServerFactoryTransport.
func (s *ServerFactoryTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	client := method[:strings.Index(method, ".")]
	var resp *http.Response
	var err error

	switch client {
	case "AccessPoliciesClient":
		initServer(s, &s.trAccessPoliciesServer, func() *AccessPoliciesServerTransport {
			return NewAccessPoliciesServerTransport(&s.srv.AccessPoliciesServer)
		})
		resp, err = s.trAccessPoliciesServer.Do(req)
	case "EdgeModulesClient":
		initServer(s, &s.trEdgeModulesServer, func() *EdgeModulesServerTransport { return NewEdgeModulesServerTransport(&s.srv.EdgeModulesServer) })
		resp, err = s.trEdgeModulesServer.Do(req)
	case "LivePipelineOperationStatusesClient":
		initServer(s, &s.trLivePipelineOperationStatusesServer, func() *LivePipelineOperationStatusesServerTransport {
			return NewLivePipelineOperationStatusesServerTransport(&s.srv.LivePipelineOperationStatusesServer)
		})
		resp, err = s.trLivePipelineOperationStatusesServer.Do(req)
	case "LivePipelinesClient":
		initServer(s, &s.trLivePipelinesServer, func() *LivePipelinesServerTransport {
			return NewLivePipelinesServerTransport(&s.srv.LivePipelinesServer)
		})
		resp, err = s.trLivePipelinesServer.Do(req)
	case "LocationsClient":
		initServer(s, &s.trLocationsServer, func() *LocationsServerTransport { return NewLocationsServerTransport(&s.srv.LocationsServer) })
		resp, err = s.trLocationsServer.Do(req)
	case "OperationResultsClient":
		initServer(s, &s.trOperationResultsServer, func() *OperationResultsServerTransport {
			return NewOperationResultsServerTransport(&s.srv.OperationResultsServer)
		})
		resp, err = s.trOperationResultsServer.Do(req)
	case "OperationStatusesClient":
		initServer(s, &s.trOperationStatusesServer, func() *OperationStatusesServerTransport {
			return NewOperationStatusesServerTransport(&s.srv.OperationStatusesServer)
		})
		resp, err = s.trOperationStatusesServer.Do(req)
	case "OperationsClient":
		initServer(s, &s.trOperationsServer, func() *OperationsServerTransport { return NewOperationsServerTransport(&s.srv.OperationsServer) })
		resp, err = s.trOperationsServer.Do(req)
	case "PipelineJobOperationStatusesClient":
		initServer(s, &s.trPipelineJobOperationStatusesServer, func() *PipelineJobOperationStatusesServerTransport {
			return NewPipelineJobOperationStatusesServerTransport(&s.srv.PipelineJobOperationStatusesServer)
		})
		resp, err = s.trPipelineJobOperationStatusesServer.Do(req)
	case "PipelineJobsClient":
		initServer(s, &s.trPipelineJobsServer, func() *PipelineJobsServerTransport { return NewPipelineJobsServerTransport(&s.srv.PipelineJobsServer) })
		resp, err = s.trPipelineJobsServer.Do(req)
	case "PipelineTopologiesClient":
		initServer(s, &s.trPipelineTopologiesServer, func() *PipelineTopologiesServerTransport {
			return NewPipelineTopologiesServerTransport(&s.srv.PipelineTopologiesServer)
		})
		resp, err = s.trPipelineTopologiesServer.Do(req)
	case "PrivateEndpointConnectionsClient":
		initServer(s, &s.trPrivateEndpointConnectionsServer, func() *PrivateEndpointConnectionsServerTransport {
			return NewPrivateEndpointConnectionsServerTransport(&s.srv.PrivateEndpointConnectionsServer)
		})
		resp, err = s.trPrivateEndpointConnectionsServer.Do(req)
	case "PrivateEndpointConnectionsOperationResultsClient":
		initServer(s, &s.trPrivateEndpointConnectionsOperationResultsServer, func() *PrivateEndpointConnectionsOperationResultsServerTransport {
			return NewPrivateEndpointConnectionsOperationResultsServerTransport(&s.srv.PrivateEndpointConnectionsOperationResultsServer)
		})
		resp, err = s.trPrivateEndpointConnectionsOperationResultsServer.Do(req)
	case "PrivateEndpointConnectionsOperationStatusesClient":
		initServer(s, &s.trPrivateEndpointConnectionsOperationStatusesServer, func() *PrivateEndpointConnectionsOperationStatusesServerTransport {
			return NewPrivateEndpointConnectionsOperationStatusesServerTransport(&s.srv.PrivateEndpointConnectionsOperationStatusesServer)
		})
		resp, err = s.trPrivateEndpointConnectionsOperationStatusesServer.Do(req)
	case "PrivateLinkResourcesClient":
		initServer(s, &s.trPrivateLinkResourcesServer, func() *PrivateLinkResourcesServerTransport {
			return NewPrivateLinkResourcesServerTransport(&s.srv.PrivateLinkResourcesServer)
		})
		resp, err = s.trPrivateLinkResourcesServer.Do(req)
	case "VideoAnalyzersClient":
		initServer(s, &s.trVideoAnalyzersServer, func() *VideoAnalyzersServerTransport {
			return NewVideoAnalyzersServerTransport(&s.srv.VideoAnalyzersServer)
		})
		resp, err = s.trVideoAnalyzersServer.Do(req)
	case "VideosClient":
		initServer(s, &s.trVideosServer, func() *VideosServerTransport { return NewVideosServerTransport(&s.srv.VideosServer) })
		resp, err = s.trVideosServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func initServer[T any](s *ServerFactoryTransport, dst **T, src func() *T) {
	s.trMu.Lock()
	if *dst == nil {
		*dst = src()
	}
	s.trMu.Unlock()
}
