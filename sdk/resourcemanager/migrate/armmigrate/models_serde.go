//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package armmigrate

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AgentConfiguration.
func (a AgentConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentId", a.AgentID)
	populate(objectMap, "clockGranularity", a.ClockGranularity)
	populate(objectMap, "dependencyAgentId", a.DependencyAgentID)
	populate(objectMap, "dependencyAgentRevision", a.DependencyAgentRevision)
	populate(objectMap, "dependencyAgentVersion", a.DependencyAgentVersion)
	populate(objectMap, "rebootStatus", a.RebootStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AgentConfiguration.
func (a *AgentConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentId":
			err = unpopulate(val, "AgentID", &a.AgentID)
			delete(rawMsg, key)
		case "clockGranularity":
			err = unpopulate(val, "ClockGranularity", &a.ClockGranularity)
			delete(rawMsg, key)
		case "dependencyAgentId":
			err = unpopulate(val, "DependencyAgentID", &a.DependencyAgentID)
			delete(rawMsg, key)
		case "dependencyAgentRevision":
			err = unpopulate(val, "DependencyAgentRevision", &a.DependencyAgentRevision)
			delete(rawMsg, key)
		case "dependencyAgentVersion":
			err = unpopulate(val, "DependencyAgentVersion", &a.DependencyAgentVersion)
			delete(rawMsg, key)
		case "rebootStatus":
			err = unpopulate(val, "RebootStatus", &a.RebootStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Application.
func (a Application) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "provider", a.Provider)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Application.
func (a *Application) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &a.Provider)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppsAndRoles.
func (a AppsAndRoles) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applications", a.Applications)
	populate(objectMap, "bizTalkServers", a.BizTalkServers)
	populate(objectMap, "exchangeServers", a.ExchangeServers)
	populate(objectMap, "features", a.Features)
	populate(objectMap, "otherDatabases", a.OtherDatabases)
	populate(objectMap, "sqlServers", a.SQLServers)
	populate(objectMap, "sharePointServers", a.SharePointServers)
	populate(objectMap, "systemCenters", a.SystemCenters)
	populate(objectMap, "webApplications", a.WebApplications)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppsAndRoles.
func (a *AppsAndRoles) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applications":
			err = unpopulate(val, "Applications", &a.Applications)
			delete(rawMsg, key)
		case "bizTalkServers":
			err = unpopulate(val, "BizTalkServers", &a.BizTalkServers)
			delete(rawMsg, key)
		case "exchangeServers":
			err = unpopulate(val, "ExchangeServers", &a.ExchangeServers)
			delete(rawMsg, key)
		case "features":
			err = unpopulate(val, "Features", &a.Features)
			delete(rawMsg, key)
		case "otherDatabases":
			err = unpopulate(val, "OtherDatabases", &a.OtherDatabases)
			delete(rawMsg, key)
		case "sqlServers":
			err = unpopulate(val, "SQLServers", &a.SQLServers)
			delete(rawMsg, key)
		case "sharePointServers":
			err = unpopulate(val, "SharePointServers", &a.SharePointServers)
			delete(rawMsg, key)
		case "systemCenters":
			err = unpopulate(val, "SystemCenters", &a.SystemCenters)
			delete(rawMsg, key)
		case "webApplications":
			err = unpopulate(val, "WebApplications", &a.WebApplications)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOperations.
func (a AvailableOperations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableOperations.
func (a *AvailableOperations) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BizTalkServer.
func (b BizTalkServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "productName", b.ProductName)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BizTalkServer.
func (b *BizTalkServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "productName":
			err = unpopulate(val, "ProductName", &b.ProductName)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetails.
func (e ErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentErrorCode", e.AgentErrorCode)
	populate(objectMap, "agentErrorMessage", e.AgentErrorMessage)
	populate(objectMap, "agentErrorPossibleCauses", e.AgentErrorPossibleCauses)
	populate(objectMap, "agentErrorRecommendedAction", e.AgentErrorRecommendedAction)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "isAgentReportedError", e.IsAgentReportedError)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "possibleCauses", e.PossibleCauses)
	populate(objectMap, "recommendedAction", e.RecommendedAction)
	populate(objectMap, "severity", e.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetails.
func (e *ErrorDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentErrorCode":
			err = unpopulate(val, "AgentErrorCode", &e.AgentErrorCode)
			delete(rawMsg, key)
		case "agentErrorMessage":
			err = unpopulate(val, "AgentErrorMessage", &e.AgentErrorMessage)
			delete(rawMsg, key)
		case "agentErrorPossibleCauses":
			err = unpopulate(val, "AgentErrorPossibleCauses", &e.AgentErrorPossibleCauses)
			delete(rawMsg, key)
		case "agentErrorRecommendedAction":
			err = unpopulate(val, "AgentErrorRecommendedAction", &e.AgentErrorRecommendedAction)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "isAgentReportedError":
			err = unpopulate(val, "IsAgentReportedError", &e.IsAgentReportedError)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "possibleCauses":
			err = unpopulate(val, "PossibleCauses", &e.PossibleCauses)
			delete(rawMsg, key)
		case "recommendedAction":
			err = unpopulate(val, "RecommendedAction", &e.RecommendedAction)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &e.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExchangeServer.
func (e ExchangeServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "edition", e.Edition)
	populate(objectMap, "productName", e.ProductName)
	populate(objectMap, "roles", e.Roles)
	populate(objectMap, "servicePack", e.ServicePack)
	populate(objectMap, "version", e.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExchangeServer.
func (e *ExchangeServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "edition":
			err = unpopulate(val, "Edition", &e.Edition)
			delete(rawMsg, key)
		case "productName":
			err = unpopulate(val, "ProductName", &e.ProductName)
			delete(rawMsg, key)
		case "roles":
			err = unpopulate(val, "Roles", &e.Roles)
			delete(rawMsg, key)
		case "servicePack":
			err = unpopulate(val, "ServicePack", &e.ServicePack)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &e.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Feature.
func (f Feature) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "featureType", f.FeatureType)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "parent", f.Parent)
	populate(objectMap, "status", f.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Feature.
func (f *Feature) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "featureType":
			err = unpopulate(val, "FeatureType", &f.FeatureType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "parent":
			err = unpopulate(val, "Parent", &f.Parent)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &f.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GuestOSDetails.
func (g GuestOSDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osName", g.OSName)
	populate(objectMap, "osType", g.OSType)
	populate(objectMap, "osVersion", g.OSVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GuestOSDetails.
func (g *GuestOSDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osName":
			err = unpopulate(val, "OSName", &g.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &g.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &g.OSVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HealthErrorDetails.
func (h HealthErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", h.Code)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "message", h.Message)
	populate(objectMap, "messageParameters", h.MessageParameters)
	populate(objectMap, "possibleCauses", h.PossibleCauses)
	populate(objectMap, "recommendedAction", h.RecommendedAction)
	populate(objectMap, "severity", h.Severity)
	populate(objectMap, "source", h.Source)
	populate(objectMap, "summaryMessage", h.SummaryMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HealthErrorDetails.
func (h *HealthErrorDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &h.Code)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &h.Message)
			delete(rawMsg, key)
		case "messageParameters":
			err = unpopulate(val, "MessageParameters", &h.MessageParameters)
			delete(rawMsg, key)
		case "possibleCauses":
			err = unpopulate(val, "PossibleCauses", &h.PossibleCauses)
			delete(rawMsg, key)
		case "recommendedAction":
			err = unpopulate(val, "RecommendedAction", &h.RecommendedAction)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &h.Severity)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &h.Source)
			delete(rawMsg, key)
		case "summaryMessage":
			err = unpopulate(val, "SummaryMessage", &h.SummaryMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HostingConfiguration.
func (h HostingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provider", h.Provider)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HostingConfiguration.
func (h *HostingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provider":
			err = unpopulate(val, "Provider", &h.Provider)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVCluster.
func (h HyperVCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVCluster.
func (h *HyperVCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVClusterCollection.
func (h HyperVClusterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVClusterCollection.
func (h *HyperVClusterCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVClusterProperties.
func (h HyperVClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "createdTimestamp", h.CreatedTimestamp)
	populate(objectMap, "errors", h.Errors)
	populate(objectMap, "fqdn", h.Fqdn)
	populate(objectMap, "functionalLevel", h.FunctionalLevel)
	populate(objectMap, "hostFqdnList", h.HostFqdnList)
	populate(objectMap, "runAsAccountId", h.RunAsAccountID)
	populate(objectMap, "status", h.Status)
	populate(objectMap, "updatedTimestamp", h.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVClusterProperties.
func (h *HyperVClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &h.CreatedTimestamp)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &h.Errors)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &h.Fqdn)
			delete(rawMsg, key)
		case "functionalLevel":
			err = unpopulate(val, "FunctionalLevel", &h.FunctionalLevel)
			delete(rawMsg, key)
		case "hostFqdnList":
			err = unpopulate(val, "HostFqdnList", &h.HostFqdnList)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &h.RunAsAccountID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &h.Status)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &h.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVDisk.
func (h HyperVDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskType", h.DiskType)
	populate(objectMap, "instanceId", h.InstanceID)
	populate(objectMap, "lun", h.Lun)
	populate(objectMap, "maxSizeInBytes", h.MaxSizeInBytes)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "path", h.Path)
	populate(objectMap, "vhdId", h.VhdID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVDisk.
func (h *HyperVDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskType":
			err = unpopulate(val, "DiskType", &h.DiskType)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, "InstanceID", &h.InstanceID)
			delete(rawMsg, key)
		case "lun":
			err = unpopulate(val, "Lun", &h.Lun)
			delete(rawMsg, key)
		case "maxSizeInBytes":
			err = unpopulate(val, "MaxSizeInBytes", &h.MaxSizeInBytes)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &h.Path)
			delete(rawMsg, key)
		case "vhdId":
			err = unpopulate(val, "VhdID", &h.VhdID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVHost.
func (h HyperVHost) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVHost.
func (h *HyperVHost) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVHostCollection.
func (h HyperVHostCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVHostCollection.
func (h *HyperVHostCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVHostProperties.
func (h HyperVHostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "createdTimestamp", h.CreatedTimestamp)
	populate(objectMap, "errors", h.Errors)
	populate(objectMap, "fqdn", h.Fqdn)
	populate(objectMap, "runAsAccountId", h.RunAsAccountID)
	populate(objectMap, "updatedTimestamp", h.UpdatedTimestamp)
	populate(objectMap, "version", h.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVHostProperties.
func (h *HyperVHostProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &h.CreatedTimestamp)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &h.Errors)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &h.Fqdn)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &h.RunAsAccountID)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &h.UpdatedTimestamp)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &h.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVJob.
func (h HyperVJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVJob.
func (h *HyperVJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVJobCollection.
func (h HyperVJobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVJobCollection.
func (h *HyperVJobCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVMachine.
func (h HyperVMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVMachine.
func (h *HyperVMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVMachineCollection.
func (h HyperVMachineCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVMachineCollection.
func (h *HyperVMachineCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVMachineProperties.
func (h HyperVMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocatedMemoryInMB", h.AllocatedMemoryInMB)
	populate(objectMap, "appsAndRoles", h.AppsAndRoles)
	populate(objectMap, "biosGuid", h.BiosGUID)
	populate(objectMap, "biosSerialNumber", h.BiosSerialNumber)
	populate(objectMap, "clusterFqdn", h.ClusterFqdn)
	populate(objectMap, "clusterId", h.ClusterID)
	populate(objectMap, "createdTimestamp", h.CreatedTimestamp)
	populate(objectMap, "disks", h.Disks)
	populate(objectMap, "displayName", h.DisplayName)
	populate(objectMap, "errors", h.Errors)
	populate(objectMap, "firmware", h.Firmware)
	populate(objectMap, "generation", h.Generation)
	populateTimeRFC3339(objectMap, "guestDetailsDiscoveryTimestamp", h.GuestDetailsDiscoveryTimestamp)
	populate(objectMap, "guestOSDetails", h.GuestOSDetails)
	populate(objectMap, "highAvailability", h.HighAvailability)
	populate(objectMap, "hostFqdn", h.HostFqdn)
	populate(objectMap, "hostId", h.HostID)
	populate(objectMap, "instanceUuid", h.InstanceUUID)
	populate(objectMap, "isDeleted", h.IsDeleted)
	populate(objectMap, "isDynamicMemoryEnabled", h.IsDynamicMemoryEnabled)
	populate(objectMap, "isGuestDetailsDiscoveryInProgress", h.IsGuestDetailsDiscoveryInProgress)
	populate(objectMap, "managementServerType", h.ManagementServerType)
	populate(objectMap, "maxMemoryMB", h.MaxMemoryMB)
	populate(objectMap, "networkAdapters", h.NetworkAdapters)
	populate(objectMap, "numberOfApplications", h.NumberOfApplications)
	populate(objectMap, "numberOfProcessorCore", h.NumberOfProcessorCore)
	populate(objectMap, "operatingSystemDetails", h.OperatingSystemDetails)
	populate(objectMap, "powerStatus", h.PowerStatus)
	populate(objectMap, "updatedTimestamp", h.UpdatedTimestamp)
	populate(objectMap, "vmConfigurationFileLocation", h.VMConfigurationFileLocation)
	populate(objectMap, "vmFqdn", h.VMFqdn)
	populate(objectMap, "version", h.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVMachineProperties.
func (h *HyperVMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocatedMemoryInMB":
			err = unpopulate(val, "AllocatedMemoryInMB", &h.AllocatedMemoryInMB)
			delete(rawMsg, key)
		case "appsAndRoles":
			err = unpopulate(val, "AppsAndRoles", &h.AppsAndRoles)
			delete(rawMsg, key)
		case "biosGuid":
			err = unpopulate(val, "BiosGUID", &h.BiosGUID)
			delete(rawMsg, key)
		case "biosSerialNumber":
			err = unpopulate(val, "BiosSerialNumber", &h.BiosSerialNumber)
			delete(rawMsg, key)
		case "clusterFqdn":
			err = unpopulate(val, "ClusterFqdn", &h.ClusterFqdn)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, "ClusterID", &h.ClusterID)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &h.CreatedTimestamp)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &h.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &h.DisplayName)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &h.Errors)
			delete(rawMsg, key)
		case "firmware":
			err = unpopulate(val, "Firmware", &h.Firmware)
			delete(rawMsg, key)
		case "generation":
			err = unpopulate(val, "Generation", &h.Generation)
			delete(rawMsg, key)
		case "guestDetailsDiscoveryTimestamp":
			err = unpopulateTimeRFC3339(val, "GuestDetailsDiscoveryTimestamp", &h.GuestDetailsDiscoveryTimestamp)
			delete(rawMsg, key)
		case "guestOSDetails":
			err = unpopulate(val, "GuestOSDetails", &h.GuestOSDetails)
			delete(rawMsg, key)
		case "highAvailability":
			err = unpopulate(val, "HighAvailability", &h.HighAvailability)
			delete(rawMsg, key)
		case "hostFqdn":
			err = unpopulate(val, "HostFqdn", &h.HostFqdn)
			delete(rawMsg, key)
		case "hostId":
			err = unpopulate(val, "HostID", &h.HostID)
			delete(rawMsg, key)
		case "instanceUuid":
			err = unpopulate(val, "InstanceUUID", &h.InstanceUUID)
			delete(rawMsg, key)
		case "isDeleted":
			err = unpopulate(val, "IsDeleted", &h.IsDeleted)
			delete(rawMsg, key)
		case "isDynamicMemoryEnabled":
			err = unpopulate(val, "IsDynamicMemoryEnabled", &h.IsDynamicMemoryEnabled)
			delete(rawMsg, key)
		case "isGuestDetailsDiscoveryInProgress":
			err = unpopulate(val, "IsGuestDetailsDiscoveryInProgress", &h.IsGuestDetailsDiscoveryInProgress)
			delete(rawMsg, key)
		case "managementServerType":
			err = unpopulate(val, "ManagementServerType", &h.ManagementServerType)
			delete(rawMsg, key)
		case "maxMemoryMB":
			err = unpopulate(val, "MaxMemoryMB", &h.MaxMemoryMB)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &h.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfApplications":
			err = unpopulate(val, "NumberOfApplications", &h.NumberOfApplications)
			delete(rawMsg, key)
		case "numberOfProcessorCore":
			err = unpopulate(val, "NumberOfProcessorCore", &h.NumberOfProcessorCore)
			delete(rawMsg, key)
		case "operatingSystemDetails":
			err = unpopulate(val, "OperatingSystemDetails", &h.OperatingSystemDetails)
			delete(rawMsg, key)
		case "powerStatus":
			err = unpopulate(val, "PowerStatus", &h.PowerStatus)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &h.UpdatedTimestamp)
			delete(rawMsg, key)
		case "vmConfigurationFileLocation":
			err = unpopulate(val, "VMConfigurationFileLocation", &h.VMConfigurationFileLocation)
			delete(rawMsg, key)
		case "vmFqdn":
			err = unpopulate(val, "VMFqdn", &h.VMFqdn)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &h.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVNetworkAdapter.
func (h HyperVNetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddressList", h.IPAddressList)
	populate(objectMap, "ipAddressType", h.IPAddressType)
	populate(objectMap, "macAddress", h.MacAddress)
	populate(objectMap, "networkId", h.NetworkID)
	populate(objectMap, "networkName", h.NetworkName)
	populate(objectMap, "nicId", h.NicID)
	populate(objectMap, "nicType", h.NicType)
	populate(objectMap, "staticIpAddress", h.StaticIPAddress)
	populate(objectMap, "subnetName", h.SubnetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVNetworkAdapter.
func (h *HyperVNetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddressList":
			err = unpopulate(val, "IPAddressList", &h.IPAddressList)
			delete(rawMsg, key)
		case "ipAddressType":
			err = unpopulate(val, "IPAddressType", &h.IPAddressType)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &h.MacAddress)
			delete(rawMsg, key)
		case "networkId":
			err = unpopulate(val, "NetworkID", &h.NetworkID)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &h.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &h.NicID)
			delete(rawMsg, key)
		case "nicType":
			err = unpopulate(val, "NicType", &h.NicType)
			delete(rawMsg, key)
		case "staticIpAddress":
			err = unpopulate(val, "StaticIPAddress", &h.StaticIPAddress)
			delete(rawMsg, key)
		case "subnetName":
			err = unpopulate(val, "SubnetName", &h.SubnetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVRunAsAccount.
func (h HyperVRunAsAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVRunAsAccount.
func (h *HyperVRunAsAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVRunAsAccountCollection.
func (h HyperVRunAsAccountCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVRunAsAccountCollection.
func (h *HyperVRunAsAccountCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVSite.
func (h HyperVSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", h.ETag)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVSite.
func (h *HyperVSite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &h.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &h.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &h.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVSiteUsage.
func (h HyperVSiteUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterCount", h.ClusterCount)
	populate(objectMap, "hostCount", h.HostCount)
	populate(objectMap, "machineCount", h.MachineCount)
	populate(objectMap, "runAsAccountCount", h.RunAsAccountCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVSiteUsage.
func (h *HyperVSiteUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterCount":
			err = unpopulate(val, "ClusterCount", &h.ClusterCount)
			delete(rawMsg, key)
		case "hostCount":
			err = unpopulate(val, "HostCount", &h.HostCount)
			delete(rawMsg, key)
		case "machineCount":
			err = unpopulate(val, "MachineCount", &h.MachineCount)
			delete(rawMsg, key)
		case "runAsAccountCount":
			err = unpopulate(val, "RunAsAccountCount", &h.RunAsAccountCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVSitesResultList.
func (h HyperVSitesResultList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVSitesResultList.
func (h *HyperVSitesResultList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HypervisorConfiguration.
func (h HypervisorConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hypervisorType", h.HypervisorType)
	populate(objectMap, "nativeHostMachineId", h.NativeHostMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HypervisorConfiguration.
func (h *HypervisorConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hypervisorType":
			err = unpopulate(val, "HypervisorType", &h.HypervisorType)
			delete(rawMsg, key)
		case "nativeHostMachineId":
			err = unpopulate(val, "NativeHostMachineID", &h.NativeHostMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPv4NetworkInterface.
func (i IPv4NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddress", i.IPAddress)
	populate(objectMap, "subnetMask", i.SubnetMask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPv4NetworkInterface.
func (i *IPv4NetworkInterface) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &i.IPAddress)
			delete(rawMsg, key)
		case "subnetMask":
			err = unpopulate(val, "SubnetMask", &i.SubnetMask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPv6NetworkInterface.
func (i IPv6NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddress", i.IPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPv6NetworkInterface.
func (i *IPv6NetworkInterface) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &i.IPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityId", j.ActivityID)
	populate(objectMap, "clientRequestId", j.ClientRequestID)
	populate(objectMap, "displayName", j.DisplayName)
	populate(objectMap, "endTime", j.EndTime)
	populate(objectMap, "errors", j.Errors)
	populate(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, "ActivityID", &j.ActivityID)
			delete(rawMsg, key)
		case "clientRequestId":
			err = unpopulate(val, "ClientRequestID", &j.ClientRequestID)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulate(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &j.Errors)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Machine.
func (m Machine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties.agent", m.PropertiesAgent)
	populateTimeRFC3339(objectMap, "properties.bootTime", m.PropertiesBootTime)
	populate(objectMap, "properties.computerName", m.PropertiesComputerName)
	populate(objectMap, "properties.displayName", m.PropertiesDisplayName)
	populate(objectMap, "properties.fullyQualifiedDomainName", m.PropertiesFullyQualifiedDomainName)
	populate(objectMap, "properties.hosting", m.PropertiesHosting)
	populate(objectMap, "properties.hypervisor", m.PropertiesHypervisor)
	populate(objectMap, "properties.monitoringState", m.PropertiesMonitoringState)
	populate(objectMap, "properties.networking", m.PropertiesNetworking)
	populate(objectMap, "properties.operatingSystem", m.PropertiesOperatingSystem)
	populate(objectMap, "properties.resources", m.PropertiesResources)
	populateTimeRFC3339(objectMap, "properties.timestamp", m.PropertiesTimestamp)
	populate(objectMap, "properties.timezone", m.PropertiesTimezone)
	populate(objectMap, "properties.virtualMachine", m.PropertiesVirtualMachine)
	populate(objectMap, "properties.virtualizationState", m.PropertiesVirtualizationState)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Machine.
func (m *Machine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties.agent":
			err = unpopulate(val, "PropertiesAgent", &m.PropertiesAgent)
			delete(rawMsg, key)
		case "properties.bootTime":
			err = unpopulateTimeRFC3339(val, "PropertiesBootTime", &m.PropertiesBootTime)
			delete(rawMsg, key)
		case "properties.computerName":
			err = unpopulate(val, "PropertiesComputerName", &m.PropertiesComputerName)
			delete(rawMsg, key)
		case "properties.displayName":
			err = unpopulate(val, "PropertiesDisplayName", &m.PropertiesDisplayName)
			delete(rawMsg, key)
		case "properties.fullyQualifiedDomainName":
			err = unpopulate(val, "PropertiesFullyQualifiedDomainName", &m.PropertiesFullyQualifiedDomainName)
			delete(rawMsg, key)
		case "properties.hosting":
			err = unpopulate(val, "PropertiesHosting", &m.PropertiesHosting)
			delete(rawMsg, key)
		case "properties.hypervisor":
			err = unpopulate(val, "PropertiesHypervisor", &m.PropertiesHypervisor)
			delete(rawMsg, key)
		case "properties.monitoringState":
			err = unpopulate(val, "PropertiesMonitoringState", &m.PropertiesMonitoringState)
			delete(rawMsg, key)
		case "properties.networking":
			err = unpopulate(val, "PropertiesNetworking", &m.PropertiesNetworking)
			delete(rawMsg, key)
		case "properties.operatingSystem":
			err = unpopulate(val, "PropertiesOperatingSystem", &m.PropertiesOperatingSystem)
			delete(rawMsg, key)
		case "properties.resources":
			err = unpopulate(val, "PropertiesResources", &m.PropertiesResources)
			delete(rawMsg, key)
		case "properties.timestamp":
			err = unpopulateTimeRFC3339(val, "PropertiesTimestamp", &m.PropertiesTimestamp)
			delete(rawMsg, key)
		case "properties.timezone":
			err = unpopulate(val, "PropertiesTimezone", &m.PropertiesTimezone)
			delete(rawMsg, key)
		case "properties.virtualMachine":
			err = unpopulate(val, "PropertiesVirtualMachine", &m.PropertiesVirtualMachine)
			delete(rawMsg, key)
		case "properties.virtualizationState":
			err = unpopulate(val, "PropertiesVirtualizationState", &m.PropertiesVirtualizationState)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineResourcesConfiguration.
func (m MachineResourcesConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuSpeed", m.CPUSpeed)
	populate(objectMap, "cpuSpeedAccuracy", m.CPUSpeedAccuracy)
	populate(objectMap, "cpus", m.Cpus)
	populate(objectMap, "physicalMemory", m.PhysicalMemory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineResourcesConfiguration.
func (m *MachineResourcesConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuSpeed":
			err = unpopulate(val, "CPUSpeed", &m.CPUSpeed)
			delete(rawMsg, key)
		case "cpuSpeedAccuracy":
			err = unpopulate(val, "CPUSpeedAccuracy", &m.CPUSpeedAccuracy)
			delete(rawMsg, key)
		case "cpus":
			err = unpopulate(val, "Cpus", &m.Cpus)
			delete(rawMsg, key)
		case "physicalMemory":
			err = unpopulate(val, "PhysicalMemory", &m.PhysicalMemory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MasterSite.
func (m MasterSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", m.ETag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MasterSite.
func (m *MasterSite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &m.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MasterSiteList.
func (m MasterSiteList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MasterSiteList.
func (m *MasterSiteList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MasterSiteProperties.
func (m MasterSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowMultipleSites", m.AllowMultipleSites)
	populate(objectMap, "customerStorageAccountArmId", m.CustomerStorageAccountArmID)
	populate(objectMap, "privateEndpointConnections", m.PrivateEndpointConnections)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "sites", m.Sites)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MasterSiteProperties.
func (m *MasterSiteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowMultipleSites":
			err = unpopulate(val, "AllowMultipleSites", &m.AllowMultipleSites)
			delete(rawMsg, key)
		case "customerStorageAccountArmId":
			err = unpopulate(val, "CustomerStorageAccountArmID", &m.CustomerStorageAccountArmID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, "PrivateEndpointConnections", &m.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &m.PublicNetworkAccess)
			delete(rawMsg, key)
		case "sites":
			err = unpopulate(val, "Sites", &m.Sites)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkConfiguration.
func (n NetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dnsCanonicalNames", n.DNSCanonicalNames)
	populate(objectMap, "dnsNames", n.DNSNames)
	populate(objectMap, "dnsQuestions", n.DNSQuestions)
	populate(objectMap, "defaultIpv4Gateways", n.DefaultIPv4Gateways)
	populate(objectMap, "ipv4Interfaces", n.IPv4Interfaces)
	populate(objectMap, "ipv6Interfaces", n.IPv6Interfaces)
	populate(objectMap, "macAddresses", n.MacAddresses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkConfiguration.
func (n *NetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dnsCanonicalNames":
			err = unpopulate(val, "DNSCanonicalNames", &n.DNSCanonicalNames)
			delete(rawMsg, key)
		case "dnsNames":
			err = unpopulate(val, "DNSNames", &n.DNSNames)
			delete(rawMsg, key)
		case "dnsQuestions":
			err = unpopulate(val, "DNSQuestions", &n.DNSQuestions)
			delete(rawMsg, key)
		case "defaultIpv4Gateways":
			err = unpopulate(val, "DefaultIPv4Gateways", &n.DefaultIPv4Gateways)
			delete(rawMsg, key)
		case "ipv4Interfaces":
			err = unpopulate(val, "IPv4Interfaces", &n.IPv4Interfaces)
			delete(rawMsg, key)
		case "ipv6Interfaces":
			err = unpopulate(val, "IPv6Interfaces", &n.IPv6Interfaces)
			delete(rawMsg, key)
		case "macAddresses":
			err = unpopulate(val, "MacAddresses", &n.MacAddresses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperatingSystem.
func (o OperatingSystem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "osType", o.OSType)
	populate(objectMap, "osVersion", o.OSVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperatingSystem.
func (o *OperatingSystem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osName":
			err = unpopulate(val, "OSName", &o.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &o.OSType)
			delete(rawMsg, key)
		case "osVersion":
			err = unpopulate(val, "OSVersion", &o.OSVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperatingSystemConfiguration.
func (o OperatingSystemConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bitness", o.Bitness)
	populate(objectMap, "family", o.Family)
	populate(objectMap, "fullName", o.FullName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperatingSystemConfiguration.
func (o *OperatingSystemConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitness":
			err = unpopulate(val, "Bitness", &o.Bitness)
			delete(rawMsg, key)
		case "family":
			err = unpopulate(val, "Family", &o.Family)
			delete(rawMsg, key)
		case "fullName":
			err = unpopulate(val, "FullName", &o.FullName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDetail.
func (o OperationDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDetail.
func (o *OperationDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatus.
func (o OperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endTime", o.EndTime)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatus.
func (o *OperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulate(val, "EndTime", &o.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusError.
func (o OperationStatusError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", o.Code)
	populate(objectMap, "message", o.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusError.
func (o *OperationStatusError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &o.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &o.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusProperties.
func (o OperationStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "result", o.Result)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusProperties.
func (o *OperationStatusProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "result":
			err = unpopulate(val, "Result", &o.Result)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OtherDatabase.
func (o OtherDatabase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "databaseType", o.DatabaseType)
	populate(objectMap, "instance", o.Instance)
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OtherDatabase.
func (o *OtherDatabase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseType":
			err = unpopulate(val, "DatabaseType", &o.DatabaseType)
			delete(rawMsg, key)
		case "instance":
			err = unpopulate(val, "Instance", &o.Instance)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", p.ETag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &p.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionCollection.
func (p PrivateEndpointConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionCollection.
func (p *PrivateEndpointConnectionCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProperties.
func (p PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProperties.
func (p *PrivateEndpointConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &p.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &p.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceCollection.
func (p PrivateLinkResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceCollection.
func (p *PrivateLinkResourceCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceProperties.
func (p *PrivateLinkResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &p.GroupID)
			delete(rawMsg, key)
		case "requiredMembers":
			err = unpopulate(val, "RequiredMembers", &p.RequiredMembers)
			delete(rawMsg, key)
		case "requiredZoneNames":
			err = unpopulate(val, "RequiredZoneNames", &p.RequiredZoneNames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnectionState.
func (p PrivateLinkServiceConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnectionState.
func (p *PrivateLinkServiceConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceID.
func (r ResourceID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceID.
func (r *ResourceID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunAsAccountProperties.
func (r RunAsAccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "createdTimestamp", r.CreatedTimestamp)
	populate(objectMap, "credentialType", r.CredentialType)
	populate(objectMap, "displayName", r.DisplayName)
	populate(objectMap, "updatedTimestamp", r.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunAsAccountProperties.
func (r *RunAsAccountProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &r.CreatedTimestamp)
			delete(rawMsg, key)
		case "credentialType":
			err = unpopulate(val, "CredentialType", &r.CredentialType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &r.DisplayName)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &r.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServer.
func (s SQLServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterName", s.ClusterName)
	populate(objectMap, "clustered", s.Clustered)
	populate(objectMap, "edition", s.Edition)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "servicePack", s.ServicePack)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServer.
func (s *SQLServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterName":
			err = unpopulate(val, "ClusterName", &s.ClusterName)
			delete(rawMsg, key)
		case "clustered":
			err = unpopulate(val, "Clustered", &s.Clustered)
			delete(rawMsg, key)
		case "edition":
			err = unpopulate(val, "Edition", &s.Edition)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "servicePack":
			err = unpopulate(val, "ServicePack", &s.ServicePack)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharePointServer.
func (s SharePointServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isEnterprise", s.IsEnterprise)
	populate(objectMap, "productName", s.ProductName)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharePointServer.
func (s *SharePointServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isEnterprise":
			err = unpopulate(val, "IsEnterprise", &s.IsEnterprise)
			delete(rawMsg, key)
		case "productName":
			err = unpopulate(val, "ProductName", &s.ProductName)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteAgentProperties.
func (s SiteAgentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "keyVaultId", s.KeyVaultID)
	populate(objectMap, "keyVaultUri", s.KeyVaultURI)
	populateTimeRFC3339(objectMap, "lastHeartBeatUtc", s.LastHeartBeatUTC)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteAgentProperties.
func (s *SiteAgentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "keyVaultId":
			err = unpopulate(val, "KeyVaultID", &s.KeyVaultID)
			delete(rawMsg, key)
		case "keyVaultUri":
			err = unpopulate(val, "KeyVaultURI", &s.KeyVaultURI)
			delete(rawMsg, key)
		case "lastHeartBeatUtc":
			err = unpopulateTimeRFC3339(val, "LastHeartBeatUTC", &s.LastHeartBeatUTC)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteHealthSummary.
func (s SiteHealthSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedObjectsCount", s.AffectedObjectsCount)
	populate(objectMap, "affectedResourceType", s.AffectedResourceType)
	populate(objectMap, "affectedResources", s.AffectedResources)
	populate(objectMap, "applianceName", s.ApplianceName)
	populate(objectMap, "errorCode", s.ErrorCode)
	populate(objectMap, "errorId", s.ErrorID)
	populate(objectMap, "errorMessage", s.ErrorMessage)
	populate(objectMap, "hitCount", s.HitCount)
	populate(objectMap, "remediationGuidance", s.RemediationGuidance)
	populate(objectMap, "severity", s.Severity)
	populate(objectMap, "summaryMessage", s.SummaryMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteHealthSummary.
func (s *SiteHealthSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedObjectsCount":
			err = unpopulate(val, "AffectedObjectsCount", &s.AffectedObjectsCount)
			delete(rawMsg, key)
		case "affectedResourceType":
			err = unpopulate(val, "AffectedResourceType", &s.AffectedResourceType)
			delete(rawMsg, key)
		case "affectedResources":
			err = unpopulate(val, "AffectedResources", &s.AffectedResources)
			delete(rawMsg, key)
		case "applianceName":
			err = unpopulate(val, "ApplianceName", &s.ApplianceName)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &s.ErrorCode)
			delete(rawMsg, key)
		case "errorId":
			err = unpopulate(val, "ErrorID", &s.ErrorID)
			delete(rawMsg, key)
		case "errorMessage":
			err = unpopulate(val, "ErrorMessage", &s.ErrorMessage)
			delete(rawMsg, key)
		case "hitCount":
			err = unpopulate(val, "HitCount", &s.HitCount)
			delete(rawMsg, key)
		case "remediationGuidance":
			err = unpopulate(val, "RemediationGuidance", &s.RemediationGuidance)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &s.Severity)
			delete(rawMsg, key)
		case "summaryMessage":
			err = unpopulate(val, "SummaryMessage", &s.SummaryMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteHealthSummaryCollection.
func (s SiteHealthSummaryCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteHealthSummaryCollection.
func (s *SiteHealthSummaryCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteProperties.
func (s SiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentDetails", s.AgentDetails)
	populate(objectMap, "applianceName", s.ApplianceName)
	populate(objectMap, "discoverySolutionId", s.DiscoverySolutionID)
	populate(objectMap, "serviceEndpoint", s.ServiceEndpoint)
	populate(objectMap, "servicePrincipalIdentityDetails", s.ServicePrincipalIdentityDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteProperties.
func (s *SiteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentDetails":
			err = unpopulate(val, "AgentDetails", &s.AgentDetails)
			delete(rawMsg, key)
		case "applianceName":
			err = unpopulate(val, "ApplianceName", &s.ApplianceName)
			delete(rawMsg, key)
		case "discoverySolutionId":
			err = unpopulate(val, "DiscoverySolutionID", &s.DiscoverySolutionID)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &s.ServiceEndpoint)
			delete(rawMsg, key)
		case "servicePrincipalIdentityDetails":
			err = unpopulate(val, "ServicePrincipalIdentityDetails", &s.ServicePrincipalIdentityDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SiteSpnProperties.
func (s SiteSpnProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadAuthority", s.AADAuthority)
	populate(objectMap, "applicationId", s.ApplicationID)
	populate(objectMap, "audience", s.Audience)
	populate(objectMap, "objectId", s.ObjectID)
	populate(objectMap, "rawCertData", s.RawCertData)
	populate(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SiteSpnProperties.
func (s *SiteSpnProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadAuthority":
			err = unpopulate(val, "AADAuthority", &s.AADAuthority)
			delete(rawMsg, key)
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &s.ApplicationID)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, "Audience", &s.Audience)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &s.ObjectID)
			delete(rawMsg, key)
		case "rawCertData":
			err = unpopulate(val, "RawCertData", &s.RawCertData)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &s.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemCenter.
func (s SystemCenter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "productName", s.ProductName)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemCenter.
func (s *SystemCenter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "productName":
			err = unpopulate(val, "ProductName", &s.ProductName)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Timezone.
func (t Timezone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fullName", t.FullName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Timezone.
func (t *Timezone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fullName":
			err = unpopulate(val, "FullName", &t.FullName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VCenter.
func (v VCenter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VCenter.
func (v *VCenter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VCenterCollection.
func (v VCenterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VCenterCollection.
func (v *VCenterCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VCenterProperties.
func (v VCenterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "createdTimestamp", v.CreatedTimestamp)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "fqdn", v.Fqdn)
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	populate(objectMap, "perfStatisticsLevel", v.PerfStatisticsLevel)
	populate(objectMap, "port", v.Port)
	populate(objectMap, "runAsAccountId", v.RunAsAccountID)
	populate(objectMap, "updatedTimestamp", v.UpdatedTimestamp)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VCenterProperties.
func (v *VCenterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &v.CreatedTimestamp)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &v.Errors)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &v.Fqdn)
			delete(rawMsg, key)
		case "instanceUuid":
			err = unpopulate(val, "InstanceUUID", &v.InstanceUUID)
			delete(rawMsg, key)
		case "perfStatisticsLevel":
			err = unpopulate(val, "PerfStatisticsLevel", &v.PerfStatisticsLevel)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &v.Port)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &v.RunAsAccountID)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &v.UpdatedTimestamp)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &v.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMWareSitesResultList.
func (v VMWareSitesResultList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMWareSitesResultList.
func (v *VMWareSitesResultList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareDisk.
func (v VMwareDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskMode", v.DiskMode)
	populate(objectMap, "diskProvisioningPolicy", v.DiskProvisioningPolicy)
	populate(objectMap, "diskScrubbingPolicy", v.DiskScrubbingPolicy)
	populate(objectMap, "diskType", v.DiskType)
	populate(objectMap, "label", v.Label)
	populate(objectMap, "lun", v.Lun)
	populate(objectMap, "maxSizeInBytes", v.MaxSizeInBytes)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "path", v.Path)
	populate(objectMap, "uuid", v.UUID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareDisk.
func (v *VMwareDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskMode":
			err = unpopulate(val, "DiskMode", &v.DiskMode)
			delete(rawMsg, key)
		case "diskProvisioningPolicy":
			err = unpopulate(val, "DiskProvisioningPolicy", &v.DiskProvisioningPolicy)
			delete(rawMsg, key)
		case "diskScrubbingPolicy":
			err = unpopulate(val, "DiskScrubbingPolicy", &v.DiskScrubbingPolicy)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, "DiskType", &v.DiskType)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &v.Label)
			delete(rawMsg, key)
		case "lun":
			err = unpopulate(val, "Lun", &v.Lun)
			delete(rawMsg, key)
		case "maxSizeInBytes":
			err = unpopulate(val, "MaxSizeInBytes", &v.MaxSizeInBytes)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &v.Path)
			delete(rawMsg, key)
		case "uuid":
			err = unpopulate(val, "UUID", &v.UUID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareJob.
func (v VMwareJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareJob.
func (v *VMwareJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareJobCollection.
func (v VMwareJobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareJobCollection.
func (v *VMwareJobCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareMachine.
func (v VMwareMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareMachine.
func (v *VMwareMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareMachineCollection.
func (v VMwareMachineCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareMachineCollection.
func (v *VMwareMachineCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareMachineProperties.
func (v VMwareMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocatedMemoryInMB", v.AllocatedMemoryInMB)
	populate(objectMap, "appsAndRoles", v.AppsAndRoles)
	populate(objectMap, "biosGuid", v.BiosGUID)
	populate(objectMap, "biosSerialNumber", v.BiosSerialNumber)
	populate(objectMap, "changeTrackingEnabled", v.ChangeTrackingEnabled)
	populate(objectMap, "changeTrackingSupported", v.ChangeTrackingSupported)
	populate(objectMap, "createdTimestamp", v.CreatedTimestamp)
	populate(objectMap, "dataCenterScope", v.DataCenterScope)
	populate(objectMap, "dependencyMapping", v.DependencyMapping)
	populateTimeRFC3339(objectMap, "dependencyMappingStartTime", v.DependencyMappingStartTime)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "disks", v.Disks)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "firmware", v.Firmware)
	populateTimeRFC3339(objectMap, "guestDetailsDiscoveryTimestamp", v.GuestDetailsDiscoveryTimestamp)
	populate(objectMap, "guestOSDetails", v.GuestOSDetails)
	populate(objectMap, "hostInMaintenanceMode", v.HostInMaintenanceMode)
	populate(objectMap, "hostName", v.HostName)
	populate(objectMap, "hostPowerState", v.HostPowerState)
	populate(objectMap, "hostVersion", v.HostVersion)
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	populate(objectMap, "isDeleted", v.IsDeleted)
	populate(objectMap, "isGuestDetailsDiscoveryInProgress", v.IsGuestDetailsDiscoveryInProgress)
	populate(objectMap, "maxSnapshots", v.MaxSnapshots)
	populate(objectMap, "networkAdapters", v.NetworkAdapters)
	populate(objectMap, "numberOfApplications", v.NumberOfApplications)
	populate(objectMap, "numberOfProcessorCore", v.NumberOfProcessorCore)
	populate(objectMap, "operatingSystemDetails", v.OperatingSystemDetails)
	populate(objectMap, "powerStatus", v.PowerStatus)
	populate(objectMap, "updatedTimestamp", v.UpdatedTimestamp)
	populate(objectMap, "vCenterFQDN", v.VCenterFQDN)
	populate(objectMap, "vCenterId", v.VCenterID)
	populate(objectMap, "vmConfigurationFileLocation", v.VMConfigurationFileLocation)
	populate(objectMap, "vmFqdn", v.VMFqdn)
	populate(objectMap, "vMwareToolsStatus", v.VMwareToolsStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareMachineProperties.
func (v *VMwareMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocatedMemoryInMB":
			err = unpopulate(val, "AllocatedMemoryInMB", &v.AllocatedMemoryInMB)
			delete(rawMsg, key)
		case "appsAndRoles":
			err = unpopulate(val, "AppsAndRoles", &v.AppsAndRoles)
			delete(rawMsg, key)
		case "biosGuid":
			err = unpopulate(val, "BiosGUID", &v.BiosGUID)
			delete(rawMsg, key)
		case "biosSerialNumber":
			err = unpopulate(val, "BiosSerialNumber", &v.BiosSerialNumber)
			delete(rawMsg, key)
		case "changeTrackingEnabled":
			err = unpopulate(val, "ChangeTrackingEnabled", &v.ChangeTrackingEnabled)
			delete(rawMsg, key)
		case "changeTrackingSupported":
			err = unpopulate(val, "ChangeTrackingSupported", &v.ChangeTrackingSupported)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulate(val, "CreatedTimestamp", &v.CreatedTimestamp)
			delete(rawMsg, key)
		case "dataCenterScope":
			err = unpopulate(val, "DataCenterScope", &v.DataCenterScope)
			delete(rawMsg, key)
		case "dependencyMapping":
			err = unpopulate(val, "DependencyMapping", &v.DependencyMapping)
			delete(rawMsg, key)
		case "dependencyMappingStartTime":
			err = unpopulateTimeRFC3339(val, "DependencyMappingStartTime", &v.DependencyMappingStartTime)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &v.Description)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &v.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &v.Errors)
			delete(rawMsg, key)
		case "firmware":
			err = unpopulate(val, "Firmware", &v.Firmware)
			delete(rawMsg, key)
		case "guestDetailsDiscoveryTimestamp":
			err = unpopulateTimeRFC3339(val, "GuestDetailsDiscoveryTimestamp", &v.GuestDetailsDiscoveryTimestamp)
			delete(rawMsg, key)
		case "guestOSDetails":
			err = unpopulate(val, "GuestOSDetails", &v.GuestOSDetails)
			delete(rawMsg, key)
		case "hostInMaintenanceMode":
			err = unpopulate(val, "HostInMaintenanceMode", &v.HostInMaintenanceMode)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &v.HostName)
			delete(rawMsg, key)
		case "hostPowerState":
			err = unpopulate(val, "HostPowerState", &v.HostPowerState)
			delete(rawMsg, key)
		case "hostVersion":
			err = unpopulate(val, "HostVersion", &v.HostVersion)
			delete(rawMsg, key)
		case "instanceUuid":
			err = unpopulate(val, "InstanceUUID", &v.InstanceUUID)
			delete(rawMsg, key)
		case "isDeleted":
			err = unpopulate(val, "IsDeleted", &v.IsDeleted)
			delete(rawMsg, key)
		case "isGuestDetailsDiscoveryInProgress":
			err = unpopulate(val, "IsGuestDetailsDiscoveryInProgress", &v.IsGuestDetailsDiscoveryInProgress)
			delete(rawMsg, key)
		case "maxSnapshots":
			err = unpopulate(val, "MaxSnapshots", &v.MaxSnapshots)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &v.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfApplications":
			err = unpopulate(val, "NumberOfApplications", &v.NumberOfApplications)
			delete(rawMsg, key)
		case "numberOfProcessorCore":
			err = unpopulate(val, "NumberOfProcessorCore", &v.NumberOfProcessorCore)
			delete(rawMsg, key)
		case "operatingSystemDetails":
			err = unpopulate(val, "OperatingSystemDetails", &v.OperatingSystemDetails)
			delete(rawMsg, key)
		case "powerStatus":
			err = unpopulate(val, "PowerStatus", &v.PowerStatus)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulate(val, "UpdatedTimestamp", &v.UpdatedTimestamp)
			delete(rawMsg, key)
		case "vCenterFQDN":
			err = unpopulate(val, "VCenterFQDN", &v.VCenterFQDN)
			delete(rawMsg, key)
		case "vCenterId":
			err = unpopulate(val, "VCenterID", &v.VCenterID)
			delete(rawMsg, key)
		case "vmConfigurationFileLocation":
			err = unpopulate(val, "VMConfigurationFileLocation", &v.VMConfigurationFileLocation)
			delete(rawMsg, key)
		case "vmFqdn":
			err = unpopulate(val, "VMFqdn", &v.VMFqdn)
			delete(rawMsg, key)
		case "vMwareToolsStatus":
			err = unpopulate(val, "VMwareToolsStatus", &v.VMwareToolsStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareNetworkAdapter.
func (v VMwareNetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddressList", v.IPAddressList)
	populate(objectMap, "ipAddressType", v.IPAddressType)
	populate(objectMap, "label", v.Label)
	populate(objectMap, "macAddress", v.MacAddress)
	populate(objectMap, "networkName", v.NetworkName)
	populate(objectMap, "nicId", v.NicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareNetworkAdapter.
func (v *VMwareNetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddressList":
			err = unpopulate(val, "IPAddressList", &v.IPAddressList)
			delete(rawMsg, key)
		case "ipAddressType":
			err = unpopulate(val, "IPAddressType", &v.IPAddressType)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &v.Label)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &v.MacAddress)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &v.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &v.NicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareRunAsAccount.
func (v VMwareRunAsAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareRunAsAccount.
func (v *VMwareRunAsAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareRunAsAccountCollection.
func (v VMwareRunAsAccountCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareRunAsAccountCollection.
func (v *VMwareRunAsAccountCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareSite.
func (v VMwareSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", v.ETag)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareSite.
func (v *VMwareSite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &v.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &v.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareSiteUsage.
func (v VMwareSiteUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "machineCount", v.MachineCount)
	populate(objectMap, "runAsAccountCount", v.RunAsAccountCount)
	populate(objectMap, "vCenterCount", v.VCenterCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareSiteUsage.
func (v *VMwareSiteUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "machineCount":
			err = unpopulate(val, "MachineCount", &v.MachineCount)
			delete(rawMsg, key)
		case "runAsAccountCount":
			err = unpopulate(val, "RunAsAccountCount", &v.RunAsAccountCount)
			delete(rawMsg, key)
		case "vCenterCount":
			err = unpopulate(val, "VCenterCount", &v.VCenterCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineConfiguration.
func (v VirtualMachineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nativeHostMachineId", v.NativeHostMachineID)
	populate(objectMap, "nativeMachineId", v.NativeMachineID)
	populate(objectMap, "virtualMachineName", v.VirtualMachineName)
	populate(objectMap, "virtualMachineType", v.VirtualMachineType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineConfiguration.
func (v *VirtualMachineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nativeHostMachineId":
			err = unpopulate(val, "NativeHostMachineID", &v.NativeHostMachineID)
			delete(rawMsg, key)
		case "nativeMachineId":
			err = unpopulate(val, "NativeMachineID", &v.NativeMachineID)
			delete(rawMsg, key)
		case "virtualMachineName":
			err = unpopulate(val, "VirtualMachineName", &v.VirtualMachineName)
			delete(rawMsg, key)
		case "virtualMachineType":
			err = unpopulate(val, "VirtualMachineType", &v.VirtualMachineType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebApplication.
func (w WebApplication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPool", w.ApplicationPool)
	populate(objectMap, "groupName", w.GroupName)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "platform", w.Platform)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "webServer", w.WebServer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebApplication.
func (w *WebApplication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPool":
			err = unpopulate(val, "ApplicationPool", &w.ApplicationPool)
			delete(rawMsg, key)
		case "groupName":
			err = unpopulate(val, "GroupName", &w.GroupName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, "Platform", &w.Platform)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		case "webServer":
			err = unpopulate(val, "WebServer", &w.WebServer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
