//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicesbackup

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AADProperties.
func (a AADProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audience", a.Audience)
	populate(objectMap, "authority", a.Authority)
	populate(objectMap, "servicePrincipalClientId", a.ServicePrincipalClientID)
	populate(objectMap, "servicePrincipalObjectId", a.ServicePrincipalObjectID)
	populate(objectMap, "tenantId", a.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADProperties.
func (a *AADProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audience":
			err = unpopulate(val, "Audience", &a.Audience)
			delete(rawMsg, key)
		case "authority":
			err = unpopulate(val, "Authority", &a.Authority)
			delete(rawMsg, key)
		case "servicePrincipalClientId":
			err = unpopulate(val, "ServicePrincipalClientID", &a.ServicePrincipalClientID)
			delete(rawMsg, key)
		case "servicePrincipalObjectId":
			err = unpopulate(val, "ServicePrincipalObjectID", &a.ServicePrincipalObjectID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &a.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AADPropertiesResource.
func (a AADPropertiesResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADPropertiesResource.
func (a *AADPropertiesResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileShareRecoveryPoint.
func (a AzureFileShareRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "crossRegionRestoreState", a.CrossRegionRestoreState)
	populate(objectMap, "fileShareSnapshotUri", a.FileShareSnapshotURI)
	objectMap["objectType"] = "AzureFileShareRecoveryPoint"
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointSizeInGB", a.RecoveryPointSizeInGB)
	populateDateTimeRFC3339(objectMap, "recoveryPointTime", a.RecoveryPointTime)
	populate(objectMap, "recoveryPointType", a.RecoveryPointType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileShareRecoveryPoint.
func (a *AzureFileShareRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crossRegionRestoreState":
			err = unpopulate(val, "CrossRegionRestoreState", &a.CrossRegionRestoreState)
			delete(rawMsg, key)
		case "fileShareSnapshotUri":
			err = unpopulate(val, "FileShareSnapshotURI", &a.FileShareSnapshotURI)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointSizeInGB":
			err = unpopulate(val, "RecoveryPointSizeInGB", &a.RecoveryPointSizeInGB)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTime", &a.RecoveryPointTime)
			delete(rawMsg, key)
		case "recoveryPointType":
			err = unpopulate(val, "RecoveryPointType", &a.RecoveryPointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileShareRestoreRequest.
func (a AzureFileShareRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "copyOptions", a.CopyOptions)
	objectMap["objectType"] = "AzureFileShareRestoreRequest"
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "restoreFileSpecs", a.RestoreFileSpecs)
	populate(objectMap, "restoreRequestType", a.RestoreRequestType)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetDetails", a.TargetDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileShareRestoreRequest.
func (a *AzureFileShareRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyOptions":
			err = unpopulate(val, "CopyOptions", &a.CopyOptions)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "restoreFileSpecs":
			err = unpopulate(val, "RestoreFileSpecs", &a.RestoreFileSpecs)
			delete(rawMsg, key)
		case "restoreRequestType":
			err = unpopulate(val, "RestoreRequestType", &a.RestoreRequestType)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetDetails":
			err = unpopulate(val, "TargetDetails", &a.TargetDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileshareProtectedItem.
func (a AzureFileshareProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "healthStatus", a.HealthStatus)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "policyId", a.PolicyID)
	objectMap["protectedItemType"] = "AzureFileShareProtectedItem"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileshareProtectedItem.
func (a *AzureFileshareProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "healthStatus":
			err = unpopulate(val, "HealthStatus", &a.HealthStatus)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileshareProtectedItemExtendedInfo.
func (a AzureFileshareProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", a.OldestRecoveryPoint)
	populate(objectMap, "policyState", a.PolicyState)
	populate(objectMap, "recoveryPointCount", a.RecoveryPointCount)
	populate(objectMap, "resourceState", a.ResourceState)
	populateDateTimeRFC3339(objectMap, "resourceStateSyncTime", a.ResourceStateSyncTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileshareProtectedItemExtendedInfo.
func (a *AzureFileshareProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &a.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "policyState":
			err = unpopulate(val, "PolicyState", &a.PolicyState)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &a.RecoveryPointCount)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, "ResourceState", &a.ResourceState)
			delete(rawMsg, key)
		case "resourceStateSyncTime":
			err = unpopulateDateTimeRFC3339(val, "ResourceStateSyncTime", &a.ResourceStateSyncTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSClassicComputeVMProtectedItem.
func (a AzureIaaSClassicComputeVMProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "extendedProperties", a.ExtendedProperties)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "healthDetails", a.HealthDetails)
	populate(objectMap, "healthStatus", a.HealthStatus)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataId", a.ProtectedItemDataID)
	objectMap["protectedItemType"] = "Microsoft.ClassicCompute/virtualMachines"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "virtualMachineId", a.VirtualMachineID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSClassicComputeVMProtectedItem.
func (a *AzureIaaSClassicComputeVMProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &a.ExtendedProperties)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "healthDetails":
			err = unpopulate(val, "HealthDetails", &a.HealthDetails)
			delete(rawMsg, key)
		case "healthStatus":
			err = unpopulate(val, "HealthStatus", &a.HealthStatus)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataId":
			err = unpopulate(val, "ProtectedItemDataID", &a.ProtectedItemDataID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "virtualMachineId":
			err = unpopulate(val, "VirtualMachineID", &a.VirtualMachineID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSComputeVMProtectedItem.
func (a AzureIaaSComputeVMProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "extendedProperties", a.ExtendedProperties)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "healthDetails", a.HealthDetails)
	populate(objectMap, "healthStatus", a.HealthStatus)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataId", a.ProtectedItemDataID)
	objectMap["protectedItemType"] = "Microsoft.Compute/virtualMachines"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "virtualMachineId", a.VirtualMachineID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSComputeVMProtectedItem.
func (a *AzureIaaSComputeVMProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &a.ExtendedProperties)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "healthDetails":
			err = unpopulate(val, "HealthDetails", &a.HealthDetails)
			delete(rawMsg, key)
		case "healthStatus":
			err = unpopulate(val, "HealthStatus", &a.HealthStatus)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataId":
			err = unpopulate(val, "ProtectedItemDataID", &a.ProtectedItemDataID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "virtualMachineId":
			err = unpopulate(val, "VirtualMachineID", &a.VirtualMachineID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMErrorInfo.
func (a AzureIaaSVMErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorCode", a.ErrorCode)
	populate(objectMap, "errorString", a.ErrorString)
	populate(objectMap, "errorTitle", a.ErrorTitle)
	populate(objectMap, "recommendations", a.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMErrorInfo.
func (a *AzureIaaSVMErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &a.ErrorCode)
			delete(rawMsg, key)
		case "errorString":
			err = unpopulate(val, "ErrorString", &a.ErrorString)
			delete(rawMsg, key)
		case "errorTitle":
			err = unpopulate(val, "ErrorTitle", &a.ErrorTitle)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &a.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMHealthDetails.
func (a AzureIaaSVMHealthDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "recommendations", a.Recommendations)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMHealthDetails.
func (a *AzureIaaSVMHealthDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &a.Message)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &a.Recommendations)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMJob.
func (a AzureIaaSVMJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsInfo", a.ActionsInfo)
	populate(objectMap, "activityId", a.ActivityID)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "duration", a.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "entityFriendlyName", a.EntityFriendlyName)
	populate(objectMap, "errorDetails", a.ErrorDetails)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	objectMap["jobType"] = "AzureIaaSVMJob"
	populate(objectMap, "operation", a.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "virtualMachineVersion", a.VirtualMachineVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMJob.
func (a *AzureIaaSVMJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsInfo":
			err = unpopulate(val, "ActionsInfo", &a.ActionsInfo)
			delete(rawMsg, key)
		case "activityId":
			err = unpopulate(val, "ActivityID", &a.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &a.EntityFriendlyName)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &a.ErrorDetails)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &a.JobType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &a.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "virtualMachineVersion":
			err = unpopulate(val, "VirtualMachineVersion", &a.VirtualMachineVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMJobExtendedInfo.
func (a AzureIaaSVMJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicErrorMessage", a.DynamicErrorMessage)
	populate(objectMap, "estimatedRemainingDuration", a.EstimatedRemainingDuration)
	populate(objectMap, "internalPropertyBag", a.InternalPropertyBag)
	populate(objectMap, "progressPercentage", a.ProgressPercentage)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "tasksList", a.TasksList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMJobExtendedInfo.
func (a *AzureIaaSVMJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicErrorMessage":
			err = unpopulate(val, "DynamicErrorMessage", &a.DynamicErrorMessage)
			delete(rawMsg, key)
		case "estimatedRemainingDuration":
			err = unpopulate(val, "EstimatedRemainingDuration", &a.EstimatedRemainingDuration)
			delete(rawMsg, key)
		case "internalPropertyBag":
			err = unpopulate(val, "InternalPropertyBag", &a.InternalPropertyBag)
			delete(rawMsg, key)
		case "progressPercentage":
			err = unpopulate(val, "ProgressPercentage", &a.ProgressPercentage)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "tasksList":
			err = unpopulate(val, "TasksList", &a.TasksList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMJobTaskDetails.
func (a AzureIaaSVMJobTaskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", a.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "instanceId", a.InstanceID)
	populate(objectMap, "progressPercentage", a.ProgressPercentage)
	populateDateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "taskExecutionDetails", a.TaskExecutionDetails)
	populate(objectMap, "taskId", a.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMJobTaskDetails.
func (a *AzureIaaSVMJobTaskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "instanceId":
			err = unpopulate(val, "InstanceID", &a.InstanceID)
			delete(rawMsg, key)
		case "progressPercentage":
			err = unpopulate(val, "ProgressPercentage", &a.ProgressPercentage)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "taskExecutionDetails":
			err = unpopulate(val, "TaskExecutionDetails", &a.TaskExecutionDetails)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &a.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMProtectedItem.
func (a AzureIaaSVMProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "extendedProperties", a.ExtendedProperties)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "healthDetails", a.HealthDetails)
	populate(objectMap, "healthStatus", a.HealthStatus)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataId", a.ProtectedItemDataID)
	objectMap["protectedItemType"] = "AzureIaaSVMProtectedItem"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "virtualMachineId", a.VirtualMachineID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMProtectedItem.
func (a *AzureIaaSVMProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &a.ExtendedProperties)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "healthDetails":
			err = unpopulate(val, "HealthDetails", &a.HealthDetails)
			delete(rawMsg, key)
		case "healthStatus":
			err = unpopulate(val, "HealthStatus", &a.HealthStatus)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataId":
			err = unpopulate(val, "ProtectedItemDataID", &a.ProtectedItemDataID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "virtualMachineId":
			err = unpopulate(val, "VirtualMachineID", &a.VirtualMachineID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMProtectedItemExtendedInfo.
func (a AzureIaaSVMProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", a.OldestRecoveryPoint)
	populate(objectMap, "policyInconsistent", a.PolicyInconsistent)
	populate(objectMap, "recoveryPointCount", a.RecoveryPointCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMProtectedItemExtendedInfo.
func (a *AzureIaaSVMProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &a.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "policyInconsistent":
			err = unpopulate(val, "PolicyInconsistent", &a.PolicyInconsistent)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &a.RecoveryPointCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLProtectedItem.
func (a AzureSQLProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataId", a.ProtectedItemDataID)
	objectMap["protectedItemType"] = "Microsoft.Sql/servers/databases"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLProtectedItem.
func (a *AzureSQLProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataId":
			err = unpopulate(val, "ProtectedItemDataID", &a.ProtectedItemDataID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLProtectedItemExtendedInfo.
func (a AzureSQLProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", a.OldestRecoveryPoint)
	populate(objectMap, "policyState", a.PolicyState)
	populate(objectMap, "recoveryPointCount", a.RecoveryPointCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLProtectedItemExtendedInfo.
func (a *AzureSQLProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &a.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "policyState":
			err = unpopulate(val, "PolicyState", &a.PolicyState)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &a.RecoveryPointCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageErrorInfo.
func (a AzureStorageErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorCode", a.ErrorCode)
	populate(objectMap, "errorString", a.ErrorString)
	populate(objectMap, "recommendations", a.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageErrorInfo.
func (a *AzureStorageErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &a.ErrorCode)
			delete(rawMsg, key)
		case "errorString":
			err = unpopulate(val, "ErrorString", &a.ErrorString)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &a.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageJob.
func (a AzureStorageJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsInfo", a.ActionsInfo)
	populate(objectMap, "activityId", a.ActivityID)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "duration", a.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "entityFriendlyName", a.EntityFriendlyName)
	populate(objectMap, "errorDetails", a.ErrorDetails)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	objectMap["jobType"] = "AzureStorageJob"
	populate(objectMap, "operation", a.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageAccountVersion", a.StorageAccountVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageJob.
func (a *AzureStorageJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsInfo":
			err = unpopulate(val, "ActionsInfo", &a.ActionsInfo)
			delete(rawMsg, key)
		case "activityId":
			err = unpopulate(val, "ActivityID", &a.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &a.EntityFriendlyName)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &a.ErrorDetails)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &a.JobType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &a.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, "StorageAccountName", &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageAccountVersion":
			err = unpopulate(val, "StorageAccountVersion", &a.StorageAccountVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageJobExtendedInfo.
func (a AzureStorageJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicErrorMessage", a.DynamicErrorMessage)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "tasksList", a.TasksList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageJobExtendedInfo.
func (a *AzureStorageJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicErrorMessage":
			err = unpopulate(val, "DynamicErrorMessage", &a.DynamicErrorMessage)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "tasksList":
			err = unpopulate(val, "TasksList", &a.TasksList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageJobTaskDetails.
func (a AzureStorageJobTaskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "taskId", a.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageJobTaskDetails.
func (a *AzureStorageJobTaskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &a.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadProtectedItem.
func (a AzureVMWorkloadProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupErrorDetail", a.LastBackupErrorDetail)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "parentName", a.ParentName)
	populate(objectMap, "parentType", a.ParentType)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataSourceId", a.ProtectedItemDataSourceID)
	populate(objectMap, "protectedItemHealthStatus", a.ProtectedItemHealthStatus)
	objectMap["protectedItemType"] = "AzureVmWorkloadProtectedItem"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "serverName", a.ServerName)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadProtectedItem.
func (a *AzureVMWorkloadProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupErrorDetail":
			err = unpopulate(val, "LastBackupErrorDetail", &a.LastBackupErrorDetail)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "parentName":
			err = unpopulate(val, "ParentName", &a.ParentName)
			delete(rawMsg, key)
		case "parentType":
			err = unpopulate(val, "ParentType", &a.ParentType)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataSourceId":
			err = unpopulate(val, "ProtectedItemDataSourceID", &a.ProtectedItemDataSourceID)
			delete(rawMsg, key)
		case "protectedItemHealthStatus":
			err = unpopulate(val, "ProtectedItemHealthStatus", &a.ProtectedItemHealthStatus)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &a.ServerName)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadProtectedItemExtendedInfo.
func (a AzureVMWorkloadProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", a.OldestRecoveryPoint)
	populate(objectMap, "policyState", a.PolicyState)
	populate(objectMap, "recoveryPointCount", a.RecoveryPointCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadProtectedItemExtendedInfo.
func (a *AzureVMWorkloadProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &a.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "policyState":
			err = unpopulate(val, "PolicyState", &a.PolicyState)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &a.RecoveryPointCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadSAPAseDatabaseProtectedItem.
func (a AzureVMWorkloadSAPAseDatabaseProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupErrorDetail", a.LastBackupErrorDetail)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "parentName", a.ParentName)
	populate(objectMap, "parentType", a.ParentType)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataSourceId", a.ProtectedItemDataSourceID)
	populate(objectMap, "protectedItemHealthStatus", a.ProtectedItemHealthStatus)
	objectMap["protectedItemType"] = "AzureVmWorkloadSAPAseDatabase"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "serverName", a.ServerName)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadSAPAseDatabaseProtectedItem.
func (a *AzureVMWorkloadSAPAseDatabaseProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupErrorDetail":
			err = unpopulate(val, "LastBackupErrorDetail", &a.LastBackupErrorDetail)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "parentName":
			err = unpopulate(val, "ParentName", &a.ParentName)
			delete(rawMsg, key)
		case "parentType":
			err = unpopulate(val, "ParentType", &a.ParentType)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataSourceId":
			err = unpopulate(val, "ProtectedItemDataSourceID", &a.ProtectedItemDataSourceID)
			delete(rawMsg, key)
		case "protectedItemHealthStatus":
			err = unpopulate(val, "ProtectedItemHealthStatus", &a.ProtectedItemHealthStatus)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &a.ServerName)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadSAPHanaDatabaseProtectedItem.
func (a AzureVMWorkloadSAPHanaDatabaseProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupErrorDetail", a.LastBackupErrorDetail)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "parentName", a.ParentName)
	populate(objectMap, "parentType", a.ParentType)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataSourceId", a.ProtectedItemDataSourceID)
	populate(objectMap, "protectedItemHealthStatus", a.ProtectedItemHealthStatus)
	objectMap["protectedItemType"] = "AzureVmWorkloadSAPHanaDatabase"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "serverName", a.ServerName)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadSAPHanaDatabaseProtectedItem.
func (a *AzureVMWorkloadSAPHanaDatabaseProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupErrorDetail":
			err = unpopulate(val, "LastBackupErrorDetail", &a.LastBackupErrorDetail)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "parentName":
			err = unpopulate(val, "ParentName", &a.ParentName)
			delete(rawMsg, key)
		case "parentType":
			err = unpopulate(val, "ParentType", &a.ParentType)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataSourceId":
			err = unpopulate(val, "ProtectedItemDataSourceID", &a.ProtectedItemDataSourceID)
			delete(rawMsg, key)
		case "protectedItemHealthStatus":
			err = unpopulate(val, "ProtectedItemHealthStatus", &a.ProtectedItemHealthStatus)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &a.ServerName)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadSQLDatabaseProtectedItem.
func (a AzureVMWorkloadSQLDatabaseProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "backupSetName", a.BackupSetName)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "createMode", a.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", a.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", a.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", a.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", a.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", a.IsScheduledForDeferredDelete)
	populate(objectMap, "kpisHealths", a.KpisHealths)
	populate(objectMap, "lastBackupErrorDetail", a.LastBackupErrorDetail)
	populate(objectMap, "lastBackupStatus", a.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", a.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", a.LastRecoveryPoint)
	populate(objectMap, "parentName", a.ParentName)
	populate(objectMap, "parentType", a.ParentType)
	populate(objectMap, "policyId", a.PolicyID)
	populate(objectMap, "protectedItemDataSourceId", a.ProtectedItemDataSourceID)
	populate(objectMap, "protectedItemHealthStatus", a.ProtectedItemHealthStatus)
	objectMap["protectedItemType"] = "AzureVmWorkloadSQLDatabase"
	populate(objectMap, "protectionState", a.ProtectionState)
	populate(objectMap, "protectionStatus", a.ProtectionStatus)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "serverName", a.ServerName)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadSQLDatabaseProtectedItem.
func (a *AzureVMWorkloadSQLDatabaseProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &a.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &a.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &a.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &a.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &a.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &a.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &a.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &a.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "kpisHealths":
			err = unpopulate(val, "KpisHealths", &a.KpisHealths)
			delete(rawMsg, key)
		case "lastBackupErrorDetail":
			err = unpopulate(val, "LastBackupErrorDetail", &a.LastBackupErrorDetail)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &a.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &a.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &a.LastRecoveryPoint)
			delete(rawMsg, key)
		case "parentName":
			err = unpopulate(val, "ParentName", &a.ParentName)
			delete(rawMsg, key)
		case "parentType":
			err = unpopulate(val, "ParentType", &a.ParentType)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &a.PolicyID)
			delete(rawMsg, key)
		case "protectedItemDataSourceId":
			err = unpopulate(val, "ProtectedItemDataSourceID", &a.ProtectedItemDataSourceID)
			delete(rawMsg, key)
		case "protectedItemHealthStatus":
			err = unpopulate(val, "ProtectedItemHealthStatus", &a.ProtectedItemHealthStatus)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &a.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &a.ProtectionState)
			delete(rawMsg, key)
		case "protectionStatus":
			err = unpopulate(val, "ProtectionStatus", &a.ProtectionStatus)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &a.ServerName)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadErrorInfo.
func (a AzureWorkloadErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDetails", a.AdditionalDetails)
	populate(objectMap, "errorCode", a.ErrorCode)
	populate(objectMap, "errorString", a.ErrorString)
	populate(objectMap, "errorTitle", a.ErrorTitle)
	populate(objectMap, "recommendations", a.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadErrorInfo.
func (a *AzureWorkloadErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDetails":
			err = unpopulate(val, "AdditionalDetails", &a.AdditionalDetails)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &a.ErrorCode)
			delete(rawMsg, key)
		case "errorString":
			err = unpopulate(val, "ErrorString", &a.ErrorString)
			delete(rawMsg, key)
		case "errorTitle":
			err = unpopulate(val, "ErrorTitle", &a.ErrorTitle)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &a.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadJob.
func (a AzureWorkloadJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsInfo", a.ActionsInfo)
	populate(objectMap, "activityId", a.ActivityID)
	populate(objectMap, "backupManagementType", a.BackupManagementType)
	populate(objectMap, "duration", a.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "entityFriendlyName", a.EntityFriendlyName)
	populate(objectMap, "errorDetails", a.ErrorDetails)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	objectMap["jobType"] = "AzureWorkloadJob"
	populate(objectMap, "operation", a.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "workloadType", a.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadJob.
func (a *AzureWorkloadJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsInfo":
			err = unpopulate(val, "ActionsInfo", &a.ActionsInfo)
			delete(rawMsg, key)
		case "activityId":
			err = unpopulate(val, "ActivityID", &a.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &a.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &a.EntityFriendlyName)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &a.ErrorDetails)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &a.JobType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &a.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &a.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadJobExtendedInfo.
func (a AzureWorkloadJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicErrorMessage", a.DynamicErrorMessage)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "tasksList", a.TasksList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadJobExtendedInfo.
func (a *AzureWorkloadJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicErrorMessage":
			err = unpopulate(val, "DynamicErrorMessage", &a.DynamicErrorMessage)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "tasksList":
			err = unpopulate(val, "TasksList", &a.TasksList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadJobTaskDetails.
func (a AzureWorkloadJobTaskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "taskId", a.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadJobTaskDetails.
func (a *AzureWorkloadJobTaskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &a.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadPointInTimeRecoveryPoint.
func (a AzureWorkloadPointInTimeRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadPointInTimeRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "timeRanges", a.TimeRanges)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadPointInTimeRecoveryPoint.
func (a *AzureWorkloadPointInTimeRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "timeRanges":
			err = unpopulate(val, "TimeRanges", &a.TimeRanges)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadPointInTimeRestoreRequest.
func (a AzureWorkloadPointInTimeRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadPointInTimeRestoreRequest"
	populateDateTimeRFC3339(objectMap, "pointInTime", a.PointInTime)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadPointInTimeRestoreRequest.
func (a *AzureWorkloadPointInTimeRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "pointInTime":
			err = unpopulateDateTimeRFC3339(val, "PointInTime", &a.PointInTime)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadRecoveryPoint.
func (a AzureWorkloadRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadRecoveryPoint.
func (a *AzureWorkloadRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadRestoreRequest.
func (a AzureWorkloadRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadRestoreRequest"
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadRestoreRequest.
func (a *AzureWorkloadRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSAPHanaPointInTimeRecoveryPoint.
func (a AzureWorkloadSAPHanaPointInTimeRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadSAPHanaPointInTimeRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "timeRanges", a.TimeRanges)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSAPHanaPointInTimeRecoveryPoint.
func (a *AzureWorkloadSAPHanaPointInTimeRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "timeRanges":
			err = unpopulate(val, "TimeRanges", &a.TimeRanges)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSAPHanaPointInTimeRestoreRequest.
func (a AzureWorkloadSAPHanaPointInTimeRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadSAPHanaPointInTimeRestoreRequest"
	populateDateTimeRFC3339(objectMap, "pointInTime", a.PointInTime)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSAPHanaPointInTimeRestoreRequest.
func (a *AzureWorkloadSAPHanaPointInTimeRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "pointInTime":
			err = unpopulateDateTimeRFC3339(val, "PointInTime", &a.PointInTime)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSAPHanaRecoveryPoint.
func (a AzureWorkloadSAPHanaRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadSAPHanaRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSAPHanaRecoveryPoint.
func (a *AzureWorkloadSAPHanaRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSAPHanaRestoreRequest.
func (a AzureWorkloadSAPHanaRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "AzureWorkloadSAPHanaRestoreRequest"
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSAPHanaRestoreRequest.
func (a *AzureWorkloadSAPHanaRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSQLPointInTimeRecoveryPoint.
func (a AzureWorkloadSQLPointInTimeRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	objectMap["objectType"] = "AzureWorkloadSQLPointInTimeRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "timeRanges", a.TimeRanges)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSQLPointInTimeRecoveryPoint.
func (a *AzureWorkloadSQLPointInTimeRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "timeRanges":
			err = unpopulate(val, "TimeRanges", &a.TimeRanges)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSQLPointInTimeRestoreRequest.
func (a AzureWorkloadSQLPointInTimeRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alternateDirectoryPaths", a.AlternateDirectoryPaths)
	populate(objectMap, "isNonRecoverable", a.IsNonRecoverable)
	objectMap["objectType"] = "AzureWorkloadSQLPointInTimeRestoreRequest"
	populateDateTimeRFC3339(objectMap, "pointInTime", a.PointInTime)
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "shouldUseAlternateTargetLocation", a.ShouldUseAlternateTargetLocation)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSQLPointInTimeRestoreRequest.
func (a *AzureWorkloadSQLPointInTimeRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateDirectoryPaths":
			err = unpopulate(val, "AlternateDirectoryPaths", &a.AlternateDirectoryPaths)
			delete(rawMsg, key)
		case "isNonRecoverable":
			err = unpopulate(val, "IsNonRecoverable", &a.IsNonRecoverable)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "pointInTime":
			err = unpopulateDateTimeRFC3339(val, "PointInTime", &a.PointInTime)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "shouldUseAlternateTargetLocation":
			err = unpopulate(val, "ShouldUseAlternateTargetLocation", &a.ShouldUseAlternateTargetLocation)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSQLRecoveryPoint.
func (a AzureWorkloadSQLRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedInfo", a.ExtendedInfo)
	objectMap["objectType"] = "AzureWorkloadSQLRecoveryPoint"
	populate(objectMap, "recoveryPointMoveReadinessInfo", a.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", a.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", a.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTimeInUTC", a.RecoveryPointTimeInUTC)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSQLRecoveryPoint.
func (a *AzureWorkloadSQLRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &a.ExtendedInfo)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &a.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &a.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &a.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTimeInUTC", &a.RecoveryPointTimeInUTC)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSQLRecoveryPointExtendedInfo.
func (a AzureWorkloadSQLRecoveryPointExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataDirectoryPaths", a.DataDirectoryPaths)
	populateDateTimeRFC3339(objectMap, "dataDirectoryTimeInUTC", a.DataDirectoryTimeInUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSQLRecoveryPointExtendedInfo.
func (a *AzureWorkloadSQLRecoveryPointExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataDirectoryPaths":
			err = unpopulate(val, "DataDirectoryPaths", &a.DataDirectoryPaths)
			delete(rawMsg, key)
		case "dataDirectoryTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DataDirectoryTimeInUTC", &a.DataDirectoryTimeInUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureWorkloadSQLRestoreRequest.
func (a AzureWorkloadSQLRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alternateDirectoryPaths", a.AlternateDirectoryPaths)
	populate(objectMap, "isNonRecoverable", a.IsNonRecoverable)
	objectMap["objectType"] = "AzureWorkloadSQLRestoreRequest"
	populate(objectMap, "propertyBag", a.PropertyBag)
	populate(objectMap, "recoveryMode", a.RecoveryMode)
	populate(objectMap, "recoveryType", a.RecoveryType)
	populate(objectMap, "shouldUseAlternateTargetLocation", a.ShouldUseAlternateTargetLocation)
	populate(objectMap, "sourceResourceId", a.SourceResourceID)
	populate(objectMap, "targetInfo", a.TargetInfo)
	populate(objectMap, "targetVirtualMachineId", a.TargetVirtualMachineID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureWorkloadSQLRestoreRequest.
func (a *AzureWorkloadSQLRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateDirectoryPaths":
			err = unpopulate(val, "AlternateDirectoryPaths", &a.AlternateDirectoryPaths)
			delete(rawMsg, key)
		case "isNonRecoverable":
			err = unpopulate(val, "IsNonRecoverable", &a.IsNonRecoverable)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &a.ObjectType)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &a.PropertyBag)
			delete(rawMsg, key)
		case "recoveryMode":
			err = unpopulate(val, "RecoveryMode", &a.RecoveryMode)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &a.RecoveryType)
			delete(rawMsg, key)
		case "shouldUseAlternateTargetLocation":
			err = unpopulate(val, "ShouldUseAlternateTargetLocation", &a.ShouldUseAlternateTargetLocation)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &a.SourceResourceID)
			delete(rawMsg, key)
		case "targetInfo":
			err = unpopulate(val, "TargetInfo", &a.TargetInfo)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &a.TargetVirtualMachineID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BEKDetails.
func (b BEKDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretData", b.SecretData)
	populate(objectMap, "secretUrl", b.SecretURL)
	populate(objectMap, "secretVaultId", b.SecretVaultID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BEKDetails.
func (b *BEKDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretData":
			err = unpopulate(val, "SecretData", &b.SecretData)
			delete(rawMsg, key)
		case "secretUrl":
			err = unpopulate(val, "SecretURL", &b.SecretURL)
			delete(rawMsg, key)
		case "secretVaultId":
			err = unpopulate(val, "SecretVaultID", &b.SecretVaultID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BMSAADPropertiesQueryObject.
func (b BMSAADPropertiesQueryObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", b.BackupManagementType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BMSAADPropertiesQueryObject.
func (b *BMSAADPropertiesQueryObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &b.BackupManagementType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BMSBackupSummariesQueryObject.
func (b BMSBackupSummariesQueryObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BMSBackupSummariesQueryObject.
func (b *BMSBackupSummariesQueryObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BMSRPQueryObject.
func (b BMSRPQueryObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDate", b.EndDate)
	populate(objectMap, "extendedInfo", b.ExtendedInfo)
	populate(objectMap, "includeSoftDeletedRP", b.IncludeSoftDeletedRP)
	populate(objectMap, "moveReadyRPOnly", b.MoveReadyRPOnly)
	populate(objectMap, "restorePointQueryType", b.RestorePointQueryType)
	populateDateTimeRFC3339(objectMap, "startDate", b.StartDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BMSRPQueryObject.
func (b *BMSRPQueryObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDate":
			err = unpopulateDateTimeRFC3339(val, "EndDate", &b.EndDate)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &b.ExtendedInfo)
			delete(rawMsg, key)
		case "includeSoftDeletedRP":
			err = unpopulate(val, "IncludeSoftDeletedRP", &b.IncludeSoftDeletedRP)
			delete(rawMsg, key)
		case "moveReadyRPOnly":
			err = unpopulate(val, "MoveReadyRPOnly", &b.MoveReadyRPOnly)
			delete(rawMsg, key)
		case "restorePointQueryType":
			err = unpopulate(val, "RestorePointQueryType", &b.RestorePointQueryType)
			delete(rawMsg, key)
		case "startDate":
			err = unpopulateDateTimeRFC3339(val, "StartDate", &b.StartDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupManagementUsage.
func (b BackupManagementUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentValue", b.CurrentValue)
	populate(objectMap, "limit", b.Limit)
	populate(objectMap, "name", b.Name)
	populateDateTimeRFC3339(objectMap, "nextResetTime", b.NextResetTime)
	populate(objectMap, "quotaPeriod", b.QuotaPeriod)
	populate(objectMap, "unit", b.Unit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupManagementUsage.
func (b *BackupManagementUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentValue":
			err = unpopulate(val, "CurrentValue", &b.CurrentValue)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, "Limit", &b.Limit)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "nextResetTime":
			err = unpopulateDateTimeRFC3339(val, "NextResetTime", &b.NextResetTime)
			delete(rawMsg, key)
		case "quotaPeriod":
			err = unpopulate(val, "QuotaPeriod", &b.QuotaPeriod)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, "Unit", &b.Unit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupManagementUsageList.
func (b BackupManagementUsageList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupManagementUsageList.
func (b *BackupManagementUsageList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupResourceConfig.
func (b BackupResourceConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "crossRegionRestoreFlag", b.CrossRegionRestoreFlag)
	populate(objectMap, "storageModelType", b.StorageModelType)
	populate(objectMap, "storageType", b.StorageType)
	populate(objectMap, "storageTypeState", b.StorageTypeState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupResourceConfig.
func (b *BackupResourceConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crossRegionRestoreFlag":
			err = unpopulate(val, "CrossRegionRestoreFlag", &b.CrossRegionRestoreFlag)
			delete(rawMsg, key)
		case "storageModelType":
			err = unpopulate(val, "StorageModelType", &b.StorageModelType)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, "StorageType", &b.StorageType)
			delete(rawMsg, key)
		case "storageTypeState":
			err = unpopulate(val, "StorageTypeState", &b.StorageTypeState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupResourceConfigResource.
func (b BackupResourceConfigResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "tags", b.Tags)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupResourceConfigResource.
func (b *BackupResourceConfigResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &b.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &b.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClientScriptForConnect.
func (c ClientScriptForConnect) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osType", c.OSType)
	populate(objectMap, "scriptContent", c.ScriptContent)
	populate(objectMap, "scriptExtension", c.ScriptExtension)
	populate(objectMap, "scriptNameSuffix", c.ScriptNameSuffix)
	populate(objectMap, "url", c.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientScriptForConnect.
func (c *ClientScriptForConnect) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osType":
			err = unpopulate(val, "OSType", &c.OSType)
			delete(rawMsg, key)
		case "scriptContent":
			err = unpopulate(val, "ScriptContent", &c.ScriptContent)
			delete(rawMsg, key)
		case "scriptExtension":
			err = unpopulate(val, "ScriptExtension", &c.ScriptExtension)
			delete(rawMsg, key)
		case "scriptNameSuffix":
			err = unpopulate(val, "ScriptNameSuffix", &c.ScriptNameSuffix)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &c.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrossRegionRestoreRequest.
func (c CrossRegionRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "crossRegionRestoreAccessDetails", c.CrossRegionRestoreAccessDetails)
	populate(objectMap, "restoreRequest", c.RestoreRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrossRegionRestoreRequest.
func (c *CrossRegionRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crossRegionRestoreAccessDetails":
			c.CrossRegionRestoreAccessDetails, err = unmarshalCrrAccessTokenClassification(val)
			delete(rawMsg, key)
		case "restoreRequest":
			c.RestoreRequest, err = unmarshalRestoreRequestClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrossRegionRestoreRequestResource.
func (c CrossRegionRestoreRequestResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", c.ETag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrossRegionRestoreRequestResource.
func (c *CrossRegionRestoreRequestResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &c.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrrAccessToken.
func (c CrrAccessToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessTokenString", c.AccessTokenString)
	populate(objectMap, "bMSActiveRegion", c.BMSActiveRegion)
	populate(objectMap, "backupManagementType", c.BackupManagementType)
	populate(objectMap, "containerName", c.ContainerName)
	populate(objectMap, "containerType", c.ContainerType)
	populate(objectMap, "coordinatorServiceStampId", c.CoordinatorServiceStampID)
	populate(objectMap, "coordinatorServiceStampUri", c.CoordinatorServiceStampURI)
	populate(objectMap, "datasourceContainerName", c.DatasourceContainerName)
	populate(objectMap, "datasourceId", c.DatasourceID)
	populate(objectMap, "datasourceName", c.DatasourceName)
	populate(objectMap, "datasourceType", c.DatasourceType)
	objectMap["objectType"] = c.ObjectType
	populate(objectMap, "protectionContainerId", c.ProtectionContainerID)
	populate(objectMap, "protectionServiceStampId", c.ProtectionServiceStampID)
	populate(objectMap, "protectionServiceStampUri", c.ProtectionServiceStampURI)
	populate(objectMap, "recoveryPointId", c.RecoveryPointID)
	populate(objectMap, "recoveryPointTime", c.RecoveryPointTime)
	populate(objectMap, "resourceGroupName", c.ResourceGroupName)
	populate(objectMap, "resourceId", c.ResourceID)
	populate(objectMap, "resourceName", c.ResourceName)
	populate(objectMap, "rpIsManagedVirtualMachine", c.RpIsManagedVirtualMachine)
	populate(objectMap, "rpOriginalSAOption", c.RpOriginalSAOption)
	populate(objectMap, "rpTierInformation", c.RpTierInformation)
	populate(objectMap, "rpVMSizeDescription", c.RpVMSizeDescription)
	populate(objectMap, "subscriptionId", c.SubscriptionID)
	populate(objectMap, "tokenExtendedInformation", c.TokenExtendedInformation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrrAccessToken.
func (c *CrrAccessToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTokenString":
			err = unpopulate(val, "AccessTokenString", &c.AccessTokenString)
			delete(rawMsg, key)
		case "bMSActiveRegion":
			err = unpopulate(val, "BMSActiveRegion", &c.BMSActiveRegion)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &c.BackupManagementType)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &c.ContainerName)
			delete(rawMsg, key)
		case "containerType":
			err = unpopulate(val, "ContainerType", &c.ContainerType)
			delete(rawMsg, key)
		case "coordinatorServiceStampId":
			err = unpopulate(val, "CoordinatorServiceStampID", &c.CoordinatorServiceStampID)
			delete(rawMsg, key)
		case "coordinatorServiceStampUri":
			err = unpopulate(val, "CoordinatorServiceStampURI", &c.CoordinatorServiceStampURI)
			delete(rawMsg, key)
		case "datasourceContainerName":
			err = unpopulate(val, "DatasourceContainerName", &c.DatasourceContainerName)
			delete(rawMsg, key)
		case "datasourceId":
			err = unpopulate(val, "DatasourceID", &c.DatasourceID)
			delete(rawMsg, key)
		case "datasourceName":
			err = unpopulate(val, "DatasourceName", &c.DatasourceName)
			delete(rawMsg, key)
		case "datasourceType":
			err = unpopulate(val, "DatasourceType", &c.DatasourceType)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &c.ObjectType)
			delete(rawMsg, key)
		case "protectionContainerId":
			err = unpopulate(val, "ProtectionContainerID", &c.ProtectionContainerID)
			delete(rawMsg, key)
		case "protectionServiceStampId":
			err = unpopulate(val, "ProtectionServiceStampID", &c.ProtectionServiceStampID)
			delete(rawMsg, key)
		case "protectionServiceStampUri":
			err = unpopulate(val, "ProtectionServiceStampURI", &c.ProtectionServiceStampURI)
			delete(rawMsg, key)
		case "recoveryPointId":
			err = unpopulate(val, "RecoveryPointID", &c.RecoveryPointID)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulate(val, "RecoveryPointTime", &c.RecoveryPointTime)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &c.ResourceGroupName)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &c.ResourceID)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, "ResourceName", &c.ResourceName)
			delete(rawMsg, key)
		case "rpIsManagedVirtualMachine":
			err = unpopulate(val, "RpIsManagedVirtualMachine", &c.RpIsManagedVirtualMachine)
			delete(rawMsg, key)
		case "rpOriginalSAOption":
			err = unpopulate(val, "RpOriginalSAOption", &c.RpOriginalSAOption)
			delete(rawMsg, key)
		case "rpTierInformation":
			err = unpopulate(val, "RpTierInformation", &c.RpTierInformation)
			delete(rawMsg, key)
		case "rpVMSizeDescription":
			err = unpopulate(val, "RpVMSizeDescription", &c.RpVMSizeDescription)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &c.SubscriptionID)
			delete(rawMsg, key)
		case "tokenExtendedInformation":
			err = unpopulate(val, "TokenExtendedInformation", &c.TokenExtendedInformation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrrAccessTokenResource.
func (c CrrAccessTokenResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", c.ETag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrrAccessTokenResource.
func (c *CrrAccessTokenResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &c.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			c.Properties, err = unmarshalCrrAccessTokenClassification(val)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrrJobRequest.
func (c CrrJobRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobName", c.JobName)
	populate(objectMap, "resourceId", c.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrrJobRequest.
func (c *CrrJobRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobName":
			err = unpopulate(val, "JobName", &c.JobName)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &c.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CrrJobRequestResource.
func (c CrrJobRequestResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", c.ETag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CrrJobRequestResource.
func (c *CrrJobRequestResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &c.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DPMProtectedItem.
func (d DPMProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupEngineName", d.BackupEngineName)
	populate(objectMap, "backupManagementType", d.BackupManagementType)
	populate(objectMap, "backupSetName", d.BackupSetName)
	populate(objectMap, "containerName", d.ContainerName)
	populate(objectMap, "createMode", d.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", d.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", d.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", d.ExtendedInfo)
	populate(objectMap, "friendlyName", d.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", d.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", d.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", d.IsScheduledForDeferredDelete)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", d.LastRecoveryPoint)
	populate(objectMap, "policyId", d.PolicyID)
	objectMap["protectedItemType"] = "DPMProtectedItem"
	populate(objectMap, "protectionState", d.ProtectionState)
	populate(objectMap, "resourceGuardOperationRequests", d.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", d.SourceResourceID)
	populate(objectMap, "workloadType", d.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DPMProtectedItem.
func (d *DPMProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupEngineName":
			err = unpopulate(val, "BackupEngineName", &d.BackupEngineName)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &d.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &d.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &d.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &d.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &d.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &d.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &d.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &d.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &d.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &d.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &d.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &d.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &d.PolicyID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &d.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &d.ProtectionState)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &d.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &d.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &d.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DPMProtectedItemExtendedInfo.
func (d DPMProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskStorageUsedInBytes", d.DiskStorageUsedInBytes)
	populate(objectMap, "isCollocated", d.IsCollocated)
	populate(objectMap, "isPresentOnCloud", d.IsPresentOnCloud)
	populate(objectMap, "lastBackupStatus", d.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastRefreshedAt", d.LastRefreshedAt)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", d.OldestRecoveryPoint)
	populateDateTimeRFC3339(objectMap, "onPremiseLatestRecoveryPoint", d.OnPremiseLatestRecoveryPoint)
	populateDateTimeRFC3339(objectMap, "onPremiseOldestRecoveryPoint", d.OnPremiseOldestRecoveryPoint)
	populate(objectMap, "onPremiseRecoveryPointCount", d.OnPremiseRecoveryPointCount)
	populate(objectMap, "protectableObjectLoadPath", d.ProtectableObjectLoadPath)
	populate(objectMap, "protected", d.Protected)
	populate(objectMap, "protectionGroupName", d.ProtectionGroupName)
	populate(objectMap, "recoveryPointCount", d.RecoveryPointCount)
	populate(objectMap, "totalDiskStorageSizeInBytes", d.TotalDiskStorageSizeInBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DPMProtectedItemExtendedInfo.
func (d *DPMProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskStorageUsedInBytes":
			err = unpopulate(val, "DiskStorageUsedInBytes", &d.DiskStorageUsedInBytes)
			delete(rawMsg, key)
		case "isCollocated":
			err = unpopulate(val, "IsCollocated", &d.IsCollocated)
			delete(rawMsg, key)
		case "isPresentOnCloud":
			err = unpopulate(val, "IsPresentOnCloud", &d.IsPresentOnCloud)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &d.LastBackupStatus)
			delete(rawMsg, key)
		case "lastRefreshedAt":
			err = unpopulateDateTimeRFC3339(val, "LastRefreshedAt", &d.LastRefreshedAt)
			delete(rawMsg, key)
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &d.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "onPremiseLatestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OnPremiseLatestRecoveryPoint", &d.OnPremiseLatestRecoveryPoint)
			delete(rawMsg, key)
		case "onPremiseOldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OnPremiseOldestRecoveryPoint", &d.OnPremiseOldestRecoveryPoint)
			delete(rawMsg, key)
		case "onPremiseRecoveryPointCount":
			err = unpopulate(val, "OnPremiseRecoveryPointCount", &d.OnPremiseRecoveryPointCount)
			delete(rawMsg, key)
		case "protectableObjectLoadPath":
			err = unpopulate(val, "ProtectableObjectLoadPath", &d.ProtectableObjectLoadPath)
			delete(rawMsg, key)
		case "protected":
			err = unpopulate(val, "Protected", &d.Protected)
			delete(rawMsg, key)
		case "protectionGroupName":
			err = unpopulate(val, "ProtectionGroupName", &d.ProtectionGroupName)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &d.RecoveryPointCount)
			delete(rawMsg, key)
		case "totalDiskStorageSizeInBytes":
			err = unpopulate(val, "TotalDiskStorageSizeInBytes", &d.TotalDiskStorageSizeInBytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskExclusionProperties.
func (d DiskExclusionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskLunList", d.DiskLunList)
	populate(objectMap, "isInclusionList", d.IsInclusionList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskExclusionProperties.
func (d *DiskExclusionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskLunList":
			err = unpopulate(val, "DiskLunList", &d.DiskLunList)
			delete(rawMsg, key)
		case "isInclusionList":
			err = unpopulate(val, "IsInclusionList", &d.IsInclusionList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskInformation.
func (d DiskInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lun", d.Lun)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskInformation.
func (d *DiskInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lun":
			err = unpopulate(val, "Lun", &d.Lun)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DpmErrorInfo.
func (d DpmErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorString", d.ErrorString)
	populate(objectMap, "recommendations", d.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DpmErrorInfo.
func (d *DpmErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorString":
			err = unpopulate(val, "ErrorString", &d.ErrorString)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &d.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DpmJob.
func (d DpmJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsInfo", d.ActionsInfo)
	populate(objectMap, "activityId", d.ActivityID)
	populate(objectMap, "backupManagementType", d.BackupManagementType)
	populate(objectMap, "containerName", d.ContainerName)
	populate(objectMap, "containerType", d.ContainerType)
	populate(objectMap, "dpmServerName", d.DpmServerName)
	populate(objectMap, "duration", d.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", d.EndTime)
	populate(objectMap, "entityFriendlyName", d.EntityFriendlyName)
	populate(objectMap, "errorDetails", d.ErrorDetails)
	populate(objectMap, "extendedInfo", d.ExtendedInfo)
	objectMap["jobType"] = "DpmJob"
	populate(objectMap, "operation", d.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", d.StartTime)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "workloadType", d.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DpmJob.
func (d *DpmJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsInfo":
			err = unpopulate(val, "ActionsInfo", &d.ActionsInfo)
			delete(rawMsg, key)
		case "activityId":
			err = unpopulate(val, "ActivityID", &d.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &d.BackupManagementType)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &d.ContainerName)
			delete(rawMsg, key)
		case "containerType":
			err = unpopulate(val, "ContainerType", &d.ContainerType)
			delete(rawMsg, key)
		case "dpmServerName":
			err = unpopulate(val, "DpmServerName", &d.DpmServerName)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &d.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &d.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &d.EntityFriendlyName)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &d.ErrorDetails)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &d.ExtendedInfo)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &d.JobType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &d.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &d.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &d.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DpmJobExtendedInfo.
func (d DpmJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicErrorMessage", d.DynamicErrorMessage)
	populate(objectMap, "propertyBag", d.PropertyBag)
	populate(objectMap, "tasksList", d.TasksList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DpmJobExtendedInfo.
func (d *DpmJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicErrorMessage":
			err = unpopulate(val, "DynamicErrorMessage", &d.DynamicErrorMessage)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &d.PropertyBag)
			delete(rawMsg, key)
		case "tasksList":
			err = unpopulate(val, "TasksList", &d.TasksList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DpmJobTaskDetails.
func (d DpmJobTaskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", d.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", d.EndTime)
	populateDateTimeRFC3339(objectMap, "startTime", d.StartTime)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "taskId", d.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DpmJobTaskDetails.
func (d *DpmJobTaskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &d.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &d.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &d.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &d.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionDetails.
func (e EncryptionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptionEnabled", e.EncryptionEnabled)
	populate(objectMap, "kekUrl", e.KekURL)
	populate(objectMap, "kekVaultId", e.KekVaultID)
	populate(objectMap, "secretKeyUrl", e.SecretKeyURL)
	populate(objectMap, "secretKeyVaultId", e.SecretKeyVaultID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionDetails.
func (e *EncryptionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptionEnabled":
			err = unpopulate(val, "EncryptionEnabled", &e.EncryptionEnabled)
			delete(rawMsg, key)
		case "kekUrl":
			err = unpopulate(val, "KekURL", &e.KekURL)
			delete(rawMsg, key)
		case "kekVaultId":
			err = unpopulate(val, "KekVaultID", &e.KekVaultID)
			delete(rawMsg, key)
		case "secretKeyUrl":
			err = unpopulate(val, "SecretKeyURL", &e.SecretKeyURL)
			delete(rawMsg, key)
		case "secretKeyVaultId":
			err = unpopulate(val, "SecretKeyVaultID", &e.SecretKeyVaultID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
			err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "recommendations", e.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &e.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedProperties.
func (e ExtendedProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskExclusionProperties", e.DiskExclusionProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedProperties.
func (e *ExtendedProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskExclusionProperties":
			err = unpopulate(val, "DiskExclusionProperties", &e.DiskExclusionProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenericProtectedItem.
func (g GenericProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", g.BackupManagementType)
	populate(objectMap, "backupSetName", g.BackupSetName)
	populate(objectMap, "containerName", g.ContainerName)
	populate(objectMap, "createMode", g.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", g.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", g.DeferredDeleteTimeRemaining)
	populate(objectMap, "fabricName", g.FabricName)
	populate(objectMap, "friendlyName", g.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", g.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", g.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", g.IsScheduledForDeferredDelete)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", g.LastRecoveryPoint)
	populate(objectMap, "policyId", g.PolicyID)
	populate(objectMap, "policyState", g.PolicyState)
	populate(objectMap, "protectedItemId", g.ProtectedItemID)
	objectMap["protectedItemType"] = "GenericProtectedItem"
	populate(objectMap, "protectionState", g.ProtectionState)
	populate(objectMap, "resourceGuardOperationRequests", g.ResourceGuardOperationRequests)
	populate(objectMap, "sourceAssociations", g.SourceAssociations)
	populate(objectMap, "sourceResourceId", g.SourceResourceID)
	populate(objectMap, "workloadType", g.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenericProtectedItem.
func (g *GenericProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &g.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &g.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &g.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &g.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &g.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &g.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "fabricName":
			err = unpopulate(val, "FabricName", &g.FabricName)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &g.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &g.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &g.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &g.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &g.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &g.PolicyID)
			delete(rawMsg, key)
		case "policyState":
			err = unpopulate(val, "PolicyState", &g.PolicyState)
			delete(rawMsg, key)
		case "protectedItemId":
			err = unpopulate(val, "ProtectedItemID", &g.ProtectedItemID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &g.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &g.ProtectionState)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &g.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceAssociations":
			err = unpopulate(val, "SourceAssociations", &g.SourceAssociations)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &g.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &g.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenericRecoveryPoint.
func (g GenericRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "friendlyName", g.FriendlyName)
	objectMap["objectType"] = "GenericRecoveryPoint"
	populate(objectMap, "recoveryPointAdditionalInfo", g.RecoveryPointAdditionalInfo)
	populate(objectMap, "recoveryPointProperties", g.RecoveryPointProperties)
	populateDateTimeRFC3339(objectMap, "recoveryPointTime", g.RecoveryPointTime)
	populate(objectMap, "recoveryPointType", g.RecoveryPointType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenericRecoveryPoint.
func (g *GenericRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &g.FriendlyName)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &g.ObjectType)
			delete(rawMsg, key)
		case "recoveryPointAdditionalInfo":
			err = unpopulate(val, "RecoveryPointAdditionalInfo", &g.RecoveryPointAdditionalInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &g.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTime", &g.RecoveryPointTime)
			delete(rawMsg, key)
		case "recoveryPointType":
			err = unpopulate(val, "RecoveryPointType", &g.RecoveryPointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasVMRecoveryPoint.
func (i IaasVMRecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isInstantIlrSessionActive", i.IsInstantIlrSessionActive)
	populate(objectMap, "isManagedVirtualMachine", i.IsManagedVirtualMachine)
	populate(objectMap, "isSourceVMEncrypted", i.IsSourceVMEncrypted)
	populate(objectMap, "keyAndSecret", i.KeyAndSecret)
	populate(objectMap, "osType", i.OSType)
	objectMap["objectType"] = "IaasVMRecoveryPoint"
	populate(objectMap, "originalStorageAccountOption", i.OriginalStorageAccountOption)
	populate(objectMap, "recoveryPointAdditionalInfo", i.RecoveryPointAdditionalInfo)
	populate(objectMap, "recoveryPointDiskConfiguration", i.RecoveryPointDiskConfiguration)
	populate(objectMap, "recoveryPointMoveReadinessInfo", i.RecoveryPointMoveReadinessInfo)
	populate(objectMap, "recoveryPointProperties", i.RecoveryPointProperties)
	populate(objectMap, "recoveryPointTierDetails", i.RecoveryPointTierDetails)
	populateDateTimeRFC3339(objectMap, "recoveryPointTime", i.RecoveryPointTime)
	populate(objectMap, "recoveryPointType", i.RecoveryPointType)
	populate(objectMap, "sourceVMStorageType", i.SourceVMStorageType)
	populate(objectMap, "virtualMachineSize", i.VirtualMachineSize)
	populate(objectMap, "zones", i.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasVMRecoveryPoint.
func (i *IaasVMRecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isInstantIlrSessionActive":
			err = unpopulate(val, "IsInstantIlrSessionActive", &i.IsInstantIlrSessionActive)
			delete(rawMsg, key)
		case "isManagedVirtualMachine":
			err = unpopulate(val, "IsManagedVirtualMachine", &i.IsManagedVirtualMachine)
			delete(rawMsg, key)
		case "isSourceVMEncrypted":
			err = unpopulate(val, "IsSourceVMEncrypted", &i.IsSourceVMEncrypted)
			delete(rawMsg, key)
		case "keyAndSecret":
			err = unpopulate(val, "KeyAndSecret", &i.KeyAndSecret)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &i.OSType)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &i.ObjectType)
			delete(rawMsg, key)
		case "originalStorageAccountOption":
			err = unpopulate(val, "OriginalStorageAccountOption", &i.OriginalStorageAccountOption)
			delete(rawMsg, key)
		case "recoveryPointAdditionalInfo":
			err = unpopulate(val, "RecoveryPointAdditionalInfo", &i.RecoveryPointAdditionalInfo)
			delete(rawMsg, key)
		case "recoveryPointDiskConfiguration":
			err = unpopulate(val, "RecoveryPointDiskConfiguration", &i.RecoveryPointDiskConfiguration)
			delete(rawMsg, key)
		case "recoveryPointMoveReadinessInfo":
			err = unpopulate(val, "RecoveryPointMoveReadinessInfo", &i.RecoveryPointMoveReadinessInfo)
			delete(rawMsg, key)
		case "recoveryPointProperties":
			err = unpopulate(val, "RecoveryPointProperties", &i.RecoveryPointProperties)
			delete(rawMsg, key)
		case "recoveryPointTierDetails":
			err = unpopulate(val, "RecoveryPointTierDetails", &i.RecoveryPointTierDetails)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulateDateTimeRFC3339(val, "RecoveryPointTime", &i.RecoveryPointTime)
			delete(rawMsg, key)
		case "recoveryPointType":
			err = unpopulate(val, "RecoveryPointType", &i.RecoveryPointType)
			delete(rawMsg, key)
		case "sourceVMStorageType":
			err = unpopulate(val, "SourceVMStorageType", &i.SourceVMStorageType)
			delete(rawMsg, key)
		case "virtualMachineSize":
			err = unpopulate(val, "VirtualMachineSize", &i.VirtualMachineSize)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &i.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasVMRestoreRequest.
func (i IaasVMRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityGroup", i.AffinityGroup)
	populate(objectMap, "createNewCloudService", i.CreateNewCloudService)
	populate(objectMap, "diskEncryptionSetId", i.DiskEncryptionSetID)
	populate(objectMap, "encryptionDetails", i.EncryptionDetails)
	populate(objectMap, "identityBasedRestoreDetails", i.IdentityBasedRestoreDetails)
	populate(objectMap, "identityInfo", i.IdentityInfo)
	objectMap["objectType"] = "IaasVMRestoreRequest"
	populate(objectMap, "originalStorageAccountOption", i.OriginalStorageAccountOption)
	populate(objectMap, "recoveryPointId", i.RecoveryPointID)
	populate(objectMap, "recoveryType", i.RecoveryType)
	populate(objectMap, "region", i.Region)
	populate(objectMap, "restoreDiskLunList", i.RestoreDiskLunList)
	populate(objectMap, "restoreWithManagedDisks", i.RestoreWithManagedDisks)
	populate(objectMap, "sourceResourceId", i.SourceResourceID)
	populate(objectMap, "storageAccountId", i.StorageAccountID)
	populate(objectMap, "subnetId", i.SubnetID)
	populate(objectMap, "targetDomainNameId", i.TargetDomainNameID)
	populate(objectMap, "targetResourceGroupId", i.TargetResourceGroupID)
	populate(objectMap, "targetVirtualMachineId", i.TargetVirtualMachineID)
	populate(objectMap, "virtualNetworkId", i.VirtualNetworkID)
	populate(objectMap, "zones", i.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasVMRestoreRequest.
func (i *IaasVMRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityGroup":
			err = unpopulate(val, "AffinityGroup", &i.AffinityGroup)
			delete(rawMsg, key)
		case "createNewCloudService":
			err = unpopulate(val, "CreateNewCloudService", &i.CreateNewCloudService)
			delete(rawMsg, key)
		case "diskEncryptionSetId":
			err = unpopulate(val, "DiskEncryptionSetID", &i.DiskEncryptionSetID)
			delete(rawMsg, key)
		case "encryptionDetails":
			err = unpopulate(val, "EncryptionDetails", &i.EncryptionDetails)
			delete(rawMsg, key)
		case "identityBasedRestoreDetails":
			err = unpopulate(val, "IdentityBasedRestoreDetails", &i.IdentityBasedRestoreDetails)
			delete(rawMsg, key)
		case "identityInfo":
			err = unpopulate(val, "IdentityInfo", &i.IdentityInfo)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &i.ObjectType)
			delete(rawMsg, key)
		case "originalStorageAccountOption":
			err = unpopulate(val, "OriginalStorageAccountOption", &i.OriginalStorageAccountOption)
			delete(rawMsg, key)
		case "recoveryPointId":
			err = unpopulate(val, "RecoveryPointID", &i.RecoveryPointID)
			delete(rawMsg, key)
		case "recoveryType":
			err = unpopulate(val, "RecoveryType", &i.RecoveryType)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, "Region", &i.Region)
			delete(rawMsg, key)
		case "restoreDiskLunList":
			err = unpopulate(val, "RestoreDiskLunList", &i.RestoreDiskLunList)
			delete(rawMsg, key)
		case "restoreWithManagedDisks":
			err = unpopulate(val, "RestoreWithManagedDisks", &i.RestoreWithManagedDisks)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &i.SourceResourceID)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, "StorageAccountID", &i.StorageAccountID)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &i.SubnetID)
			delete(rawMsg, key)
		case "targetDomainNameId":
			err = unpopulate(val, "TargetDomainNameID", &i.TargetDomainNameID)
			delete(rawMsg, key)
		case "targetResourceGroupId":
			err = unpopulate(val, "TargetResourceGroupID", &i.TargetResourceGroupID)
			delete(rawMsg, key)
		case "targetVirtualMachineId":
			err = unpopulate(val, "TargetVirtualMachineID", &i.TargetVirtualMachineID)
			delete(rawMsg, key)
		case "virtualNetworkId":
			err = unpopulate(val, "VirtualNetworkID", &i.VirtualNetworkID)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &i.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityBasedRestoreDetails.
func (i IdentityBasedRestoreDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "objectType", i.ObjectType)
	populate(objectMap, "targetStorageAccountId", i.TargetStorageAccountID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityBasedRestoreDetails.
func (i *IdentityBasedRestoreDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &i.ObjectType)
			delete(rawMsg, key)
		case "targetStorageAccountId":
			err = unpopulate(val, "TargetStorageAccountID", &i.TargetStorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityInfo.
func (i IdentityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSystemAssignedIdentity", i.IsSystemAssignedIdentity)
	populate(objectMap, "managedIdentityResourceId", i.ManagedIdentityResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityInfo.
func (i *IdentityInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSystemAssignedIdentity":
			err = unpopulate(val, "IsSystemAssignedIdentity", &i.IsSystemAssignedIdentity)
			delete(rawMsg, key)
		case "managedIdentityResourceId":
			err = unpopulate(val, "ManagedIdentityResourceID", &i.ManagedIdentityResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstantItemRecoveryTarget.
func (i InstantItemRecoveryTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientScripts", i.ClientScripts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstantItemRecoveryTarget.
func (i *InstantItemRecoveryTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientScripts":
			err = unpopulate(val, "ClientScripts", &i.ClientScripts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityId", j.ActivityID)
	populate(objectMap, "backupManagementType", j.BackupManagementType)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "entityFriendlyName", j.EntityFriendlyName)
	objectMap["jobType"] = j.JobType
	populate(objectMap, "operation", j.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Job.
func (j *Job) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, "ActivityID", &j.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &j.BackupManagementType)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &j.EntityFriendlyName)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &j.JobType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &j.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobQueryObject.
func (j JobQueryObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", j.BackupManagementType)
	populateDateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "jobId", j.JobID)
	populate(objectMap, "operation", j.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobQueryObject.
func (j *JobQueryObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &j.BackupManagementType)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, "JobID", &j.JobID)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &j.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobResource.
func (j JobResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", j.ETag)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "location", j.Location)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "tags", j.Tags)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobResource.
func (j *JobResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &j.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &j.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &j.Name)
			delete(rawMsg, key)
		case "properties":
			j.Properties, err = unmarshalJobClassification(val)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &j.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceList.
func (j JobResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobResourceList.
func (j *JobResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &j.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KEKDetails.
func (k KEKDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyBackupData", k.KeyBackupData)
	populate(objectMap, "keyUrl", k.KeyURL)
	populate(objectMap, "keyVaultId", k.KeyVaultID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KEKDetails.
func (k *KEKDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyBackupData":
			err = unpopulate(val, "KeyBackupData", &k.KeyBackupData)
			delete(rawMsg, key)
		case "keyUrl":
			err = unpopulate(val, "KeyURL", &k.KeyURL)
			delete(rawMsg, key)
		case "keyVaultId":
			err = unpopulate(val, "KeyVaultID", &k.KeyVaultID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KPIResourceHealthDetails.
func (k KPIResourceHealthDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceHealthDetails", k.ResourceHealthDetails)
	populate(objectMap, "resourceHealthStatus", k.ResourceHealthStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KPIResourceHealthDetails.
func (k *KPIResourceHealthDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceHealthDetails":
			err = unpopulate(val, "ResourceHealthDetails", &k.ResourceHealthDetails)
			delete(rawMsg, key)
		case "resourceHealthStatus":
			err = unpopulate(val, "ResourceHealthStatus", &k.ResourceHealthStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyAndSecretDetails.
func (k KeyAndSecretDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bekDetails", k.BekDetails)
	populate(objectMap, "encryptionMechanism", k.EncryptionMechanism)
	populate(objectMap, "kekDetails", k.KekDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyAndSecretDetails.
func (k *KeyAndSecretDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bekDetails":
			err = unpopulate(val, "BekDetails", &k.BekDetails)
			delete(rawMsg, key)
		case "encryptionMechanism":
			err = unpopulate(val, "EncryptionMechanism", &k.EncryptionMechanism)
			delete(rawMsg, key)
		case "kekDetails":
			err = unpopulate(val, "KekDetails", &k.KekDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabErrorInfo.
func (m MabErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorString", m.ErrorString)
	populate(objectMap, "recommendations", m.Recommendations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabErrorInfo.
func (m *MabErrorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorString":
			err = unpopulate(val, "ErrorString", &m.ErrorString)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &m.Recommendations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabFileFolderProtectedItem.
func (m MabFileFolderProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", m.BackupManagementType)
	populate(objectMap, "backupSetName", m.BackupSetName)
	populate(objectMap, "computerName", m.ComputerName)
	populate(objectMap, "containerName", m.ContainerName)
	populate(objectMap, "createMode", m.CreateMode)
	populate(objectMap, "deferredDeleteSyncTimeInUTC", m.DeferredDeleteSyncTimeInUTC)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", m.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", m.DeferredDeleteTimeRemaining)
	populate(objectMap, "extendedInfo", m.ExtendedInfo)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", m.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", m.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", m.IsScheduledForDeferredDelete)
	populate(objectMap, "lastBackupStatus", m.LastBackupStatus)
	populateDateTimeRFC3339(objectMap, "lastBackupTime", m.LastBackupTime)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", m.LastRecoveryPoint)
	populate(objectMap, "policyId", m.PolicyID)
	objectMap["protectedItemType"] = "MabFileFolderProtectedItem"
	populate(objectMap, "protectionState", m.ProtectionState)
	populate(objectMap, "resourceGuardOperationRequests", m.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", m.SourceResourceID)
	populate(objectMap, "workloadType", m.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabFileFolderProtectedItem.
func (m *MabFileFolderProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &m.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &m.BackupSetName)
			delete(rawMsg, key)
		case "computerName":
			err = unpopulate(val, "ComputerName", &m.ComputerName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &m.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &m.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteSyncTimeInUTC":
			err = unpopulate(val, "DeferredDeleteSyncTimeInUTC", &m.DeferredDeleteSyncTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &m.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &m.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &m.ExtendedInfo)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &m.FriendlyName)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &m.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &m.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &m.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "lastBackupStatus":
			err = unpopulate(val, "LastBackupStatus", &m.LastBackupStatus)
			delete(rawMsg, key)
		case "lastBackupTime":
			err = unpopulateDateTimeRFC3339(val, "LastBackupTime", &m.LastBackupTime)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &m.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &m.PolicyID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &m.ProtectedItemType)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &m.ProtectionState)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &m.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &m.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &m.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabFileFolderProtectedItemExtendedInfo.
func (m MabFileFolderProtectedItemExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastRefreshedAt", m.LastRefreshedAt)
	populateDateTimeRFC3339(objectMap, "oldestRecoveryPoint", m.OldestRecoveryPoint)
	populate(objectMap, "recoveryPointCount", m.RecoveryPointCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabFileFolderProtectedItemExtendedInfo.
func (m *MabFileFolderProtectedItemExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastRefreshedAt":
			err = unpopulateDateTimeRFC3339(val, "LastRefreshedAt", &m.LastRefreshedAt)
			delete(rawMsg, key)
		case "oldestRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "OldestRecoveryPoint", &m.OldestRecoveryPoint)
			delete(rawMsg, key)
		case "recoveryPointCount":
			err = unpopulate(val, "RecoveryPointCount", &m.RecoveryPointCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabJob.
func (m MabJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsInfo", m.ActionsInfo)
	populate(objectMap, "activityId", m.ActivityID)
	populate(objectMap, "backupManagementType", m.BackupManagementType)
	populate(objectMap, "duration", m.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "entityFriendlyName", m.EntityFriendlyName)
	populate(objectMap, "errorDetails", m.ErrorDetails)
	populate(objectMap, "extendedInfo", m.ExtendedInfo)
	objectMap["jobType"] = "MabJob"
	populate(objectMap, "mabServerName", m.MabServerName)
	populate(objectMap, "mabServerType", m.MabServerType)
	populate(objectMap, "operation", m.Operation)
	populateDateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "workloadType", m.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabJob.
func (m *MabJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsInfo":
			err = unpopulate(val, "ActionsInfo", &m.ActionsInfo)
			delete(rawMsg, key)
		case "activityId":
			err = unpopulate(val, "ActivityID", &m.ActivityID)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &m.BackupManagementType)
			delete(rawMsg, key)
		case "duration":
			err = unpopulate(val, "Duration", &m.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &m.EndTime)
			delete(rawMsg, key)
		case "entityFriendlyName":
			err = unpopulate(val, "EntityFriendlyName", &m.EntityFriendlyName)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, "ErrorDetails", &m.ErrorDetails)
			delete(rawMsg, key)
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &m.ExtendedInfo)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &m.JobType)
			delete(rawMsg, key)
		case "mabServerName":
			err = unpopulate(val, "MabServerName", &m.MabServerName)
			delete(rawMsg, key)
		case "mabServerType":
			err = unpopulate(val, "MabServerType", &m.MabServerType)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &m.Operation)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &m.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &m.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabJobExtendedInfo.
func (m MabJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicErrorMessage", m.DynamicErrorMessage)
	populate(objectMap, "propertyBag", m.PropertyBag)
	populate(objectMap, "tasksList", m.TasksList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabJobExtendedInfo.
func (m *MabJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicErrorMessage":
			err = unpopulate(val, "DynamicErrorMessage", &m.DynamicErrorMessage)
			delete(rawMsg, key)
		case "propertyBag":
			err = unpopulate(val, "PropertyBag", &m.PropertyBag)
			delete(rawMsg, key)
		case "tasksList":
			err = unpopulate(val, "TasksList", &m.TasksList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MabJobTaskDetails.
func (m MabJobTaskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", m.Duration)
	populateDateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populateDateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "taskId", m.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MabJobTaskDetails.
func (m *MabJobTaskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &m.Duration)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &m.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &m.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, "TaskID", &m.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NameInfo.
func (n NameInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "localizedValue", n.LocalizedValue)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NameInfo.
func (n *NameInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "localizedValue":
			err = unpopulate(val, "LocalizedValue", &n.LocalizedValue)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NewErrorResponse.
func (n NewErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", n.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NewErrorResponse.
func (n *NewErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, "Error", &n.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NewErrorResponseError.
func (n NewErrorResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", n.AdditionalInfo)
	populate(objectMap, "code", n.Code)
	populate(objectMap, "details", n.Details)
	populate(objectMap, "message", n.Message)
	populate(objectMap, "target", n.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NewErrorResponseError.
func (n *NewErrorResponseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &n.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &n.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &n.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &n.Message)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &n.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatus.
func (o OperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", o.EndTime)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populateDateTimeRFC3339(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatus.
func (o *OperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &o.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			o.Properties, err = unmarshalOperationStatusExtendedInfoClassification(val)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusError.
func (o OperationStatusError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", o.Code)
	populate(objectMap, "message", o.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusError.
func (o *OperationStatusError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &o.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &o.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusExtendedInfo.
func (o OperationStatusExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = o.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusExtendedInfo.
func (o *OperationStatusExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &o.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusJobExtendedInfo.
func (o OperationStatusJobExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobId", o.JobID)
	objectMap["objectType"] = "OperationStatusJobExtendedInfo"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusJobExtendedInfo.
func (o *OperationStatusJobExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobId":
			err = unpopulate(val, "JobID", &o.JobID)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &o.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusJobsExtendedInfo.
func (o OperationStatusJobsExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "failedJobsError", o.FailedJobsError)
	populate(objectMap, "jobIds", o.JobIDs)
	objectMap["objectType"] = "OperationStatusJobsExtendedInfo"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusJobsExtendedInfo.
func (o *OperationStatusJobsExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failedJobsError":
			err = unpopulate(val, "FailedJobsError", &o.FailedJobsError)
			delete(rawMsg, key)
		case "jobIds":
			err = unpopulate(val, "JobIDs", &o.JobIDs)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &o.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusProvisionILRExtendedInfo.
func (o OperationStatusProvisionILRExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = "OperationStatusProvisionILRExtendedInfo"
	populate(objectMap, "recoveryTarget", o.RecoveryTarget)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusProvisionILRExtendedInfo.
func (o *OperationStatusProvisionILRExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &o.ObjectType)
			delete(rawMsg, key)
		case "recoveryTarget":
			err = unpopulate(val, "RecoveryTarget", &o.RecoveryTarget)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusRecoveryPointExtendedInfo.
func (o OperationStatusRecoveryPointExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deletedBackupItemVersion", o.DeletedBackupItemVersion)
	objectMap["objectType"] = "OperationStatusRecoveryPointExtendedInfo"
	populate(objectMap, "updatedRecoveryPoint", o.UpdatedRecoveryPoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusRecoveryPointExtendedInfo.
func (o *OperationStatusRecoveryPointExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deletedBackupItemVersion":
			err = unpopulate(val, "DeletedBackupItemVersion", &o.DeletedBackupItemVersion)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &o.ObjectType)
			delete(rawMsg, key)
		case "updatedRecoveryPoint":
			o.UpdatedRecoveryPoint, err = unmarshalRecoveryPointClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PointInTimeRange.
func (p PointInTimeRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", p.EndTime)
	populateDateTimeRFC3339(objectMap, "startTime", p.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PointInTimeRange.
func (p *PointInTimeRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateDateTimeRFC3339(val, "EndTime", &p.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateDateTimeRFC3339(val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItem.
func (p ProtectedItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupManagementType", p.BackupManagementType)
	populate(objectMap, "backupSetName", p.BackupSetName)
	populate(objectMap, "containerName", p.ContainerName)
	populate(objectMap, "createMode", p.CreateMode)
	populateDateTimeRFC3339(objectMap, "deferredDeleteTimeInUTC", p.DeferredDeleteTimeInUTC)
	populate(objectMap, "deferredDeleteTimeRemaining", p.DeferredDeleteTimeRemaining)
	populate(objectMap, "isDeferredDeleteScheduleUpcoming", p.IsDeferredDeleteScheduleUpcoming)
	populate(objectMap, "isRehydrate", p.IsRehydrate)
	populate(objectMap, "isScheduledForDeferredDelete", p.IsScheduledForDeferredDelete)
	populateDateTimeRFC3339(objectMap, "lastRecoveryPoint", p.LastRecoveryPoint)
	populate(objectMap, "policyId", p.PolicyID)
	objectMap["protectedItemType"] = p.ProtectedItemType
	populate(objectMap, "resourceGuardOperationRequests", p.ResourceGuardOperationRequests)
	populate(objectMap, "sourceResourceId", p.SourceResourceID)
	populate(objectMap, "workloadType", p.WorkloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItem.
func (p *ProtectedItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &p.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &p.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &p.ContainerName)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, "CreateMode", &p.CreateMode)
			delete(rawMsg, key)
		case "deferredDeleteTimeInUTC":
			err = unpopulateDateTimeRFC3339(val, "DeferredDeleteTimeInUTC", &p.DeferredDeleteTimeInUTC)
			delete(rawMsg, key)
		case "deferredDeleteTimeRemaining":
			err = unpopulate(val, "DeferredDeleteTimeRemaining", &p.DeferredDeleteTimeRemaining)
			delete(rawMsg, key)
		case "isDeferredDeleteScheduleUpcoming":
			err = unpopulate(val, "IsDeferredDeleteScheduleUpcoming", &p.IsDeferredDeleteScheduleUpcoming)
			delete(rawMsg, key)
		case "isRehydrate":
			err = unpopulate(val, "IsRehydrate", &p.IsRehydrate)
			delete(rawMsg, key)
		case "isScheduledForDeferredDelete":
			err = unpopulate(val, "IsScheduledForDeferredDelete", &p.IsScheduledForDeferredDelete)
			delete(rawMsg, key)
		case "lastRecoveryPoint":
			err = unpopulateDateTimeRFC3339(val, "LastRecoveryPoint", &p.LastRecoveryPoint)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &p.PolicyID)
			delete(rawMsg, key)
		case "protectedItemType":
			err = unpopulate(val, "ProtectedItemType", &p.ProtectedItemType)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &p.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &p.SourceResourceID)
			delete(rawMsg, key)
		case "workloadType":
			err = unpopulate(val, "WorkloadType", &p.WorkloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemQueryObject.
func (p ProtectedItemQueryObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupEngineName", p.BackupEngineName)
	populate(objectMap, "backupManagementType", p.BackupManagementType)
	populate(objectMap, "backupSetName", p.BackupSetName)
	populate(objectMap, "containerName", p.ContainerName)
	populate(objectMap, "fabricName", p.FabricName)
	populate(objectMap, "friendlyName", p.FriendlyName)
	populate(objectMap, "healthState", p.HealthState)
	populate(objectMap, "itemType", p.ItemType)
	populate(objectMap, "policyName", p.PolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemQueryObject.
func (p *ProtectedItemQueryObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupEngineName":
			err = unpopulate(val, "BackupEngineName", &p.BackupEngineName)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &p.BackupManagementType)
			delete(rawMsg, key)
		case "backupSetName":
			err = unpopulate(val, "BackupSetName", &p.BackupSetName)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &p.ContainerName)
			delete(rawMsg, key)
		case "fabricName":
			err = unpopulate(val, "FabricName", &p.FabricName)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, "FriendlyName", &p.FriendlyName)
			delete(rawMsg, key)
		case "healthState":
			err = unpopulate(val, "HealthState", &p.HealthState)
			delete(rawMsg, key)
		case "itemType":
			err = unpopulate(val, "ItemType", &p.ItemType)
			delete(rawMsg, key)
		case "policyName":
			err = unpopulate(val, "PolicyName", &p.PolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemResource.
func (p ProtectedItemResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", p.ETag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemResource.
func (p *ProtectedItemResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &p.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &p.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalProtectedItemClassification(val)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemResourceList.
func (p ProtectedItemResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemResourceList.
func (p *ProtectedItemResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPoint.
func (r RecoveryPoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = r.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPoint.
func (r *RecoveryPoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &r.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointDiskConfiguration.
func (r RecoveryPointDiskConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "excludedDiskList", r.ExcludedDiskList)
	populate(objectMap, "includedDiskList", r.IncludedDiskList)
	populate(objectMap, "numberOfDisksAttachedToVm", r.NumberOfDisksAttachedToVM)
	populate(objectMap, "numberOfDisksIncludedInBackup", r.NumberOfDisksIncludedInBackup)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointDiskConfiguration.
func (r *RecoveryPointDiskConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "excludedDiskList":
			err = unpopulate(val, "ExcludedDiskList", &r.ExcludedDiskList)
			delete(rawMsg, key)
		case "includedDiskList":
			err = unpopulate(val, "IncludedDiskList", &r.IncludedDiskList)
			delete(rawMsg, key)
		case "numberOfDisksAttachedToVm":
			err = unpopulate(val, "NumberOfDisksAttachedToVM", &r.NumberOfDisksAttachedToVM)
			delete(rawMsg, key)
		case "numberOfDisksIncludedInBackup":
			err = unpopulate(val, "NumberOfDisksIncludedInBackup", &r.NumberOfDisksIncludedInBackup)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointMoveReadinessInfo.
func (r RecoveryPointMoveReadinessInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", r.AdditionalInfo)
	populate(objectMap, "isReadyForMove", r.IsReadyForMove)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointMoveReadinessInfo.
func (r *RecoveryPointMoveReadinessInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
			err = unpopulate(val, "AdditionalInfo", &r.AdditionalInfo)
			delete(rawMsg, key)
		case "isReadyForMove":
			err = unpopulate(val, "IsReadyForMove", &r.IsReadyForMove)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointProperties.
func (r RecoveryPointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expiryTime", r.ExpiryTime)
	populate(objectMap, "isSoftDeleted", r.IsSoftDeleted)
	populate(objectMap, "ruleName", r.RuleName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointProperties.
func (r *RecoveryPointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulate(val, "ExpiryTime", &r.ExpiryTime)
			delete(rawMsg, key)
		case "isSoftDeleted":
			err = unpopulate(val, "IsSoftDeleted", &r.IsSoftDeleted)
			delete(rawMsg, key)
		case "ruleName":
			err = unpopulate(val, "RuleName", &r.RuleName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointResource.
func (r RecoveryPointResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", r.ETag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointResource.
func (r *RecoveryPointResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &r.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &r.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			r.Properties, err = unmarshalRecoveryPointClassification(val)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointResourceList.
func (r RecoveryPointResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointResourceList.
func (r *RecoveryPointResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointTierInformation.
func (r RecoveryPointTierInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extendedInfo", r.ExtendedInfo)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointTierInformation.
func (r *RecoveryPointTierInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extendedInfo":
			err = unpopulate(val, "ExtendedInfo", &r.ExtendedInfo)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &r.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", r.ETag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &r.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &r.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceHealthDetails.
func (r ResourceHealthDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", r.Code)
	populate(objectMap, "message", r.Message)
	populate(objectMap, "recommendations", r.Recommendations)
	populate(objectMap, "title", r.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceHealthDetails.
func (r *ResourceHealthDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &r.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &r.Message)
			delete(rawMsg, key)
		case "recommendations":
			err = unpopulate(val, "Recommendations", &r.Recommendations)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, "Title", &r.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceList.
func (r ResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceList.
func (r *ResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreFileSpecs.
func (r RestoreFileSpecs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileSpecType", r.FileSpecType)
	populate(objectMap, "path", r.Path)
	populate(objectMap, "targetFolderPath", r.TargetFolderPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreFileSpecs.
func (r *RestoreFileSpecs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileSpecType":
			err = unpopulate(val, "FileSpecType", &r.FileSpecType)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &r.Path)
			delete(rawMsg, key)
		case "targetFolderPath":
			err = unpopulate(val, "TargetFolderPath", &r.TargetFolderPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreRequest.
func (r RestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["objectType"] = r.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreRequest.
func (r *RestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
			err = unpopulate(val, "ObjectType", &r.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDataDirectory.
func (s SQLDataDirectory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logicalName", s.LogicalName)
	populate(objectMap, "path", s.Path)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDataDirectory.
func (s *SQLDataDirectory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logicalName":
			err = unpopulate(val, "LogicalName", &s.LogicalName)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &s.Path)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDataDirectoryMapping.
func (s SQLDataDirectoryMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mappingType", s.MappingType)
	populate(objectMap, "sourceLogicalName", s.SourceLogicalName)
	populate(objectMap, "sourcePath", s.SourcePath)
	populate(objectMap, "targetPath", s.TargetPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDataDirectoryMapping.
func (s *SQLDataDirectoryMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mappingType":
			err = unpopulate(val, "MappingType", &s.MappingType)
			delete(rawMsg, key)
		case "sourceLogicalName":
			err = unpopulate(val, "SourceLogicalName", &s.SourceLogicalName)
			delete(rawMsg, key)
		case "sourcePath":
			err = unpopulate(val, "SourcePath", &s.SourcePath)
			delete(rawMsg, key)
		case "targetPath":
			err = unpopulate(val, "TargetPath", &s.TargetPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetAFSRestoreInfo.
func (t TargetAFSRestoreInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "targetResourceId", t.TargetResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetAFSRestoreInfo.
func (t *TargetAFSRestoreInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "targetResourceId":
			err = unpopulate(val, "TargetResourceID", &t.TargetResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetRestoreInfo.
func (t TargetRestoreInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerId", t.ContainerID)
	populate(objectMap, "databaseName", t.DatabaseName)
	populate(objectMap, "overwriteOption", t.OverwriteOption)
	populate(objectMap, "targetDirectoryForFileRestore", t.TargetDirectoryForFileRestore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetRestoreInfo.
func (t *TargetRestoreInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerId":
			err = unpopulate(val, "ContainerID", &t.ContainerID)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &t.DatabaseName)
			delete(rawMsg, key)
		case "overwriteOption":
			err = unpopulate(val, "OverwriteOption", &t.OverwriteOption)
			delete(rawMsg, key)
		case "targetDirectoryForFileRestore":
			err = unpopulate(val, "TargetDirectoryForFileRestore", &t.TargetDirectoryForFileRestore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadCrrAccessToken.
func (w WorkloadCrrAccessToken) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessTokenString", w.AccessTokenString)
	populate(objectMap, "bMSActiveRegion", w.BMSActiveRegion)
	populate(objectMap, "backupManagementType", w.BackupManagementType)
	populate(objectMap, "containerId", w.ContainerID)
	populate(objectMap, "containerName", w.ContainerName)
	populate(objectMap, "containerType", w.ContainerType)
	populate(objectMap, "coordinatorServiceStampId", w.CoordinatorServiceStampID)
	populate(objectMap, "coordinatorServiceStampUri", w.CoordinatorServiceStampURI)
	populate(objectMap, "datasourceContainerName", w.DatasourceContainerName)
	populate(objectMap, "datasourceId", w.DatasourceID)
	populate(objectMap, "datasourceName", w.DatasourceName)
	populate(objectMap, "datasourceType", w.DatasourceType)
	objectMap["objectType"] = "WorkloadCrrAccessToken"
	populate(objectMap, "policyId", w.PolicyID)
	populate(objectMap, "policyName", w.PolicyName)
	populate(objectMap, "protectableObjectContainerHostOsName", w.ProtectableObjectContainerHostOsName)
	populate(objectMap, "protectableObjectFriendlyName", w.ProtectableObjectFriendlyName)
	populate(objectMap, "protectableObjectParentLogicalContainerName", w.ProtectableObjectParentLogicalContainerName)
	populate(objectMap, "protectableObjectProtectionState", w.ProtectableObjectProtectionState)
	populate(objectMap, "protectableObjectUniqueName", w.ProtectableObjectUniqueName)
	populate(objectMap, "protectableObjectWorkloadType", w.ProtectableObjectWorkloadType)
	populate(objectMap, "protectionContainerId", w.ProtectionContainerID)
	populate(objectMap, "protectionServiceStampId", w.ProtectionServiceStampID)
	populate(objectMap, "protectionServiceStampUri", w.ProtectionServiceStampURI)
	populate(objectMap, "recoveryPointId", w.RecoveryPointID)
	populate(objectMap, "recoveryPointTime", w.RecoveryPointTime)
	populate(objectMap, "resourceGroupName", w.ResourceGroupName)
	populate(objectMap, "resourceId", w.ResourceID)
	populate(objectMap, "resourceName", w.ResourceName)
	populate(objectMap, "rpIsManagedVirtualMachine", w.RpIsManagedVirtualMachine)
	populate(objectMap, "rpOriginalSAOption", w.RpOriginalSAOption)
	populate(objectMap, "rpTierInformation", w.RpTierInformation)
	populate(objectMap, "rpVMSizeDescription", w.RpVMSizeDescription)
	populate(objectMap, "subscriptionId", w.SubscriptionID)
	populate(objectMap, "tokenExtendedInformation", w.TokenExtendedInformation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadCrrAccessToken.
func (w *WorkloadCrrAccessToken) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTokenString":
			err = unpopulate(val, "AccessTokenString", &w.AccessTokenString)
			delete(rawMsg, key)
		case "bMSActiveRegion":
			err = unpopulate(val, "BMSActiveRegion", &w.BMSActiveRegion)
			delete(rawMsg, key)
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &w.BackupManagementType)
			delete(rawMsg, key)
		case "containerId":
			err = unpopulate(val, "ContainerID", &w.ContainerID)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, "ContainerName", &w.ContainerName)
			delete(rawMsg, key)
		case "containerType":
			err = unpopulate(val, "ContainerType", &w.ContainerType)
			delete(rawMsg, key)
		case "coordinatorServiceStampId":
			err = unpopulate(val, "CoordinatorServiceStampID", &w.CoordinatorServiceStampID)
			delete(rawMsg, key)
		case "coordinatorServiceStampUri":
			err = unpopulate(val, "CoordinatorServiceStampURI", &w.CoordinatorServiceStampURI)
			delete(rawMsg, key)
		case "datasourceContainerName":
			err = unpopulate(val, "DatasourceContainerName", &w.DatasourceContainerName)
			delete(rawMsg, key)
		case "datasourceId":
			err = unpopulate(val, "DatasourceID", &w.DatasourceID)
			delete(rawMsg, key)
		case "datasourceName":
			err = unpopulate(val, "DatasourceName", &w.DatasourceName)
			delete(rawMsg, key)
		case "datasourceType":
			err = unpopulate(val, "DatasourceType", &w.DatasourceType)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &w.ObjectType)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &w.PolicyID)
			delete(rawMsg, key)
		case "policyName":
			err = unpopulate(val, "PolicyName", &w.PolicyName)
			delete(rawMsg, key)
		case "protectableObjectContainerHostOsName":
			err = unpopulate(val, "ProtectableObjectContainerHostOsName", &w.ProtectableObjectContainerHostOsName)
			delete(rawMsg, key)
		case "protectableObjectFriendlyName":
			err = unpopulate(val, "ProtectableObjectFriendlyName", &w.ProtectableObjectFriendlyName)
			delete(rawMsg, key)
		case "protectableObjectParentLogicalContainerName":
			err = unpopulate(val, "ProtectableObjectParentLogicalContainerName", &w.ProtectableObjectParentLogicalContainerName)
			delete(rawMsg, key)
		case "protectableObjectProtectionState":
			err = unpopulate(val, "ProtectableObjectProtectionState", &w.ProtectableObjectProtectionState)
			delete(rawMsg, key)
		case "protectableObjectUniqueName":
			err = unpopulate(val, "ProtectableObjectUniqueName", &w.ProtectableObjectUniqueName)
			delete(rawMsg, key)
		case "protectableObjectWorkloadType":
			err = unpopulate(val, "ProtectableObjectWorkloadType", &w.ProtectableObjectWorkloadType)
			delete(rawMsg, key)
		case "protectionContainerId":
			err = unpopulate(val, "ProtectionContainerID", &w.ProtectionContainerID)
			delete(rawMsg, key)
		case "protectionServiceStampId":
			err = unpopulate(val, "ProtectionServiceStampID", &w.ProtectionServiceStampID)
			delete(rawMsg, key)
		case "protectionServiceStampUri":
			err = unpopulate(val, "ProtectionServiceStampURI", &w.ProtectionServiceStampURI)
			delete(rawMsg, key)
		case "recoveryPointId":
			err = unpopulate(val, "RecoveryPointID", &w.RecoveryPointID)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulate(val, "RecoveryPointTime", &w.RecoveryPointTime)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &w.ResourceGroupName)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, "ResourceID", &w.ResourceID)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, "ResourceName", &w.ResourceName)
			delete(rawMsg, key)
		case "rpIsManagedVirtualMachine":
			err = unpopulate(val, "RpIsManagedVirtualMachine", &w.RpIsManagedVirtualMachine)
			delete(rawMsg, key)
		case "rpOriginalSAOption":
			err = unpopulate(val, "RpOriginalSAOption", &w.RpOriginalSAOption)
			delete(rawMsg, key)
		case "rpTierInformation":
			err = unpopulate(val, "RpTierInformation", &w.RpTierInformation)
			delete(rawMsg, key)
		case "rpVMSizeDescription":
			err = unpopulate(val, "RpVMSizeDescription", &w.RpVMSizeDescription)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &w.SubscriptionID)
			delete(rawMsg, key)
		case "tokenExtendedInformation":
			err = unpopulate(val, "TokenExtendedInformation", &w.TokenExtendedInformation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
