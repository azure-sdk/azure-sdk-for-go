//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmigrationdiscovery

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// ServerSitesControllerClient contains the methods for the ServerSitesController group.
// Don't use this type directly, use NewServerSitesControllerClient() instead.
type ServerSitesControllerClient struct {
	internal       *arm.Client
	subscriptionID string
}

// NewServerSitesControllerClient creates a new instance of ServerSitesControllerClient with the specified values.
//   - subscriptionID - The ID of the target subscription.
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - pass nil to accept the default values.
func NewServerSitesControllerClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*ServerSitesControllerClient, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &ServerSitesControllerClient{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// ComputeErrorSummary - Get the error summary for a server site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - The content of the action request
//   - options - ServerSitesControllerClientComputeErrorSummaryOptions contains the optional parameters for the ServerSitesControllerClient.ComputeErrorSummary
//     method.
func (client *ServerSitesControllerClient) ComputeErrorSummary(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientComputeErrorSummaryOptions) (ServerSitesControllerClientComputeErrorSummaryResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.ComputeErrorSummary"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.computeErrorSummaryCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return ServerSitesControllerClientComputeErrorSummaryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientComputeErrorSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientComputeErrorSummaryResponse{}, err
	}
	resp, err := client.computeErrorSummaryHandleResponse(httpResp)
	return resp, err
}

// computeErrorSummaryCreateRequest creates the ComputeErrorSummary request.
func (client *ServerSitesControllerClient) computeErrorSummaryCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientComputeErrorSummaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/computeErrorSummary"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// computeErrorSummaryHandleResponse handles the ComputeErrorSummary response.
func (client *ServerSitesControllerClient) computeErrorSummaryHandleResponse(resp *http.Response) (ServerSitesControllerClientComputeErrorSummaryResponse, error) {
	result := ServerSitesControllerClientComputeErrorSummaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteErrorSummary); err != nil {
		return ServerSitesControllerClientComputeErrorSummaryResponse{}, err
	}
	return result, nil
}

// Computeusage - Get a serve site usage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - The content of the action request
//   - options - ServerSitesControllerClientComputeusageOptions contains the optional parameters for the ServerSitesControllerClient.Computeusage
//     method.
func (client *ServerSitesControllerClient) Computeusage(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientComputeusageOptions) (ServerSitesControllerClientComputeusageResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.Computeusage"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.computeusageCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return ServerSitesControllerClientComputeusageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientComputeusageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientComputeusageResponse{}, err
	}
	resp, err := client.computeusageHandleResponse(httpResp)
	return resp, err
}

// computeusageCreateRequest creates the Computeusage request.
func (client *ServerSitesControllerClient) computeusageCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientComputeusageOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/computeusage"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// computeusageHandleResponse handles the Computeusage response.
func (client *ServerSitesControllerClient) computeusageHandleResponse(resp *http.Response) (ServerSitesControllerClientComputeusageResponse, error) {
	result := ServerSitesControllerClientComputeusageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteUsageResponse); err != nil {
		return ServerSitesControllerClientComputeusageResponse{}, err
	}
	return result, nil
}

// BeginCreate - Create a ServerSiteResource
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - Resource create parameters.
//   - options - ServerSitesControllerClientBeginCreateOptions contains the optional parameters for the ServerSitesControllerClient.BeginCreate
//     method.
func (client *ServerSitesControllerClient) BeginCreate(ctx context.Context, resourceGroupName string, siteName string, body ServerSiteResource, options *ServerSitesControllerClientBeginCreateOptions) (*runtime.Poller[ServerSitesControllerClientCreateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.create(ctx, resourceGroupName, siteName, body, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientCreateResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientCreateResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Create - Create a ServerSiteResource
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) create(ctx context.Context, resourceGroupName string, siteName string, body ServerSiteResource, options *ServerSitesControllerClientBeginCreateOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginCreate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createCreateRequest creates the Create request.
func (client *ServerSitesControllerClient) createCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body ServerSiteResource, options *ServerSitesControllerClientBeginCreateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// Delete - Delete a ServerSiteResource
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - options - ServerSitesControllerClientDeleteOptions contains the optional parameters for the ServerSitesControllerClient.Delete
//     method.
func (client *ServerSitesControllerClient) Delete(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientDeleteOptions) (ServerSitesControllerClientDeleteResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.Delete"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return ServerSitesControllerClientDeleteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientDeleteResponse{}, err
	}
	return ServerSitesControllerClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *ServerSitesControllerClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginExportApplications - Method to generate report containing machine and the deep discovery of the application installed
// in the machine.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - The content of the action request
//   - options - ServerSitesControllerClientBeginExportApplicationsOptions contains the optional parameters for the ServerSitesControllerClient.BeginExportApplications
//     method.
func (client *ServerSitesControllerClient) BeginExportApplications(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientBeginExportApplicationsOptions) (*runtime.Poller[ServerSitesControllerClientExportApplicationsResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.exportApplications(ctx, resourceGroupName, siteName, body, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientExportApplicationsResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientExportApplicationsResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ExportApplications - Method to generate report containing machine and the deep discovery of the application installed in
// the machine.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) exportApplications(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientBeginExportApplicationsOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginExportApplications"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportApplicationsCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// exportApplicationsCreateRequest creates the ExportApplications request.
func (client *ServerSitesControllerClient) exportApplicationsCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body any, options *ServerSitesControllerClientBeginExportApplicationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/exportApplications"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginExportMachineErrors - Method to generate report containing machine and the errors encountered during guest discovery
// of the machine.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - The content of the action request
//   - options - ServerSitesControllerClientBeginExportMachineErrorsOptions contains the optional parameters for the ServerSitesControllerClient.BeginExportMachineErrors
//     method.
func (client *ServerSitesControllerClient) BeginExportMachineErrors(ctx context.Context, resourceGroupName string, siteName string, body ExportMachineErrorsRequest, options *ServerSitesControllerClientBeginExportMachineErrorsOptions) (*runtime.Poller[ServerSitesControllerClientExportMachineErrorsResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.exportMachineErrors(ctx, resourceGroupName, siteName, body, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientExportMachineErrorsResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientExportMachineErrorsResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ExportMachineErrors - Method to generate report containing machine and the errors encountered during guest discovery of
// the machine.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) exportMachineErrors(ctx context.Context, resourceGroupName string, siteName string, body ExportMachineErrorsRequest, options *ServerSitesControllerClientBeginExportMachineErrorsOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginExportMachineErrors"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportMachineErrorsCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// exportMachineErrorsCreateRequest creates the ExportMachineErrors request.
func (client *ServerSitesControllerClient) exportMachineErrorsCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body ExportMachineErrorsRequest, options *ServerSitesControllerClientBeginExportMachineErrorsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/exportMachineErrors"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// Get - Get a ServerSiteResource
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - options - ServerSitesControllerClientGetOptions contains the optional parameters for the ServerSitesControllerClient.Get
//     method.
func (client *ServerSitesControllerClient) Get(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientGetOptions) (ServerSitesControllerClientGetResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.Get"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return ServerSitesControllerClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *ServerSitesControllerClient) getCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *ServerSitesControllerClient) getHandleResponse(resp *http.Response) (ServerSitesControllerClientGetResponse, error) {
	result := ServerSitesControllerClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteResource); err != nil {
		return ServerSitesControllerClientGetResponse{}, err
	}
	return result, nil
}

// NewListByResourceGroupPager - List ServerSiteResource resources by resource group
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - options - ServerSitesControllerClientListByResourceGroupOptions contains the optional parameters for the ServerSitesControllerClient.NewListByResourceGroupPager
//     method.
func (client *ServerSitesControllerClient) NewListByResourceGroupPager(resourceGroupName string, options *ServerSitesControllerClientListByResourceGroupOptions) *runtime.Pager[ServerSitesControllerClientListByResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[ServerSitesControllerClientListByResourceGroupResponse]{
		More: func(page ServerSitesControllerClientListByResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ServerSitesControllerClientListByResourceGroupResponse) (ServerSitesControllerClientListByResourceGroupResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ServerSitesControllerClient.NewListByResourceGroupPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
			}, nil)
			if err != nil {
				return ServerSitesControllerClientListByResourceGroupResponse{}, err
			}
			return client.listByResourceGroupHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *ServerSitesControllerClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *ServerSitesControllerClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *ServerSitesControllerClient) listByResourceGroupHandleResponse(resp *http.Response) (ServerSitesControllerClientListByResourceGroupResponse, error) {
	result := ServerSitesControllerClientListByResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteResourceListResult); err != nil {
		return ServerSitesControllerClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListBySubscriptionPager - List ServerSiteResource resources by subscription ID
//
// Generated from API version 2023-10-01-preview
//   - options - ServerSitesControllerClientListBySubscriptionOptions contains the optional parameters for the ServerSitesControllerClient.NewListBySubscriptionPager
//     method.
func (client *ServerSitesControllerClient) NewListBySubscriptionPager(options *ServerSitesControllerClientListBySubscriptionOptions) *runtime.Pager[ServerSitesControllerClientListBySubscriptionResponse] {
	return runtime.NewPager(runtime.PagingHandler[ServerSitesControllerClientListBySubscriptionResponse]{
		More: func(page ServerSitesControllerClientListBySubscriptionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ServerSitesControllerClientListBySubscriptionResponse) (ServerSitesControllerClientListBySubscriptionResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "ServerSitesControllerClient.NewListBySubscriptionPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBySubscriptionCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ServerSitesControllerClientListBySubscriptionResponse{}, err
			}
			return client.listBySubscriptionHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBySubscriptionCreateRequest creates the ListBySubscription request.
func (client *ServerSitesControllerClient) listBySubscriptionCreateRequest(ctx context.Context, options *ServerSitesControllerClientListBySubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.OffAzure/serverSites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBySubscriptionHandleResponse handles the ListBySubscription response.
func (client *ServerSitesControllerClient) listBySubscriptionHandleResponse(resp *http.Response) (ServerSitesControllerClientListBySubscriptionResponse, error) {
	result := ServerSitesControllerClientListBySubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteResourceListResult); err != nil {
		return ServerSitesControllerClientListBySubscriptionResponse{}, err
	}
	return result, nil
}

// ListHealthSummary - Method to get site health summary.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - options - ServerSitesControllerClientListHealthSummaryOptions contains the optional parameters for the ServerSitesControllerClient.ListHealthSummary
//     method.
func (client *ServerSitesControllerClient) ListHealthSummary(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientListHealthSummaryOptions) (ServerSitesControllerClientListHealthSummaryResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.ListHealthSummary"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listHealthSummaryCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return ServerSitesControllerClientListHealthSummaryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientListHealthSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientListHealthSummaryResponse{}, err
	}
	resp, err := client.listHealthSummaryHandleResponse(httpResp)
	return resp, err
}

// listHealthSummaryCreateRequest creates the ListHealthSummary request.
func (client *ServerSitesControllerClient) listHealthSummaryCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientListHealthSummaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/listHealthSummary"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHealthSummaryHandleResponse handles the ListHealthSummary response.
func (client *ServerSitesControllerClient) listHealthSummaryHandleResponse(resp *http.Response) (ServerSitesControllerClientListHealthSummaryResponse, error) {
	result := ServerSitesControllerClientListHealthSummaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteHealthSummaryCollection); err != nil {
		return ServerSitesControllerClientListHealthSummaryResponse{}, err
	}
	return result, nil
}

// BeginRefreshSite - Operation to refresh a site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - options - ServerSitesControllerClientBeginRefreshSiteOptions contains the optional parameters for the ServerSitesControllerClient.BeginRefreshSite
//     method.
func (client *ServerSitesControllerClient) BeginRefreshSite(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientBeginRefreshSiteOptions) (*runtime.Poller[ServerSitesControllerClientRefreshSiteResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.refreshSite(ctx, resourceGroupName, siteName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientRefreshSiteResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientRefreshSiteResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// RefreshSite - Operation to refresh a site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) refreshSite(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientBeginRefreshSiteOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginRefreshSite"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.refreshSiteCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// refreshSiteCreateRequest creates the RefreshSite request.
func (client *ServerSitesControllerClient) refreshSiteCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientBeginRefreshSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/refreshSite"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Summary - Method to get site usage.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - options - ServerSitesControllerClientSummaryOptions contains the optional parameters for the ServerSitesControllerClient.Summary
//     method.
func (client *ServerSitesControllerClient) Summary(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientSummaryOptions) (ServerSitesControllerClientSummaryResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.Summary"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.summaryCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return ServerSitesControllerClientSummaryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientSummaryResponse{}, err
	}
	resp, err := client.summaryHandleResponse(httpResp)
	return resp, err
}

// summaryCreateRequest creates the Summary request.
func (client *ServerSitesControllerClient) summaryCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *ServerSitesControllerClientSummaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/summary"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// summaryHandleResponse handles the Summary response.
func (client *ServerSitesControllerClient) summaryHandleResponse(resp *http.Response) (ServerSitesControllerClientSummaryResponse, error) {
	result := ServerSitesControllerClientSummaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteUsage); err != nil {
		return ServerSitesControllerClientSummaryResponse{}, err
	}
	return result, nil
}

// Update - Update a ServerSiteResource
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - body - The resource properties to be updated.
//   - options - ServerSitesControllerClientUpdateOptions contains the optional parameters for the ServerSitesControllerClient.Update
//     method.
func (client *ServerSitesControllerClient) Update(ctx context.Context, resourceGroupName string, siteName string, body ServerSiteResourceUpdate, options *ServerSitesControllerClientUpdateOptions) (ServerSitesControllerClientUpdateResponse, error) {
	var err error
	const operationName = "ServerSitesControllerClient.Update"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateCreateRequest(ctx, resourceGroupName, siteName, body, options)
	if err != nil {
		return ServerSitesControllerClientUpdateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ServerSitesControllerClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ServerSitesControllerClientUpdateResponse{}, err
	}
	resp, err := client.updateHandleResponse(httpResp)
	return resp, err
}

// updateCreateRequest creates the Update request.
func (client *ServerSitesControllerClient) updateCreateRequest(ctx context.Context, resourceGroupName string, siteName string, body ServerSiteResourceUpdate, options *ServerSitesControllerClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// updateHandleResponse handles the Update response.
func (client *ServerSitesControllerClient) updateHandleResponse(resp *http.Response) (ServerSitesControllerClientUpdateResponse, error) {
	result := ServerSitesControllerClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ServerSiteResource); err != nil {
		return ServerSitesControllerClientUpdateResponse{}, err
	}
	return result, nil
}

// BeginUpdateDependencyMapStatus - Method to enable disable dependency map status for machines in a site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - mapRequest - The content of the action request
//   - options - ServerSitesControllerClientBeginUpdateDependencyMapStatusOptions contains the optional parameters for the ServerSitesControllerClient.BeginUpdateDependencyMapStatus
//     method.
func (client *ServerSitesControllerClient) BeginUpdateDependencyMapStatus(ctx context.Context, resourceGroupName string, siteName string, mapRequest UpdateMachineDepMapStatus, options *ServerSitesControllerClientBeginUpdateDependencyMapStatusOptions) (*runtime.Poller[ServerSitesControllerClientUpdateDependencyMapStatusResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.updateDependencyMapStatus(ctx, resourceGroupName, siteName, mapRequest, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientUpdateDependencyMapStatusResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientUpdateDependencyMapStatusResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// UpdateDependencyMapStatus - Method to enable disable dependency map status for machines in a site.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) updateDependencyMapStatus(ctx context.Context, resourceGroupName string, siteName string, mapRequest UpdateMachineDepMapStatus, options *ServerSitesControllerClientBeginUpdateDependencyMapStatusOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginUpdateDependencyMapStatus"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateDependencyMapStatusCreateRequest(ctx, resourceGroupName, siteName, mapRequest, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// updateDependencyMapStatusCreateRequest creates the UpdateDependencyMapStatus request.
func (client *ServerSitesControllerClient) updateDependencyMapStatusCreateRequest(ctx context.Context, resourceGroupName string, siteName string, mapRequest UpdateMachineDepMapStatus, options *ServerSitesControllerClientBeginUpdateDependencyMapStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/updateDependencyMapStatus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, mapRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginUpdateProperties - Operation to update custom properties for servers
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - siteName - Site name
//   - metaData - The content of the action request
//   - options - ServerSitesControllerClientBeginUpdatePropertiesOptions contains the optional parameters for the ServerSitesControllerClient.BeginUpdateProperties
//     method.
func (client *ServerSitesControllerClient) BeginUpdateProperties(ctx context.Context, resourceGroupName string, siteName string, metaData MachineMetadataCollection, options *ServerSitesControllerClientBeginUpdatePropertiesOptions) (*runtime.Poller[ServerSitesControllerClientUpdatePropertiesResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.updateProperties(ctx, resourceGroupName, siteName, metaData, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ServerSitesControllerClientUpdatePropertiesResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ServerSitesControllerClientUpdatePropertiesResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// UpdateProperties - Operation to update custom properties for servers
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2023-10-01-preview
func (client *ServerSitesControllerClient) updateProperties(ctx context.Context, resourceGroupName string, siteName string, metaData MachineMetadataCollection, options *ServerSitesControllerClientBeginUpdatePropertiesOptions) (*http.Response, error) {
	var err error
	const operationName = "ServerSitesControllerClient.BeginUpdateProperties"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updatePropertiesCreateRequest(ctx, resourceGroupName, siteName, metaData, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// updatePropertiesCreateRequest creates the UpdateProperties request.
func (client *ServerSitesControllerClient) updatePropertiesCreateRequest(ctx context.Context, resourceGroupName string, siteName string, metaData MachineMetadataCollection, options *ServerSitesControllerClientBeginUpdatePropertiesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OffAzure/serverSites/{siteName}/updateProperties"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2023-10-01-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, metaData); err != nil {
		return nil, err
	}
	return req, nil
}
