//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armoracledatabase

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AddRemoveDbNode.
func (a AddRemoveDbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbServers", a.DbServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddRemoveDbNode.
func (a *AddRemoveDbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbServers":
			err = unpopulate(val, "DbServers", &a.DbServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudAccountDetails.
func (c CloudAccountDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloudAccountHomeRegion", c.CloudAccountHomeRegion)
	populate(objectMap, "cloudAccountName", c.CloudAccountName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudAccountDetails.
func (c *CloudAccountDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudAccountHomeRegion":
			err = unpopulate(val, "CloudAccountHomeRegion", &c.CloudAccountHomeRegion)
			delete(rawMsg, key)
		case "cloudAccountName":
			err = unpopulate(val, "CloudAccountName", &c.CloudAccountName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructure.
func (c CloudExadataInfrastructure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructure.
func (c *CloudExadataInfrastructure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureListResult.
func (c CloudExadataInfrastructureListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureListResult.
func (c *CloudExadataInfrastructureListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureProperties.
func (c CloudExadataInfrastructureProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activatedStorageCount", c.ActivatedStorageCount)
	populate(objectMap, "additionalStorageCount", c.AdditionalStorageCount)
	populate(objectMap, "availableStorageSizeInGbs", c.AvailableStorageSizeInGbs)
	populate(objectMap, "cpuCount", c.CPUCount)
	populate(objectMap, "computeCount", c.ComputeCount)
	populate(objectMap, "customerContacts", c.CustomerContacts)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerVersion", c.DbServerVersion)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "estimatedPatchingTime", c.EstimatedPatchingTime)
	populate(objectMap, "lastMaintenanceRunId", c.LastMaintenanceRunID)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "maintenanceWindow", c.MaintenanceWindow)
	populate(objectMap, "maxCpuCount", c.MaxCPUCount)
	populate(objectMap, "maxDataStorageInTbs", c.MaxDataStorageInTbs)
	populate(objectMap, "maxDbNodeStorageSizeInGbs", c.MaxDbNodeStorageSizeInGbs)
	populate(objectMap, "maxMemoryInGbs", c.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "monthlyDbServerVersion", c.MonthlyDbServerVersion)
	populate(objectMap, "monthlyStorageServerVersion", c.MonthlyStorageServerVersion)
	populate(objectMap, "nextMaintenanceRunId", c.NextMaintenanceRunID)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageCount", c.StorageCount)
	populate(objectMap, "storageServerVersion", c.StorageServerVersion)
	populate(objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "totalStorageSizeInGbs", c.TotalStorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureProperties.
func (c *CloudExadataInfrastructureProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activatedStorageCount":
			err = unpopulate(val, "ActivatedStorageCount", &c.ActivatedStorageCount)
			delete(rawMsg, key)
		case "additionalStorageCount":
			err = unpopulate(val, "AdditionalStorageCount", &c.AdditionalStorageCount)
			delete(rawMsg, key)
		case "availableStorageSizeInGbs":
			err = unpopulate(val, "AvailableStorageSizeInGbs", &c.AvailableStorageSizeInGbs)
			delete(rawMsg, key)
		case "cpuCount":
			err = unpopulate(val, "CPUCount", &c.CPUCount)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &c.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &c.CustomerContacts)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerVersion":
			err = unpopulate(val, "DbServerVersion", &c.DbServerVersion)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "estimatedPatchingTime":
			err = unpopulate(val, "EstimatedPatchingTime", &c.EstimatedPatchingTime)
			delete(rawMsg, key)
		case "lastMaintenanceRunId":
			err = unpopulate(val, "LastMaintenanceRunID", &c.LastMaintenanceRunID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "maintenanceWindow":
			err = unpopulate(val, "MaintenanceWindow", &c.MaintenanceWindow)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &c.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDataStorageInTbs":
			err = unpopulate(val, "MaxDataStorageInTbs", &c.MaxDataStorageInTbs)
			delete(rawMsg, key)
		case "maxDbNodeStorageSizeInGbs":
			err = unpopulate(val, "MaxDbNodeStorageSizeInGbs", &c.MaxDbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &c.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "monthlyDbServerVersion":
			err = unpopulate(val, "MonthlyDbServerVersion", &c.MonthlyDbServerVersion)
			delete(rawMsg, key)
		case "monthlyStorageServerVersion":
			err = unpopulate(val, "MonthlyStorageServerVersion", &c.MonthlyStorageServerVersion)
			delete(rawMsg, key)
		case "nextMaintenanceRunId":
			err = unpopulate(val, "NextMaintenanceRunID", &c.NextMaintenanceRunID)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageCount":
			err = unpopulate(val, "StorageCount", &c.StorageCount)
			delete(rawMsg, key)
		case "storageServerVersion":
			err = unpopulate(val, "StorageServerVersion", &c.StorageServerVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulate(val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "totalStorageSizeInGbs":
			err = unpopulate(val, "TotalStorageSizeInGbs", &c.TotalStorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureUpdate.
func (c CloudExadataInfrastructureUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureUpdate.
func (c *CloudExadataInfrastructureUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMCluster.
func (c CloudVMCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMCluster.
func (c *CloudVMCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterListResult.
func (c CloudVMClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterListResult.
func (c *CloudVMClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterProperties.
func (c CloudVMClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupSubnetCidr", c.BackupSubnetCidr)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "cloudExadataInfrastructureId", c.CloudExadataInfrastructureID)
	populate(objectMap, "clusterName", c.ClusterName)
	populate(objectMap, "compartmentId", c.CompartmentID)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStoragePercentage", c.DataStoragePercentage)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServers", c.DbServers)
	populate(objectMap, "diskRedundancy", c.DiskRedundancy)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "domain", c.Domain)
	populate(objectMap, "giVersion", c.GiVersion)
	populate(objectMap, "hostname", c.Hostname)
	populate(objectMap, "iormConfigCache", c.IormConfigCache)
	populate(objectMap, "isLocalBackupEnabled", c.IsLocalBackupEnabled)
	populate(objectMap, "isSparseDiskgroupEnabled", c.IsSparseDiskgroupEnabled)
	populate(objectMap, "lastUpdateHistoryEntryId", c.LastUpdateHistoryEntryID)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "listenerPort", c.ListenerPort)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "nodeCount", c.NodeCount)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "scanDnsName", c.ScanDNSName)
	populate(objectMap, "scanDnsRecordId", c.ScanDNSRecordID)
	populate(objectMap, "scanIpIds", c.ScanIPIDs)
	populate(objectMap, "scanListenerPortTcp", c.ScanListenerPortTCP)
	populate(objectMap, "scanListenerPortTcpSsl", c.ScanListenerPortTCPSSL)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	populate(objectMap, "subnetId", c.SubnetID)
	populate(objectMap, "subnetOcid", c.SubnetOcid)
	populate(objectMap, "systemVersion", c.SystemVersion)
	populateDateTimeRFC3339(objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "timeZone", c.TimeZone)
	populate(objectMap, "vipIds", c.VipIDs)
	populate(objectMap, "vnetId", c.VnetID)
	populate(objectMap, "zoneId", c.ZoneID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterProperties.
func (c *CloudVMClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupSubnetCidr":
			err = unpopulate(val, "BackupSubnetCidr", &c.BackupSubnetCidr)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "cloudExadataInfrastructureId":
			err = unpopulate(val, "CloudExadataInfrastructureID", &c.CloudExadataInfrastructureID)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &c.ClusterName)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &c.CompartmentID)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStoragePercentage":
			err = unpopulate(val, "DataStoragePercentage", &c.DataStoragePercentage)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServers":
			err = unpopulate(val, "DbServers", &c.DbServers)
			delete(rawMsg, key)
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &c.DiskRedundancy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &c.Domain)
			delete(rawMsg, key)
		case "giVersion":
			err = unpopulate(val, "GiVersion", &c.GiVersion)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &c.Hostname)
			delete(rawMsg, key)
		case "iormConfigCache":
			err = unpopulate(val, "IormConfigCache", &c.IormConfigCache)
			delete(rawMsg, key)
		case "isLocalBackupEnabled":
			err = unpopulate(val, "IsLocalBackupEnabled", &c.IsLocalBackupEnabled)
			delete(rawMsg, key)
		case "isSparseDiskgroupEnabled":
			err = unpopulate(val, "IsSparseDiskgroupEnabled", &c.IsSparseDiskgroupEnabled)
			delete(rawMsg, key)
		case "lastUpdateHistoryEntryId":
			err = unpopulate(val, "LastUpdateHistoryEntryID", &c.LastUpdateHistoryEntryID)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &c.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &c.NodeCount)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &c.ScanDNSName)
			delete(rawMsg, key)
		case "scanDnsRecordId":
			err = unpopulate(val, "ScanDNSRecordID", &c.ScanDNSRecordID)
			delete(rawMsg, key)
		case "scanIpIds":
			err = unpopulate(val, "ScanIPIDs", &c.ScanIPIDs)
			delete(rawMsg, key)
		case "scanListenerPortTcp":
			err = unpopulate(val, "ScanListenerPortTCP", &c.ScanListenerPortTCP)
			delete(rawMsg, key)
		case "scanListenerPortTcpSsl":
			err = unpopulate(val, "ScanListenerPortTCPSSL", &c.ScanListenerPortTCPSSL)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &c.SubnetID)
			delete(rawMsg, key)
		case "subnetOcid":
			err = unpopulate(val, "SubnetOcid", &c.SubnetOcid)
			delete(rawMsg, key)
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &c.SystemVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &c.TimeZone)
			delete(rawMsg, key)
		case "vipIds":
			err = unpopulate(val, "VipIDs", &c.VipIDs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &c.VnetID)
			delete(rawMsg, key)
		case "zoneId":
			err = unpopulate(val, "ZoneID", &c.ZoneID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdate.
func (c CloudVMClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdate.
func (c *CloudVMClusterUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdateProperties.
func (c CloudVMClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdateProperties.
func (c *CloudVMClusterUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerContact.
func (c CustomerContact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "email", c.Email)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerContact.
func (c *CustomerContact) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "email":
			err = unpopulate(val, "Email", &c.Email)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateView.
func (d DNSPrivateView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateView.
func (d *DNSPrivateView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewListResult.
func (d DNSPrivateViewListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewListResult.
func (d *DNSPrivateViewListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewProperties.
func (d DNSPrivateViewProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populateDateTimeRFC3339(objectMap, "timeUpdated", d.TimeUpdated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewProperties.
func (d *DNSPrivateViewProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeUpdated":
			err = unpopulateDateTimeRFC3339(val, "TimeUpdated", &d.TimeUpdated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZone.
func (d DNSPrivateZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZone.
func (d *DNSPrivateZone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneListResult.
func (d DNSPrivateZoneListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneListResult.
func (d *DNSPrivateZoneListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneProperties.
func (d DNSPrivateZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populate(objectMap, "serial", d.Serial)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "version", d.Version)
	populate(objectMap, "viewId", d.ViewID)
	populate(objectMap, "zoneType", d.ZoneType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneProperties.
func (d *DNSPrivateZoneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "serial":
			err = unpopulate(val, "Serial", &d.Serial)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		case "viewId":
			err = unpopulate(val, "ViewID", &d.ViewID)
			delete(rawMsg, key)
		case "zoneType":
			err = unpopulate(val, "ZoneType", &d.ZoneType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionOptions.
func (d DataCollectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDiagnosticsEventsEnabled", d.IsDiagnosticsEventsEnabled)
	populate(objectMap, "isHealthMonitoringEnabled", d.IsHealthMonitoringEnabled)
	populate(objectMap, "isIncidentLogsEnabled", d.IsIncidentLogsEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionOptions.
func (d *DataCollectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDiagnosticsEventsEnabled":
			err = unpopulate(val, "IsDiagnosticsEventsEnabled", &d.IsDiagnosticsEventsEnabled)
			delete(rawMsg, key)
		case "isHealthMonitoringEnabled":
			err = unpopulate(val, "IsHealthMonitoringEnabled", &d.IsHealthMonitoringEnabled)
			delete(rawMsg, key)
		case "isIncidentLogsEnabled":
			err = unpopulate(val, "IsIncidentLogsEnabled", &d.IsIncidentLogsEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DayOfWeek.
func (d DayOfWeek) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DayOfWeek.
func (d *DayOfWeek) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbIormConfig.
func (d DbIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbName", d.DbName)
	populate(objectMap, "flashCacheLimit", d.FlashCacheLimit)
	populate(objectMap, "share", d.Share)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbIormConfig.
func (d *DbIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbName":
			err = unpopulate(val, "DbName", &d.DbName)
			delete(rawMsg, key)
		case "flashCacheLimit":
			err = unpopulate(val, "FlashCacheLimit", &d.FlashCacheLimit)
			delete(rawMsg, key)
		case "share":
			err = unpopulate(val, "Share", &d.Share)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNode.
func (d DbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNode.
func (d *DbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeListResult.
func (d DbNodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeListResult.
func (d *DbNodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeProperties.
func (d DbNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDetails", d.AdditionalDetails)
	populate(objectMap, "backupIpId", d.BackupIPID)
	populate(objectMap, "backupVnic2Id", d.BackupVnic2ID)
	populate(objectMap, "backupVnicId", d.BackupVnicID)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerId", d.DbServerID)
	populate(objectMap, "dbSystemId", d.DbSystemID)
	populate(objectMap, "faultDomain", d.FaultDomain)
	populate(objectMap, "hostIpId", d.HostIPID)
	populate(objectMap, "hostname", d.Hostname)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "maintenanceType", d.MaintenanceType)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "softwareStorageSizeInGb", d.SoftwareStorageSizeInGb)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceWindowEnd", d.TimeMaintenanceWindowEnd)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceWindowStart", d.TimeMaintenanceWindowStart)
	populate(objectMap, "vnic2Id", d.Vnic2ID)
	populate(objectMap, "vnicId", d.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeProperties.
func (d *DbNodeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDetails":
			err = unpopulate(val, "AdditionalDetails", &d.AdditionalDetails)
			delete(rawMsg, key)
		case "backupIpId":
			err = unpopulate(val, "BackupIPID", &d.BackupIPID)
			delete(rawMsg, key)
		case "backupVnic2Id":
			err = unpopulate(val, "BackupVnic2ID", &d.BackupVnic2ID)
			delete(rawMsg, key)
		case "backupVnicId":
			err = unpopulate(val, "BackupVnicID", &d.BackupVnicID)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerId":
			err = unpopulate(val, "DbServerID", &d.DbServerID)
			delete(rawMsg, key)
		case "dbSystemId":
			err = unpopulate(val, "DbSystemID", &d.DbSystemID)
			delete(rawMsg, key)
		case "faultDomain":
			err = unpopulate(val, "FaultDomain", &d.FaultDomain)
			delete(rawMsg, key)
		case "hostIpId":
			err = unpopulate(val, "HostIPID", &d.HostIPID)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &d.Hostname)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "maintenanceType":
			err = unpopulate(val, "MaintenanceType", &d.MaintenanceType)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "softwareStorageSizeInGb":
			err = unpopulate(val, "SoftwareStorageSizeInGb", &d.SoftwareStorageSizeInGb)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeMaintenanceWindowEnd":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceWindowEnd", &d.TimeMaintenanceWindowEnd)
			delete(rawMsg, key)
		case "timeMaintenanceWindowStart":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceWindowStart", &d.TimeMaintenanceWindowStart)
			delete(rawMsg, key)
		case "vnic2Id":
			err = unpopulate(val, "Vnic2ID", &d.Vnic2ID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &d.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServer.
func (d DbServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServer.
func (d *DbServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerListResult.
func (d DbServerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerListResult.
func (d *DbServerListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerPatchingDetails.
func (d DbServerPatchingDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedPatchDuration", d.EstimatedPatchDuration)
	populate(objectMap, "patchingStatus", d.PatchingStatus)
	populateDateTimeRFC3339(objectMap, "timePatchingEnded", d.TimePatchingEnded)
	populateDateTimeRFC3339(objectMap, "timePatchingStarted", d.TimePatchingStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerPatchingDetails.
func (d *DbServerPatchingDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedPatchDuration":
			err = unpopulate(val, "EstimatedPatchDuration", &d.EstimatedPatchDuration)
			delete(rawMsg, key)
		case "patchingStatus":
			err = unpopulate(val, "PatchingStatus", &d.PatchingStatus)
			delete(rawMsg, key)
		case "timePatchingEnded":
			err = unpopulateDateTimeRFC3339(val, "TimePatchingEnded", &d.TimePatchingEnded)
			delete(rawMsg, key)
		case "timePatchingStarted":
			err = unpopulateDateTimeRFC3339(val, "TimePatchingStarted", &d.TimePatchingStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerProperties.
func (d DbServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autonomousVmClusterIds", d.AutonomousVMClusterIDs)
	populate(objectMap, "autonomousVirtualMachineIds", d.AutonomousVirtualMachineIDs)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "compartmentId", d.CompartmentID)
	populate(objectMap, "dbNodeIds", d.DbNodeIDs)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerPatchingDetails", d.DbServerPatchingDetails)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "exadataInfrastructureId", d.ExadataInfrastructureID)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "maxCpuCount", d.MaxCPUCount)
	populate(objectMap, "maxDbNodeStorageInGbs", d.MaxDbNodeStorageInGbs)
	populate(objectMap, "maxMemoryInGbs", d.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "shape", d.Shape)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "vmClusterIds", d.VMClusterIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerProperties.
func (d *DbServerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autonomousVmClusterIds":
			err = unpopulate(val, "AutonomousVMClusterIDs", &d.AutonomousVMClusterIDs)
			delete(rawMsg, key)
		case "autonomousVirtualMachineIds":
			err = unpopulate(val, "AutonomousVirtualMachineIDs", &d.AutonomousVirtualMachineIDs)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &d.CompartmentID)
			delete(rawMsg, key)
		case "dbNodeIds":
			err = unpopulate(val, "DbNodeIDs", &d.DbNodeIDs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerPatchingDetails":
			err = unpopulate(val, "DbServerPatchingDetails", &d.DbServerPatchingDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "exadataInfrastructureId":
			err = unpopulate(val, "ExadataInfrastructureID", &d.ExadataInfrastructureID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &d.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDbNodeStorageInGbs":
			err = unpopulate(val, "MaxDbNodeStorageInGbs", &d.MaxDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &d.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &d.Shape)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "vmClusterIds":
			err = unpopulate(val, "VMClusterIDs", &d.VMClusterIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShape.
func (d DbSystemShape) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShape.
func (d *DbSystemShape) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeListResult.
func (d DbSystemShapeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeListResult.
func (d *DbSystemShapeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeProperties.
func (d DbSystemShapeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableCoreCount", d.AvailableCoreCount)
	populate(objectMap, "availableCoreCountPerNode", d.AvailableCoreCountPerNode)
	populate(objectMap, "availableDataStorageInTbs", d.AvailableDataStorageInTbs)
	populate(objectMap, "availableDataStoragePerServerInTbs", d.AvailableDataStoragePerServerInTbs)
	populate(objectMap, "availableDbNodePerNodeInGbs", d.AvailableDbNodePerNodeInGbs)
	populate(objectMap, "availableDbNodeStorageInGbs", d.AvailableDbNodeStorageInGbs)
	populate(objectMap, "availableMemoryInGbs", d.AvailableMemoryInGbs)
	populate(objectMap, "availableMemoryPerNodeInGbs", d.AvailableMemoryPerNodeInGbs)
	populate(objectMap, "coreCountIncrement", d.CoreCountIncrement)
	populate(objectMap, "maxStorageCount", d.MaxStorageCount)
	populate(objectMap, "maximumNodeCount", d.MaximumNodeCount)
	populate(objectMap, "minCoreCountPerNode", d.MinCoreCountPerNode)
	populate(objectMap, "minDataStorageInTbs", d.MinDataStorageInTbs)
	populate(objectMap, "minDbNodeStoragePerNodeInGbs", d.MinDbNodeStoragePerNodeInGbs)
	populate(objectMap, "minMemoryPerNodeInGbs", d.MinMemoryPerNodeInGbs)
	populate(objectMap, "minStorageCount", d.MinStorageCount)
	populate(objectMap, "minimumCoreCount", d.MinimumCoreCount)
	populate(objectMap, "minimumNodeCount", d.MinimumNodeCount)
	populate(objectMap, "runtimeMinimumCoreCount", d.RuntimeMinimumCoreCount)
	populate(objectMap, "shapeFamily", d.ShapeFamily)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeProperties.
func (d *DbSystemShapeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableCoreCount":
			err = unpopulate(val, "AvailableCoreCount", &d.AvailableCoreCount)
			delete(rawMsg, key)
		case "availableCoreCountPerNode":
			err = unpopulate(val, "AvailableCoreCountPerNode", &d.AvailableCoreCountPerNode)
			delete(rawMsg, key)
		case "availableDataStorageInTbs":
			err = unpopulate(val, "AvailableDataStorageInTbs", &d.AvailableDataStorageInTbs)
			delete(rawMsg, key)
		case "availableDataStoragePerServerInTbs":
			err = unpopulate(val, "AvailableDataStoragePerServerInTbs", &d.AvailableDataStoragePerServerInTbs)
			delete(rawMsg, key)
		case "availableDbNodePerNodeInGbs":
			err = unpopulate(val, "AvailableDbNodePerNodeInGbs", &d.AvailableDbNodePerNodeInGbs)
			delete(rawMsg, key)
		case "availableDbNodeStorageInGbs":
			err = unpopulate(val, "AvailableDbNodeStorageInGbs", &d.AvailableDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "availableMemoryInGbs":
			err = unpopulate(val, "AvailableMemoryInGbs", &d.AvailableMemoryInGbs)
			delete(rawMsg, key)
		case "availableMemoryPerNodeInGbs":
			err = unpopulate(val, "AvailableMemoryPerNodeInGbs", &d.AvailableMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "coreCountIncrement":
			err = unpopulate(val, "CoreCountIncrement", &d.CoreCountIncrement)
			delete(rawMsg, key)
		case "maxStorageCount":
			err = unpopulate(val, "MaxStorageCount", &d.MaxStorageCount)
			delete(rawMsg, key)
		case "maximumNodeCount":
			err = unpopulate(val, "MaximumNodeCount", &d.MaximumNodeCount)
			delete(rawMsg, key)
		case "minCoreCountPerNode":
			err = unpopulate(val, "MinCoreCountPerNode", &d.MinCoreCountPerNode)
			delete(rawMsg, key)
		case "minDataStorageInTbs":
			err = unpopulate(val, "MinDataStorageInTbs", &d.MinDataStorageInTbs)
			delete(rawMsg, key)
		case "minDbNodeStoragePerNodeInGbs":
			err = unpopulate(val, "MinDbNodeStoragePerNodeInGbs", &d.MinDbNodeStoragePerNodeInGbs)
			delete(rawMsg, key)
		case "minMemoryPerNodeInGbs":
			err = unpopulate(val, "MinMemoryPerNodeInGbs", &d.MinMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "minStorageCount":
			err = unpopulate(val, "MinStorageCount", &d.MinStorageCount)
			delete(rawMsg, key)
		case "minimumCoreCount":
			err = unpopulate(val, "MinimumCoreCount", &d.MinimumCoreCount)
			delete(rawMsg, key)
		case "minimumNodeCount":
			err = unpopulate(val, "MinimumNodeCount", &d.MinimumNodeCount)
			delete(rawMsg, key)
		case "runtimeMinimumCoreCount":
			err = unpopulate(val, "RuntimeMinimumCoreCount", &d.RuntimeMinimumCoreCount)
			delete(rawMsg, key)
		case "shapeFamily":
			err = unpopulate(val, "ShapeFamily", &d.ShapeFamily)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedPatchingTime.
func (e EstimatedPatchingTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedDbServerPatchingTime", e.EstimatedDbServerPatchingTime)
	populate(objectMap, "estimatedNetworkSwitchesPatchingTime", e.EstimatedNetworkSwitchesPatchingTime)
	populate(objectMap, "estimatedStorageServerPatchingTime", e.EstimatedStorageServerPatchingTime)
	populate(objectMap, "totalEstimatedPatchingTime", e.TotalEstimatedPatchingTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedPatchingTime.
func (e *EstimatedPatchingTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedDbServerPatchingTime":
			err = unpopulate(val, "EstimatedDbServerPatchingTime", &e.EstimatedDbServerPatchingTime)
			delete(rawMsg, key)
		case "estimatedNetworkSwitchesPatchingTime":
			err = unpopulate(val, "EstimatedNetworkSwitchesPatchingTime", &e.EstimatedNetworkSwitchesPatchingTime)
			delete(rawMsg, key)
		case "estimatedStorageServerPatchingTime":
			err = unpopulate(val, "EstimatedStorageServerPatchingTime", &e.EstimatedStorageServerPatchingTime)
			delete(rawMsg, key)
		case "totalEstimatedPatchingTime":
			err = unpopulate(val, "TotalEstimatedPatchingTime", &e.TotalEstimatedPatchingTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadataIormConfig.
func (e ExadataIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbPlans", e.DbPlans)
	populate(objectMap, "lifecycleDetails", e.LifecycleDetails)
	populate(objectMap, "objective", e.Objective)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadataIormConfig.
func (e *ExadataIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbPlans":
			err = unpopulate(val, "DbPlans", &e.DbPlans)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &e.LifecycleDetails)
			delete(rawMsg, key)
		case "objective":
			err = unpopulate(val, "Objective", &e.Objective)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersion.
func (g GiVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersion.
func (g *GiVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionListResult.
func (g GiVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionListResult.
func (g *GiVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionProperties.
func (g GiVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "version", g.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionProperties.
func (g *GiVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "version":
			err = unpopulate(val, "Version", &g.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindow.
func (m MaintenanceWindow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customActionTimeoutInMins", m.CustomActionTimeoutInMins)
	populate(objectMap, "daysOfWeek", m.DaysOfWeek)
	populate(objectMap, "hoursOfDay", m.HoursOfDay)
	populate(objectMap, "isCustomActionTimeoutEnabled", m.IsCustomActionTimeoutEnabled)
	populate(objectMap, "isMonthlyPatchingEnabled", m.IsMonthlyPatchingEnabled)
	populate(objectMap, "leadTimeInWeeks", m.LeadTimeInWeeks)
	populate(objectMap, "months", m.Months)
	populate(objectMap, "patchingMode", m.PatchingMode)
	populate(objectMap, "preference", m.Preference)
	populate(objectMap, "weeksOfMonth", m.WeeksOfMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceWindow.
func (m *MaintenanceWindow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customActionTimeoutInMins":
			err = unpopulate(val, "CustomActionTimeoutInMins", &m.CustomActionTimeoutInMins)
			delete(rawMsg, key)
		case "daysOfWeek":
			err = unpopulate(val, "DaysOfWeek", &m.DaysOfWeek)
			delete(rawMsg, key)
		case "hoursOfDay":
			err = unpopulate(val, "HoursOfDay", &m.HoursOfDay)
			delete(rawMsg, key)
		case "isCustomActionTimeoutEnabled":
			err = unpopulate(val, "IsCustomActionTimeoutEnabled", &m.IsCustomActionTimeoutEnabled)
			delete(rawMsg, key)
		case "isMonthlyPatchingEnabled":
			err = unpopulate(val, "IsMonthlyPatchingEnabled", &m.IsMonthlyPatchingEnabled)
			delete(rawMsg, key)
		case "leadTimeInWeeks":
			err = unpopulate(val, "LeadTimeInWeeks", &m.LeadTimeInWeeks)
			delete(rawMsg, key)
		case "months":
			err = unpopulate(val, "Months", &m.Months)
			delete(rawMsg, key)
		case "patchingMode":
			err = unpopulate(val, "PatchingMode", &m.PatchingMode)
			delete(rawMsg, key)
		case "preference":
			err = unpopulate(val, "Preference", &m.Preference)
			delete(rawMsg, key)
		case "weeksOfMonth":
			err = unpopulate(val, "WeeksOfMonth", &m.WeeksOfMonth)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Month.
func (m Month) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Month.
func (m *Month) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscription.
func (o OracleSubscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscription.
func (o *OracleSubscription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionListResult.
func (o OracleSubscriptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionListResult.
func (o *OracleSubscriptionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionProperties.
func (o OracleSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloudAccountId", o.CloudAccountID)
	populate(objectMap, "cloudAccountState", o.CloudAccountState)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "saasSubscriptionId", o.SaasSubscriptionID)
	populate(objectMap, "termUnit", o.TermUnit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionProperties.
func (o *OracleSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudAccountId":
			err = unpopulate(val, "CloudAccountID", &o.CloudAccountID)
			delete(rawMsg, key)
		case "cloudAccountState":
			err = unpopulate(val, "CloudAccountState", &o.CloudAccountState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &o.ProvisioningState)
			delete(rawMsg, key)
		case "saasSubscriptionId":
			err = unpopulate(val, "SaasSubscriptionID", &o.SaasSubscriptionID)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &o.TermUnit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdate.
func (o OracleSubscriptionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdate.
func (o *OracleSubscriptionUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdateProperties.
func (o OracleSubscriptionUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "termUnit", o.TermUnit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdateProperties.
func (o *OracleSubscriptionUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "termUnit":
			err = unpopulate(val, "TermUnit", &o.TermUnit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Plan.
func (p Plan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "promotionCode", p.PromotionCode)
	populate(objectMap, "publisher", p.Publisher)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Plan.
func (p *Plan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &p.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressProperties.
func (p PrivateIPAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "hostnameLabel", p.HostnameLabel)
	populate(objectMap, "ipAddress", p.IPAddress)
	populate(objectMap, "ocid", p.Ocid)
	populate(objectMap, "subnetId", p.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressProperties.
func (p *PrivateIPAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "hostnameLabel":
			err = unpopulate(val, "HostnameLabel", &p.HostnameLabel)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &p.IPAddress)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &p.Ocid)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressesFilter.
func (p PrivateIPAddressesFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "subnetId", p.SubnetID)
	populate(objectMap, "vnicId", p.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressesFilter.
func (p *PrivateIPAddressesFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &p.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SaasSubscriptionDetails.
func (s SaasSubscriptionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "isAutoRenew", s.IsAutoRenew)
	populate(objectMap, "isFreeTrial", s.IsFreeTrial)
	populate(objectMap, "offerId", s.OfferID)
	populate(objectMap, "planId", s.PlanID)
	populate(objectMap, "publisherId", s.PublisherID)
	populate(objectMap, "purchaserEmailId", s.PurchaserEmailID)
	populate(objectMap, "purchaserTenantId", s.PurchaserTenantID)
	populate(objectMap, "saasSubscriptionStatus", s.SaasSubscriptionStatus)
	populate(objectMap, "subscriptionName", s.SubscriptionName)
	populate(objectMap, "termUnit", s.TermUnit)
	populateDateTimeRFC3339(objectMap, "timeCreated", s.TimeCreated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SaasSubscriptionDetails.
func (s *SaasSubscriptionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "isAutoRenew":
			err = unpopulate(val, "IsAutoRenew", &s.IsAutoRenew)
			delete(rawMsg, key)
		case "isFreeTrial":
			err = unpopulate(val, "IsFreeTrial", &s.IsFreeTrial)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, "OfferID", &s.OfferID)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, "PlanID", &s.PlanID)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, "PublisherID", &s.PublisherID)
			delete(rawMsg, key)
		case "purchaserEmailId":
			err = unpopulate(val, "PurchaserEmailID", &s.PurchaserEmailID)
			delete(rawMsg, key)
		case "purchaserTenantId":
			err = unpopulate(val, "PurchaserTenantID", &s.PurchaserTenantID)
			delete(rawMsg, key)
		case "saasSubscriptionStatus":
			err = unpopulate(val, "SaasSubscriptionStatus", &s.SaasSubscriptionStatus)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, "SubscriptionName", &s.SubscriptionName)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &s.TermUnit)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &s.TimeCreated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddress.
func (v VirtualNetworkAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddress.
func (v *VirtualNetworkAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressListResult.
func (v VirtualNetworkAddressListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressListResult.
func (v *VirtualNetworkAddressListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressProperties.
func (v VirtualNetworkAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domain", v.Domain)
	populate(objectMap, "ipAddress", v.IPAddress)
	populate(objectMap, "lifecycleDetails", v.LifecycleDetails)
	populate(objectMap, "ocid", v.Ocid)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "timeAssigned", v.TimeAssigned)
	populate(objectMap, "vmOcid", v.VMOcid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressProperties.
func (v *VirtualNetworkAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, "Domain", &v.Domain)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &v.IPAddress)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &v.LifecycleDetails)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &v.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "timeAssigned":
			err = unpopulateDateTimeRFC3339(val, "TimeAssigned", &v.TimeAssigned)
			delete(rawMsg, key)
		case "vmOcid":
			err = unpopulate(val, "VMOcid", &v.VMOcid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
