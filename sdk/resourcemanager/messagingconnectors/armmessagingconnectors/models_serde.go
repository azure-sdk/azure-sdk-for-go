//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmessagingconnectors

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type BitCoinSourceConnectorProperties.
func (b BitCoinSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorDirection", b.ConnectorDirection)
	populate(objectMap, "connectorState", b.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeBitCoinSource
	populate(objectMap, "eventHubConfig", b.EventHubConfig)
	populate(objectMap, "maxTasks", b.MaxTasks)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "valueConverter", b.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BitCoinSourceConnectorProperties.
func (b *BitCoinSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &b.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &b.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &b.ConnectorType)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &b.EventHubConfig)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &b.MaxTasks)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &b.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfluentSourceConnectorProperties.
func (c ConfluentSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoOffsetReset", c.AutoOffsetReset)
	populate(objectMap, "bootstrapServers", c.BootstrapServers)
	populate(objectMap, "connectorDirection", c.ConnectorDirection)
	populate(objectMap, "connectorState", c.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeConfluentSource
	populate(objectMap, "consumerGroup", c.ConsumerGroup)
	populate(objectMap, "eventHubConfig", c.EventHubConfig)
	populate(objectMap, "maxTasks", c.MaxTasks)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "topic", c.Topic)
	populate(objectMap, "user", c.User)
	populate(objectMap, "valueConverter", c.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfluentSourceConnectorProperties.
func (c *ConfluentSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoOffsetReset":
			err = unpopulate(val, "AutoOffsetReset", &c.AutoOffsetReset)
			delete(rawMsg, key)
		case "bootstrapServers":
			err = unpopulate(val, "BootstrapServers", &c.BootstrapServers)
			delete(rawMsg, key)
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &c.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &c.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &c.ConnectorType)
			delete(rawMsg, key)
		case "consumerGroup":
			err = unpopulate(val, "ConsumerGroup", &c.ConsumerGroup)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &c.EventHubConfig)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &c.MaxTasks)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "topic":
			err = unpopulate(val, "Topic", &c.Topic)
			delete(rawMsg, key)
		case "user":
			err = unpopulate(val, "User", &c.User)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &c.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorInstance.
func (c ConnectorInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorInstance.
func (c *ConnectorInstance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			c.Properties, err = unmarshalConnectorPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorInstanceListResult.
func (c ConnectorInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorInstanceListResult.
func (c *ConnectorInstanceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorInstanceTagsUpdate.
func (c ConnectorInstanceTagsUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorInstanceTagsUpdate.
func (c *ConnectorInstanceTagsUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorProperties.
func (c ConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorDirection", c.ConnectorDirection)
	populate(objectMap, "connectorState", c.ConnectorState)
	objectMap["connectorType"] = c.ConnectorType
	populate(objectMap, "eventHubConfig", c.EventHubConfig)
	populate(objectMap, "maxTasks", c.MaxTasks)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "valueConverter", c.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorProperties.
func (c *ConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &c.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &c.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &c.ConnectorType)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &c.EventHubConfig)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &c.MaxTasks)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &c.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSourceConnectorProperties.
func (c CosmosDbSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorDirection", c.ConnectorDirection)
	populate(objectMap, "connectorState", c.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeCosmosDbSource
	populate(objectMap, "container", c.Container)
	populate(objectMap, "cosmosEndpoint", c.CosmosEndpoint)
	populate(objectMap, "databaseName", c.DatabaseName)
	populate(objectMap, "eventHubConfig", c.EventHubConfig)
	populate(objectMap, "masterKey", c.MasterKey)
	populate(objectMap, "maxTasks", c.MaxTasks)
	populate(objectMap, "offsetPolicy", c.OffsetPolicy)
	populate(objectMap, "pollIntervalInMs", c.PollIntervalInMs)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "valueConverter", c.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSourceConnectorProperties.
func (c *CosmosDbSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &c.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &c.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &c.ConnectorType)
			delete(rawMsg, key)
		case "container":
			err = unpopulate(val, "Container", &c.Container)
			delete(rawMsg, key)
		case "cosmosEndpoint":
			err = unpopulate(val, "CosmosEndpoint", &c.CosmosEndpoint)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &c.DatabaseName)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &c.EventHubConfig)
			delete(rawMsg, key)
		case "masterKey":
			err = unpopulate(val, "MasterKey", &c.MasterKey)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &c.MaxTasks)
			delete(rawMsg, key)
		case "offsetPolicy":
			err = unpopulate(val, "OffsetPolicy", &c.OffsetPolicy)
			delete(rawMsg, key)
		case "pollIntervalInMs":
			err = unpopulate(val, "PollIntervalInMs", &c.PollIntervalInMs)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &c.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventHubConfig.
func (e EventHubConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionString", e.ConnectionString)
	populate(objectMap, "eventHubName", e.EventHubName)
	populate(objectMap, "namespaceHostName", e.NamespaceHostName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubConfig.
func (e *EventHubConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &e.ConnectionString)
			delete(rawMsg, key)
		case "eventHubName":
			err = unpopulate(val, "EventHubName", &e.EventHubName)
			delete(rawMsg, key)
		case "namespaceHostName":
			err = unpopulate(val, "NamespaceHostName", &e.NamespaceHostName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GooglePubSubSourceConnectorProperties.
func (g GooglePubSubSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", g.AccountKey)
	populate(objectMap, "connectorDirection", g.ConnectorDirection)
	populate(objectMap, "connectorState", g.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeGooglePubSubSource
	populate(objectMap, "eventHubConfig", g.EventHubConfig)
	populate(objectMap, "maxTasks", g.MaxTasks)
	populate(objectMap, "projectId", g.ProjectID)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "subscriptionName", g.SubscriptionName)
	populate(objectMap, "valueConverter", g.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GooglePubSubSourceConnectorProperties.
func (g *GooglePubSubSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			err = unpopulate(val, "AccountKey", &g.AccountKey)
			delete(rawMsg, key)
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &g.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &g.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &g.ConnectorType)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &g.EventHubConfig)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &g.MaxTasks)
			delete(rawMsg, key)
		case "projectId":
			err = unpopulate(val, "ProjectID", &g.ProjectID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, "SubscriptionName", &g.SubscriptionName)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &g.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KinesisSourceConnectorProperties.
func (k KinesisSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "awsAccessKeyId", k.AwsAccessKeyID)
	populate(objectMap, "awsKinesisRegion", k.AwsKinesisRegion)
	populate(objectMap, "awsKinesisStreamName", k.AwsKinesisStreamName)
	populate(objectMap, "awsSecretAccessKey", k.AwsSecretAccessKey)
	populate(objectMap, "connectorDirection", k.ConnectorDirection)
	populate(objectMap, "connectorState", k.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeKinesisSource
	populate(objectMap, "eventHubConfig", k.EventHubConfig)
	populate(objectMap, "maxTasks", k.MaxTasks)
	populate(objectMap, "provisioningState", k.ProvisioningState)
	populate(objectMap, "valueConverter", k.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KinesisSourceConnectorProperties.
func (k *KinesisSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "awsAccessKeyId":
			err = unpopulate(val, "AwsAccessKeyID", &k.AwsAccessKeyID)
			delete(rawMsg, key)
		case "awsKinesisRegion":
			err = unpopulate(val, "AwsKinesisRegion", &k.AwsKinesisRegion)
			delete(rawMsg, key)
		case "awsKinesisStreamName":
			err = unpopulate(val, "AwsKinesisStreamName", &k.AwsKinesisStreamName)
			delete(rawMsg, key)
		case "awsSecretAccessKey":
			err = unpopulate(val, "AwsSecretAccessKey", &k.AwsSecretAccessKey)
			delete(rawMsg, key)
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &k.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &k.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &k.ConnectorType)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &k.EventHubConfig)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &k.MaxTasks)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &k.ProvisioningState)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &k.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLSourceConnectorProperties.
func (p PostgreSQLSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorDirection", p.ConnectorDirection)
	populate(objectMap, "connectorState", p.ConnectorState)
	objectMap["connectorType"] = ConnectorTypePostgreSQLSource
	populate(objectMap, "databaseName", p.DatabaseName)
	populate(objectMap, "eventHubConfig", p.EventHubConfig)
	populate(objectMap, "hostName", p.HostName)
	populate(objectMap, "maxTasks", p.MaxTasks)
	populate(objectMap, "password", p.Password)
	populate(objectMap, "port", p.Port)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "replicationSlotName", p.ReplicationSlotName)
	populate(objectMap, "username", p.Username)
	populate(objectMap, "valueConverter", p.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLSourceConnectorProperties.
func (p *PostgreSQLSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &p.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &p.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &p.ConnectorType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &p.DatabaseName)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &p.EventHubConfig)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &p.HostName)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &p.MaxTasks)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &p.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &p.Port)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "replicationSlotName":
			err = unpopulate(val, "ReplicationSlotName", &p.ReplicationSlotName)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &p.Username)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &p.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSourceConnectorProperties.
func (s SQLServerSourceConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectorDirection", s.ConnectorDirection)
	populate(objectMap, "connectorState", s.ConnectorState)
	objectMap["connectorType"] = ConnectorTypeSQLServerSource
	populate(objectMap, "databaseName", s.DatabaseName)
	populate(objectMap, "eventHubConfig", s.EventHubConfig)
	populate(objectMap, "hostName", s.HostName)
	populate(objectMap, "maxTasks", s.MaxTasks)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "port", s.Port)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "username", s.Username)
	populate(objectMap, "valueConverter", s.ValueConverter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSourceConnectorProperties.
func (s *SQLServerSourceConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectorDirection":
			err = unpopulate(val, "ConnectorDirection", &s.ConnectorDirection)
			delete(rawMsg, key)
		case "connectorState":
			err = unpopulate(val, "ConnectorState", &s.ConnectorState)
			delete(rawMsg, key)
		case "connectorType":
			err = unpopulate(val, "ConnectorType", &s.ConnectorType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &s.DatabaseName)
			delete(rawMsg, key)
		case "eventHubConfig":
			err = unpopulate(val, "EventHubConfig", &s.EventHubConfig)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &s.HostName)
			delete(rawMsg, key)
		case "maxTasks":
			err = unpopulate(val, "MaxTasks", &s.MaxTasks)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &s.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, "Port", &s.Port)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &s.Username)
			delete(rawMsg, key)
		case "valueConverter":
			err = unpopulate(val, "ValueConverter", &s.ValueConverter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
