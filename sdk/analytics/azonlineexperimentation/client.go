// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azonlineexperimentation

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// Client contains the methods for the group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal *azcore.Client
	endpoint string
}

// CreateOrUpdateMetric - Creates or updates an experiment metric.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-05-31-preview
//   - experimentMetricID - Identifier for this experiment metric. Must start with a lowercase letter and contain only lowercase
//     letters, numbers, and underscores.
//   - resource - The resource instance.
//   - options - CreateOrUpdateMetricOptions contains the optional parameters for the Client.CreateOrUpdateMetric method.
func (client *Client) CreateOrUpdateMetric(ctx context.Context, experimentMetricID string, resource ExperimentMetric, options *CreateOrUpdateMetricOptions) (CreateOrUpdateMetricResponse, error) {
	var err error
	const operationName = "Client.CreateOrUpdateMetric"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateMetricCreateRequest(ctx, experimentMetricID, resource, options)
	if err != nil {
		return CreateOrUpdateMetricResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CreateOrUpdateMetricResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return CreateOrUpdateMetricResponse{}, err
	}
	resp, err := client.createOrUpdateMetricHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateMetricCreateRequest creates the CreateOrUpdateMetric request.
func (client *Client) createOrUpdateMetricCreateRequest(ctx context.Context, experimentMetricID string, resource ExperimentMetric, options *CreateOrUpdateMetricOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/experiment-metrics/{experimentMetricId}"
	if experimentMetricID == "" {
		return nil, errors.New("parameter experimentMetricID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{experimentMetricId}", url.PathEscape(experimentMetricID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-05-31-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
		return nil, err
	}
	return req, nil
}

// createOrUpdateMetricHandleResponse handles the CreateOrUpdateMetric response.
func (client *Client) createOrUpdateMetricHandleResponse(resp *http.Response) (CreateOrUpdateMetricResponse, error) {
	result := CreateOrUpdateMetricResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.XMSClientRequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ExperimentMetric); err != nil {
		return CreateOrUpdateMetricResponse{}, err
	}
	return result, nil
}

// DeleteMetric - Deletes an experiment metric.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-05-31-preview
//   - experimentMetricID - Identifier for this experiment metric. Must start with a lowercase letter and contain only lowercase
//     letters, numbers, and underscores.
//   - options - DeleteMetricOptions contains the optional parameters for the Client.DeleteMetric method.
func (client *Client) DeleteMetric(ctx context.Context, experimentMetricID string, options *DeleteMetricOptions) (DeleteMetricResponse, error) {
	var err error
	const operationName = "Client.DeleteMetric"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteMetricCreateRequest(ctx, experimentMetricID, options)
	if err != nil {
		return DeleteMetricResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeleteMetricResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return DeleteMetricResponse{}, err
	}
	resp, err := client.deleteMetricHandleResponse(httpResp)
	return resp, err
}

// deleteMetricCreateRequest creates the DeleteMetric request.
func (client *Client) deleteMetricCreateRequest(ctx context.Context, experimentMetricID string, options *DeleteMetricOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/experiment-metrics/{experimentMetricId}"
	if experimentMetricID == "" {
		return nil, errors.New("parameter experimentMetricID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{experimentMetricId}", url.PathEscape(experimentMetricID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-05-31-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.ClientRequestID}
	}
	return req, nil
}

// deleteMetricHandleResponse handles the DeleteMetric response.
func (client *Client) deleteMetricHandleResponse(resp *http.Response) (DeleteMetricResponse, error) {
	result := DeleteMetricResponse{}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.XMSClientRequestID = &val
	}
	return result, nil
}

// GetMetric - Fetches an experiment metric by ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-05-31-preview
//   - experimentMetricID - Identifier for this experiment metric. Must start with a lowercase letter and contain only lowercase
//     letters, numbers, and underscores.
//   - options - GetMetricOptions contains the optional parameters for the Client.GetMetric method.
func (client *Client) GetMetric(ctx context.Context, experimentMetricID string, options *GetMetricOptions) (GetMetricResponse, error) {
	var err error
	const operationName = "Client.GetMetric"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMetricCreateRequest(ctx, experimentMetricID, options)
	if err != nil {
		return GetMetricResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return GetMetricResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return GetMetricResponse{}, err
	}
	resp, err := client.getMetricHandleResponse(httpResp)
	return resp, err
}

// getMetricCreateRequest creates the GetMetric request.
func (client *Client) getMetricCreateRequest(ctx context.Context, experimentMetricID string, options *GetMetricOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/experiment-metrics/{experimentMetricId}"
	if experimentMetricID == "" {
		return nil, errors.New("parameter experimentMetricID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{experimentMetricId}", url.PathEscape(experimentMetricID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-05-31-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.ClientRequestID}
	}
	return req, nil
}

// getMetricHandleResponse handles the GetMetric response.
func (client *Client) getMetricHandleResponse(resp *http.Response) (GetMetricResponse, error) {
	result := GetMetricResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.XMSClientRequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ExperimentMetric); err != nil {
		return GetMetricResponse{}, err
	}
	return result, nil
}

// NewListMetricsPager - Lists experiment metrics.
//
// Generated from API version 2025-05-31-preview
//   - options - ListMetricsOptions contains the optional parameters for the Client.NewListMetricsPager method.
func (client *Client) NewListMetricsPager(options *ListMetricsOptions) *runtime.Pager[ListMetricsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ListMetricsResponse]{
		More: func(page ListMetricsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ListMetricsResponse) (ListMetricsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListMetricsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listMetricsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ListMetricsResponse{}, err
			}
			return client.listMetricsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *Client) listMetricsCreateRequest(ctx context.Context, options *ListMetricsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/experiment-metrics"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-05-31-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.ClientRequestID}
	}
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *Client) listMetricsHandleResponse(resp *http.Response) (ListMetricsResponse, error) {
	result := ListMetricsResponse{}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.XMSClientRequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedExperimentMetric); err != nil {
		return ListMetricsResponse{}, err
	}
	return result, nil
}

// ValidateMetric - Validates an experiment metric definition.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-05-31-preview
//   - body - Experiment metric input to validate
//   - options - ValidateMetricOptions contains the optional parameters for the Client.ValidateMetric method.
func (client *Client) ValidateMetric(ctx context.Context, body ExperimentMetric, options *ValidateMetricOptions) (ValidateMetricResponse, error) {
	var err error
	const operationName = "Client.ValidateMetric"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateMetricCreateRequest(ctx, body, options)
	if err != nil {
		return ValidateMetricResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ValidateMetricResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ValidateMetricResponse{}, err
	}
	resp, err := client.validateMetricHandleResponse(httpResp)
	return resp, err
}

// validateMetricCreateRequest creates the ValidateMetric request.
func (client *Client) validateMetricCreateRequest(ctx context.Context, body ExperimentMetric, options *ValidateMetricOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/experiment-metrics:validate"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-05-31-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// validateMetricHandleResponse handles the ValidateMetric response.
func (client *Client) validateMetricHandleResponse(resp *http.Response) (ValidateMetricResponse, error) {
	result := ValidateMetricResponse{}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.XMSClientRequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ExperimentMetricValidationResult); err != nil {
		return ValidateMetricResponse{}, err
	}
	return result, nil
}
